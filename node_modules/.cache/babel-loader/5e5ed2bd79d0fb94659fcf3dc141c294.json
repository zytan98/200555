{"ast":null,"code":"import { groupBy } from '@antv/util';\n/**\n * bidirectional-bar 处理数据, 通过 SERIES_FIELD_KEY 字段分成左右数据\n * @param xField\n * @param yField\n * @param data\n */\n\nexport function transformData(xField, yField, seriesField, data, reverse) {\n  var hopeData = [];\n  yField.forEach(function (d) {\n    data.forEach(function (k) {\n      var _a;\n\n      var obj = (_a = {}, _a[xField] = k[xField], _a[seriesField] = d, _a[d] = k[d], _a);\n      hopeData.push(obj);\n    });\n  });\n  var groupData = Object.values(groupBy(hopeData, seriesField));\n  var _a = groupData[0],\n      data1 = _a === void 0 ? [] : _a,\n      _b = groupData[1],\n      data2 = _b === void 0 ? [] : _b;\n  return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];\n}\n/**\n * 是否横向，默认空为横向\n * @param layout\n */\n\nexport function isHorizontal(layout) {\n  return layout !== 'vertical';\n}\n/**\n * 多 view 进行同步 padding 的自定义逻辑\n * @param chart\n * @param views\n * @param p\n */\n\nexport function syncViewPadding(chart, views, p) {\n  var v1 = views[0],\n      v2 = views[1];\n  var p1 = v1.autoPadding;\n  var p2 = v2.autoPadding;\n  var _a = chart.__axisPosition,\n      layout = _a.layout,\n      position = _a.position; // 目前只能根据布局的比例来判断 layout\n\n  if (isHorizontal(layout) && position === 'top') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position top 即为 v1 左边，中间间距设置就为 0\n     */\n    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);\n  }\n\n  if (isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position bottom 即为 v1 的右边，v1 right = right / 2  v2 left = right / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);\n  }\n\n  if (!isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 left 的间隔相等 left 取最大值\n     * position bottom 即为 v1 下边，v1 bottom = bottom / 2  v2 top = bottom / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    var left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);\n    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);\n  } // 垂直状态，不建议设置position 为 top， 还是做个兼容处理\n\n\n  if (!isHorizontal(layout) && position === 'top') {\n    var left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, 0, left);\n    v2.autoPadding = p.instance(0, p2.right, p1.top, left);\n  }\n}","map":{"version":3,"sources":["../../../src/plots/bidirectional-bar/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { groupBy } from '@antv/util';\nimport { Types } from '@antv/g2';\nimport { Datum } from '../../types';\nimport { BidirectionalBarOptions } from './types';\n\ntype TransformData = {\n  [key: string]: string | number;\n}[];\n\n/**\n * bidirectional-bar 处理数据, 通过 SERIES_FIELD_KEY 字段分成左右数据\n * @param xField\n * @param yField\n * @param data\n */\nexport function transformData(\n  xField: string,\n  yField: string[],\n  seriesField: string,\n  data: Datum,\n  reverse?: boolean\n): Types.Data[] {\n  const hopeData: TransformData = [];\n  yField.forEach((d: string) => {\n    data.forEach((k: any) => {\n      const obj = {\n        [xField]: k[xField],\n        [seriesField]: d,\n        [d]: k[d],\n      };\n      hopeData.push(obj);\n    });\n  });\n  const groupData = Object.values(groupBy(hopeData, seriesField));\n  const [data1 = [], data2 = []] = groupData;\n  return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];\n}\n\n/**\n * 是否横向，默认空为横向\n * @param layout\n */\nexport function isHorizontal(layout: BidirectionalBarOptions['layout']) {\n  return layout !== 'vertical';\n}\n\n/**\n * 多 view 进行同步 padding 的自定义逻辑\n * @param chart\n * @param views\n * @param p\n */\nexport function syncViewPadding(chart: any, views: any, p: any) {\n  const [v1, v2] = views;\n  const p1 = v1.autoPadding;\n  const p2 = v2.autoPadding;\n  const { layout, position } = chart.__axisPosition;\n  // 目前只能根据布局的比例来判断 layout\n  if (isHorizontal(layout) && position === 'top') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position top 即为 v1 左边，中间间距设置就为 0\n     */\n    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);\n  }\n  if (isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position bottom 即为 v1 的右边，v1 right = right / 2  v2 left = right / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);\n  }\n  if (!isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 left 的间隔相等 left 取最大值\n     * position bottom 即为 v1 下边，v1 bottom = bottom / 2  v2 top = bottom / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    const left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);\n    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);\n  }\n  // 垂直状态，不建议设置position 为 top， 还是做个兼容处理\n  if (!isHorizontal(layout) && position === 'top') {\n    const left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, 0, left);\n    v2.autoPadding = p.instance(0, p2.right, p1.top, left);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}