{"ast":null,"code":"import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray, reduce, size } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  size: [1, 1],\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  },\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true\n};\nexport function partition(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var partition = function (data) {\n    return d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n    /**\n     * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n     * for example:\n     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n     * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n     * sum 函数中，d 为用户传入的 data, children 为保留字段\n     */\n    d3Hierarchy.hierarchy(data).sum(function (d) {\n      return size(d.children) ? options.ignoreParentValue ? 0 : d[field] - reduce(d.children, function (a, b) {\n        return a + b[field];\n      }, 0) : d[field];\n    }).sort(options.sort));\n  };\n\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    var _a, _b;\n\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0]; // 旭日图兼容下 旧版本\n\n    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);\n    node.data.name = node.name;\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"sources":["../../../src/utils/hierarchy/partition.ts"],"names":[],"mappings":"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","sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray, reduce, size } from '@antv/util';\nimport { getField, getAllNodes } from './util';\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  size: [1, 1], // width, height\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true,\n};\n\nexport interface Options {\n  field: string;\n  size?: [number, number];\n  round?: boolean;\n  ratio?: number;\n  padding?: number;\n  sort?: Function;\n  as?: [string, string];\n\n  ignoreParentValue?: boolean;\n}\n\nexport function partition(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const partition = (data) =>\n    d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n      /**\n       * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n       * for example:\n       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n       * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n       * sum 函数中，d 为用户传入的 data, children 为保留字段\n       */\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) =>\n          size(d.children)\n            ? options.ignoreParentValue\n              ? 0\n              : d[field] - reduce(d.children, (a, b) => a + b[field], 0)\n            : d[field]\n        )\n        .sort(options.sort)\n    );\n  const root = partition(data);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n\n  root.each((node) => {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    // 旭日图兼容下 旧版本\n    node.name = node.name || node.data?.name || node.data?.label;\n    node.data.name = node.name;\n\n    ['x0', 'x1', 'y0', 'y1'].forEach((prop) => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n\n  return getAllNodes(root);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}