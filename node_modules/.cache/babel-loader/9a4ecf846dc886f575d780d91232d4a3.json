{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { gl, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { inject, injectable, named } from 'inversify';\nimport { encodePickingColor } from '../../utils/picking';\nimport { Renderable } from '../Renderable';\n/* babel-plugin-inline-import './shaders/webgl.point.frag.glsl' */\n\nvar pointFrag = \"uniform float u_blur : 0.05;\\nuniform float u_opacity : 0.7;\\nuniform float u_stroke_width : 0.01;\\nuniform vec4 u_stroke_color : [0, 0, 0, 0];\\nuniform float u_stroke_opacity : 1;\\n\\nvarying vec4 v_color;\\nvarying vec4 v_data;\\nvarying float v_radius;\\n\\n#pragma include \\\"sdf2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n\\n  float antialiasblur = v_data.z;\\n  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  // if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  // } else if (shape == 1) {\\n  //   outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n  //   inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  // } else if (shape == 2) {\\n  //   outer_df = sdBox(v_data.xy, vec2(1.));\\n  //   inner_df = sdBox(v_data.xy, vec2(r));\\n  // } else if (shape == 3) {\\n  //   outer_df = sdPentagon(v_data.xy, 0.8);\\n  //   inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  // } else if (shape == 4) {\\n  //   outer_df = sdHexagon(v_data.xy, 0.8);\\n  //   inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  // } else if (shape == 5) {\\n  //   outer_df = sdOctogon(v_data.xy, 1.0);\\n  //   inner_df = sdOctogon(v_data.xy, r);\\n  // } else if (shape == 6) {\\n  //   outer_df = sdHexagram(v_data.xy, 0.52);\\n  //   inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  // } else if (shape == 7) {\\n  //   outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n  //   inner_df = sdRhombus(v_data.xy, vec2(r));\\n  // } else if (shape == 8) {\\n  //   outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n  //   inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  // }\\n\\n  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiased_blur,\\n    0.0,\\n    inner_df\\n  );\\n  vec4 strokeColor = u_stroke_color == vec4(0) ? v_color : u_stroke_color;\\n\\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n  gl_FragColor.a = gl_FragColor.a * opacity_t;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\";\n/* babel-plugin-inline-import './shaders/webgl.point.vert.glsl' */\n\nvar pointVert = \"attribute vec2 position;\\nattribute vec4 color;\\nattribute float shape;\\nattribute vec2 offset;\\nattribute float size;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 modelViewMatrix;\\n\\nuniform float u_stroke_width : 0.01;\\nuniform float u_device_pixel_ratio;\\nuniform vec2 u_viewport;\\n\\nvarying vec4 v_color;\\nvarying vec4 v_data;\\nvarying float v_radius;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = color;\\n  v_radius = size;\\n\\n  lowp float antialiasblur = 1.0 / u_device_pixel_ratio * (size + u_stroke_width);\\n\\n  // construct point coords\\n  v_data = vec4(position, antialiasblur, shape);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix\\n    * vec4(position * size + offset, 0.0, 1.0);\\n\\n  setPickingColor(a_PickingColor);\\n}\";\nvar pointShapes = ['circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'];\nexport\n/**\n * Use SDF to draw 2D point with stroke.\n */\nvar Point = (_dec = injectable(), _dec2 = inject(IDENTIFIER.Systems), _dec3 = named(IDENTIFIER.MaterialSystem), _dec4 = inject(IDENTIFIER.Systems), _dec5 = named(IDENTIFIER.GeometrySystem), _dec6 = inject(IDENTIFIER.ShaderModuleService), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Renderable) {\n  _inherits(Point, _Renderable);\n\n  var _super = _createSuper(Point);\n\n  function Point() {\n    var _this;\n\n    _classCallCheck(this, Point);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _initializerDefineProperty(_this, \"materialSystem\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"geometrySystem\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"shaderModuleService\", _descriptor3, _assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(Point, [{\n    key: \"onAttributeChanged\",\n    value: function onAttributeChanged(_ref) {\n      var name = _ref.name,\n          data = _ref.data;\n      var mesh = this.getMeshComponent();\n\n      if (mesh && mesh.material) {\n        if (name === 'strokeWidth') {\n          mesh.material.setUniform('u_stroke_width', data);\n        } else if (name === 'strokeColor') {\n          mesh.material.setUniform('u_stroke_color', data);\n        } else if (name === 'strokeOpacity') {\n          mesh.material.setUniform('u_stroke_opacity', data);\n        } else if (name === 'opacity') {\n          mesh.material.setUniform('u_opacity', data);\n        } else if (name === 'blur') {\n          mesh.material.setUniform('u_blur', data);\n        }\n      }\n    }\n  }, {\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      this.shaderModuleService.registerModule('grid', {\n        vs: pointVert,\n        fs: pointFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('grid'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          extractedUniforms = _this$shaderModuleSer.uniforms;\n\n      var material = this.materialSystem.createShaderMaterial({\n        vertexShader: vs,\n        fragmentShader: fs,\n        cull: {\n          enable: false\n        },\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            srcAlpha: 1,\n            dstAlpha: 1\n          }\n        }\n      }); // TODO: support define stroke-relative props per point\n\n      material.setUniform(_objectSpread({\n        u_device_pixel_ratio: window.devicePixelRatio\n      }, extractedUniforms));\n      var attributes = this.buildAttributes();\n      var geometry = this.geometrySystem.createInstancedBufferGeometry({\n        maxInstancedCount: attributes.instancedOffsets.length / 2,\n        vertexCount: 6\n      });\n      geometry.setIndex([0, 2, 1, 0, 3, 2]);\n      geometry.setAttribute('position', Float32Array.from(attributes.positions), {\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      geometry.setAttribute('offset', Float32Array.from(attributes.instancedOffsets), {\n        arrayStride: 4 * 2,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      geometry.setAttribute('color', Float32Array.from(attributes.instancedColors), {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      geometry.setAttribute('size', Float32Array.from(attributes.instancedSizes), {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 3,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n      geometry.setAttribute('shape', Float32Array.from(attributes.instancedShapes), {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 4,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n      geometry.setAttribute('a_PickingColor', Float32Array.from(attributes.instancedPickingColors), {\n        arrayStride: 4 * 3,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 6,\n          offset: 0,\n          format: 'float3'\n        }]\n      });\n      this.setMaterial(material);\n      this.setGeometry(geometry);\n    }\n  }, {\n    key: \"buildAttribute\",\n    value: function buildAttribute(config, attributes, index) {\n      var _attributes$instanced, _attributes$instanced2, _attributes$instanced3, _attributes$instanced4;\n\n      (_attributes$instanced = attributes.instancedPickingColors).push.apply(_attributes$instanced, _toConsumableArray(encodePickingColor(config.id || index)));\n\n      attributes.instancedShapes.push(pointShapes.indexOf(config.shape || 'circle'));\n\n      (_attributes$instanced2 = attributes.instancedColors).push.apply(_attributes$instanced2, _toConsumableArray(config.color || [1, 0, 0, 1]));\n\n      (_attributes$instanced3 = attributes.instancedOffsets).push.apply(_attributes$instanced3, _toConsumableArray(config.position || [0, 0]));\n\n      (_attributes$instanced4 = attributes.instancedSizes).push.apply(_attributes$instanced4, _toConsumableArray(config.size || [0.2, 0.2]));\n    }\n  }, {\n    key: \"buildAttributes\",\n    value: function buildAttributes() {\n      var _this2 = this;\n\n      var attributes = {\n        positions: [1, 1, 1, -1, -1, -1, -1, 1],\n        instancedOffsets: [],\n        instancedColors: [],\n        instancedSizes: [],\n        instancedShapes: [],\n        instancedPickingColors: []\n      };\n\n      if (Array.isArray(this.config)) {\n        this.config.forEach(function (config, i) {\n          _this2.buildAttribute(config, attributes, i);\n        });\n      } else {\n        this.buildAttribute(this.config, attributes, 0);\n      }\n\n      return attributes;\n    }\n  }]);\n\n  return Point;\n}(Renderable), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"materialSystem\", [_dec2, _dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"geometrySystem\", [_dec4, _dec5], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec6], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"sources":["../../../src/renderable/point/index.ts"],"names":["pointShapes","injectable","Point","inject","IDENTIFIER","named","name","data","mesh","vs","fs","pointFrag","extractedUniforms","material","vertexShader","fragmentShader","cull","enable","depth","blend","func","srcRGB","gl","dstRGB","srcAlpha","dstAlpha","u_device_pixel_ratio","window","devicePixelRatio","attributes","geometry","maxInstancedCount","vertexCount","Float32Array","arrayStride","stepMode","shaderLocation","offset","format","encodePickingColor","config","positions","instancedOffsets","instancedColors","instancedSizes","instancedShapes","instancedPickingColors","Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,EAAA,EAAA,UAAA,QAAA,qBAAA;AAQA,SAAA,MAAA,EAAA,UAAA,EAAA,KAAA,QAAA,WAAA;AACA,SAAA,kBAAA,QAAA,qBAAA;AACA,SAAA,UAAA,QAAA,eAAA;;;;;;;AAIA,IAAMA,WAAW,GAAG,CAAA,QAAA,EAAA,UAAA,EAAA,QAAA,EAAA,UAAA,EAAA,SAAA,EAAA,SAAA,EAAA,UAAA,EAAA,SAAA,EAApB,QAAoB,CAApB;AA8CA;AAJA;AACA;AACA;AAEA,IAAaE,KAAb,IAAA,IAAA,GADCD,UAAU,EACX,EAAA,KAAA,GAGGE,MAAM,CAACC,UAAU,CAHpB,OAGS,CAHT,EAAA,KAAA,GAIGC,KAAK,CAACD,UAAU,CAJnB,cAIQ,CAJR,EAAA,KAAA,GAOGD,MAAM,CAACC,UAAU,CAPpB,OAOS,CAPT,EAAA,KAAA,GAQGC,KAAK,CAACD,UAAU,CARnB,cAQQ,CARR,EAAA,KAAA,GAWGD,MAAM,CAACC,UAAU,CAXpB,mBAWS,CAXT,EAAA,IAAA,CAAA,MAAA,IAAA,OAAA,IAAA,KAAA,GAAA,aAAA,UAAA,WAAA,EAAA;AAAA,EAAA,SAAA,CAAA,KAAA,EAAA,WAAA,CAAA;;AAAA,MAAA,MAAA,GAAA,YAAA,CAAA,KAAA,CAAA;;AAAA,WAAA,KAAA,GAAA;AAAA,QAAA,KAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;AAAA,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAA,IAAA,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAA,MAAA,IAAA,CAAA,IAAA,CAAA,GAAA,SAAA,CAAA,IAAA,CAAA;AAAA;;AAAA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,IAAA,EAAA,MAAA,CAAA,IAAA,CAAA,CAAA;;AAAA,IAAA,0BAAA,CAAA,KAAA,EAAA,gBAAA,EAAA,WAAA,EAAA,sBAAA,CAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,0BAAA,CAAA,KAAA,EAAA,gBAAA,EAAA,YAAA,EAAA,sBAAA,CAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,0BAAA,CAAA,KAAA,EAAA,qBAAA,EAAA,YAAA,EAAA,sBAAA,CAAA,KAAA,CAAA,CAAA;;AAAA,WAAA,KAAA;AAAA;;AAAA,EAAA,YAAA,CAAA,KAAA,EAAA,CAAA;AAAA,IAAA,GAAA,EAAA,oBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,kBAAA,CAAA,IAAA,EAoBK;AAAA,UALDE,IAKC,GAAA,IAAA,CALDA,IAKC;AAAA,UAJDC,IAIC,GAAA,IAAA,CAJDA,IAIC;AACD,UAAMC,IAAI,GAAG,KAAb,gBAAa,EAAb;;AACA,UAAIA,IAAI,IAAIA,IAAI,CAAhB,QAAA,EAA2B;AACzB,YAAIF,IAAI,KAAR,aAAA,EAA4B;AAC1BE,UAAAA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAAAA,gBAAAA,EAAAA,IAAAA;AADF,SAAA,MAEO,IAAIF,IAAI,KAAR,aAAA,EAA4B;AACjCE,UAAAA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAAAA,gBAAAA,EAAAA,IAAAA;AADK,SAAA,MAEA,IAAIF,IAAI,KAAR,eAAA,EAA8B;AACnCE,UAAAA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAAAA,kBAAAA,EAAAA,IAAAA;AADK,SAAA,MAEA,IAAIF,IAAI,KAAR,SAAA,EAAwB;AAC7BE,UAAAA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAAAA,WAAAA,EAAAA,IAAAA;AADK,SAAA,MAEA,IAAIF,IAAI,KAAR,MAAA,EAAqB;AAC1BE,UAAAA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAAAA,QAAAA,EAAAA,IAAAA;AACD;AACF;AACF;AAnCH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,iBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,eAAA,GAqC8B;AAC1B,WAAA,mBAAA,CAAA,cAAA,CAAA,MAAA,EAAgD;AAC9CC,QAAAA,EAAE,EAD4C,SAAA;AAE9CC,QAAAA,EAAE,EAAEC;AAF0C,OAAhD;;AAD0B,UAAA,qBAAA,GAStB,KAAA,mBAAA,CAAA,SAAA,CATsB,MAStB,CATsB;AAAA,UAMxBF,EANwB,GAAA,qBAAA,CAAA,EAAA;AAAA,UAOxBC,EAPwB,GAAA,qBAAA,CAAA,EAAA;AAAA,UAQdE,iBARc,GAAA,qBAAA,CAAA,QAAA;;AAW1B,UAAMC,QAAQ,GAAG,KAAA,cAAA,CAAA,oBAAA,CAAyC;AACxDC,QAAAA,YAAY,EAD4C,EAAA;AAExDC,QAAAA,cAAc,EAF0C,EAAA;AAGxDC,QAAAA,IAAI,EAAE;AACJC,UAAAA,MAAM,EAAE;AADJ,SAHkD;AAMxDC,QAAAA,KAAK,EAAE;AACLD,UAAAA,MAAM,EAAE;AADH,SANiD;AASxDE,QAAAA,KAAK,EAAE;AACLF,UAAAA,MAAM,EADD,IAAA;AAELG,UAAAA,IAAI,EAAE;AACJC,YAAAA,MAAM,EAAEC,EAAE,CADN,SAAA;AAEJC,YAAAA,MAAM,EAAED,EAAE,CAFN,mBAAA;AAGJE,YAAAA,QAAQ,EAHJ,CAAA;AAIJC,YAAAA,QAAQ,EAAE;AAJN;AAFD;AATiD,OAAzC,CAAjB,CAX0B,CA+B1B;;AACAZ,MAAAA,QAAQ,CAARA,UAAAA,CAAAA,aAAAA,CAAAA;AACEa,QAAAA,oBAAoB,EAAEC,MAAM,CAACC;AAD/Bf,OAAAA,EAAAA,iBAAAA,CAAAA;AAKA,UAAMgB,UAAU,GAAG,KAAnB,eAAmB,EAAnB;AAEA,UAAMC,QAAQ,GAAG,KAAA,cAAA,CAAA,6BAAA,CAAkD;AACjEC,QAAAA,iBAAiB,EAAEF,UAAU,CAAVA,gBAAAA,CAAAA,MAAAA,GAD8C,CAAA;AAEjEG,QAAAA,WAAW,EAAE;AAFoD,OAAlD,CAAjB;AAKAF,MAAAA,QAAQ,CAARA,QAAAA,CAAkB,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAlBA,CAAkB,CAAlBA;AAEAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,UAAAA,EAAkCG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAA9DC,SAAkCG,CAAlCH,EAA2E;AACzEI,QAAAA,WAAW,EAAE,IAD4D,CAAA;AAEzEC,QAAAA,QAAQ,EAFiE,QAAA;AAGzEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAH6D,OAA3ER;AAYAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,QAAAA,EAEEG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAF9BC,gBAEEG,CAFFH,EAGE;AACEI,QAAAA,WAAW,EAAE,IADf,CAAA;AAEEC,QAAAA,QAAQ,EAFV,UAAA;AAGEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAHd,OAHFR;AAgBAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,OAAAA,EAEEG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAF9BC,eAEEG,CAFFH,EAGE;AACEI,QAAAA,WAAW,EAAE,IADf,CAAA;AAEEC,QAAAA,QAAQ,EAFV,UAAA;AAGEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAHd,OAHFR;AAgBAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,MAAAA,EAEEG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAF9BC,cAEEG,CAFFH,EAGE;AACEI,QAAAA,WAAW,EADb,CAAA;AAEEC,QAAAA,QAAQ,EAFV,UAAA;AAGEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAHd,OAHFR;AAgBAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,OAAAA,EAEEG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAF9BC,eAEEG,CAFFH,EAGE;AACEI,QAAAA,WAAW,EADb,CAAA;AAEEC,QAAAA,QAAQ,EAFV,UAAA;AAGEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAHd,OAHFR;AAgBAA,MAAAA,QAAQ,CAARA,YAAAA,CAAAA,gBAAAA,EAEEG,YAAY,CAAZA,IAAAA,CAAkBJ,UAAU,CAF9BC,sBAEEG,CAFFH,EAGE;AACEI,QAAAA,WAAW,EAAE,IADf,CAAA;AAEEC,QAAAA,QAAQ,EAFV,UAAA;AAGEN,QAAAA,UAAU,EAAE,CACV;AACEO,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AAHd,OAHFR;AAgBA,WAAA,WAAA,CAAA,QAAA;AACA,WAAA,WAAA,CAAA,QAAA;AACD;AAjLH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,gBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,cAAA,CAAA,MAAA,EAAA,UAAA,EAAA,KAAA,EAuLI;AAAA,UAAA,qBAAA,EAAA,sBAAA,EAAA,sBAAA,EAAA,sBAAA;;AACA,OAAA,qBAAA,GAAA,UAAU,CAAV,sBAAA,EAAA,IAAA,CAAA,KAAA,CAAA,qBAAA,EAAA,kBAAA,CACKS,kBAAkB,CAACC,MAAM,CAANA,EAAAA,IADxB,KACuB,CADvB,CAAA;;AAIAX,MAAAA,UAAU,CAAVA,eAAAA,CAAAA,IAAAA,CACE7B,WAAW,CAAXA,OAAAA,CAAoBwC,MAAM,CAANA,KAAAA,IADtBX,QACE7B,CADF6B;;AAGA,OAAA,sBAAA,GAAA,UAAU,CAAV,eAAA,EAAA,IAAA,CAAA,KAAA,CAAA,sBAAA,EAAA,kBAAA,CAAoCW,MAAM,CAANA,KAAAA,IAAgB,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAApD,CAAoD,CAApD,CAAA;;AACA,OAAA,sBAAA,GAAA,UAAU,CAAV,gBAAA,EAAA,IAAA,CAAA,KAAA,CAAA,sBAAA,EAAA,kBAAA,CAAqCA,MAAM,CAANA,QAAAA,IAAmB,CAAA,CAAA,EAAxD,CAAwD,CAAxD,CAAA;;AACA,OAAA,sBAAA,GAAA,UAAU,CAAV,cAAA,EAAA,IAAA,CAAA,KAAA,CAAA,sBAAA,EAAA,kBAAA,CAAmCA,MAAM,CAANA,IAAAA,IAAe,CAAA,GAAA,EAAlD,GAAkD,CAAlD,CAAA;AACD;AAlMH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,iBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,eAAA,GAoM4B;AAAA,UAAA,MAAA,GAAA,IAAA;;AACxB,UAAMX,UAA+B,GAAG;AACtCY,QAAAA,SAAS,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAU,CAAV,CAAA,EAAc,CAAd,CAAA,EAAkB,CAAlB,CAAA,EAAsB,CAAtB,CAAA,EAD2B,CAC3B,CAD2B;AAEtCC,QAAAA,gBAAgB,EAFsB,EAAA;AAGtCC,QAAAA,eAAe,EAHuB,EAAA;AAItCC,QAAAA,cAAc,EAJwB,EAAA;AAKtCC,QAAAA,eAAe,EALuB,EAAA;AAMtCC,QAAAA,sBAAsB,EAAE;AANc,OAAxC;;AASA,UAAIC,KAAK,CAALA,OAAAA,CAAc,KAAlB,MAAIA,CAAJ,EAAgC;AAC9B,aAAA,MAAA,CAAA,OAAA,CAAoB,UAAA,MAAA,EAAA,CAAA,EAAe;AACjC,UAAA,MAAI,CAAJ,cAAA,CAAA,MAAA,EAAA,UAAA,EAAA,CAAA;AADF,SAAA;AADF,OAAA,MAIO;AACL,aAAA,cAAA,CAAoB,KAApB,MAAA,EAAA,UAAA,EAAA,CAAA;AACD;;AAED,aAAA,UAAA;AACD;AAvNH,GAAA,CAAA,CAAA;;AAAA,SAAA,KAAA;AAAA,CAAA,CAAA,UAAA,CAAA,EAAA,KAAA,CAAA,GAAA,WAAA,GAAA,yBAAA,CAAA,OAAA,CAAA,SAAA,EAAA,gBAAA,EAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA;AAAA,EAAA,YAAA,EAAA,IAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,QAAA,EAAA,IAAA;AAAA,EAAA,WAAA,EAAA;AAAA,CAAA,CAAA,EAAA,YAAA,GAAA,yBAAA,CAAA,OAAA,CAAA,SAAA,EAAA,gBAAA,EAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA;AAAA,EAAA,YAAA,EAAA,IAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,QAAA,EAAA,IAAA;AAAA,EAAA,WAAA,EAAA;AAAA,CAAA,CAAA,EAAA,YAAA,GAAA,yBAAA,CAAA,OAAA,CAAA,SAAA,EAAA,qBAAA,EAAA,CAAA,KAAA,CAAA,EAAA;AAAA,EAAA,YAAA,EAAA,IAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,QAAA,EAAA,IAAA;AAAA,EAAA,WAAA,EAAA;AAAA,CAAA,CAAA,GAAA,OAAA,CAAA,CAAA,IAAA,MAAA,CAAA","sourcesContent":["import {\n  BufferData,\n  GeometrySystem,\n  gl,\n  IDENTIFIER,\n  IShaderModuleService,\n  MaterialSystem,\n} from '@antv/g-webgpu-core';\nimport { inject, injectable, named } from 'inversify';\nimport { encodePickingColor } from '../../utils/picking';\nimport { Renderable } from '../Renderable';\nimport pointFrag from './shaders/webgl.point.frag.glsl';\nimport pointVert from './shaders/webgl.point.vert.glsl';\n\nconst pointShapes = [\n  'circle',\n  'triangle',\n  'square',\n  'pentagon',\n  'hexagon',\n  'octogon',\n  'hexagram',\n  'rhombus',\n  'vesica',\n];\n\ninterface IPointConfig {\n  id: number;\n  shape:\n    | 'circle'\n    | 'triangle'\n    | 'square'\n    | 'pentagon'\n    | 'hexagon'\n    | 'octogon'\n    | 'hexagram'\n    | 'rhombus'\n    | 'vesica';\n  position: [number, number];\n  size: [number, number];\n  color: [number, number, number, number]; // sRGB\n  opacity: number;\n  strokeWidth: number;\n  strokeOpacity: number;\n  strokeColor: [number, number, number, number]; // sRGB\n}\n\ninterface IInstanceAttributes {\n  positions: number[];\n  instancedOffsets: number[];\n  instancedColors: number[];\n  instancedSizes: number[];\n  instancedShapes: number[];\n  instancedPickingColors: number[];\n}\n\n/**\n * Use SDF to draw 2D point with stroke.\n */\n@injectable()\nexport class Point extends Renderable<\n  Partial<IPointConfig> | Array<Partial<IPointConfig>>\n> {\n  @inject(IDENTIFIER.Systems)\n  @named(IDENTIFIER.MaterialSystem)\n  private readonly materialSystem: MaterialSystem;\n\n  @inject(IDENTIFIER.Systems)\n  @named(IDENTIFIER.GeometrySystem)\n  private readonly geometrySystem: GeometrySystem;\n\n  @inject(IDENTIFIER.ShaderModuleService)\n  private readonly shaderModuleService: IShaderModuleService;\n\n  protected onAttributeChanged({\n    name,\n    data,\n  }: {\n    name: string;\n    data: BufferData;\n  }) {\n    const mesh = this.getMeshComponent();\n    if (mesh && mesh.material) {\n      if (name === 'strokeWidth') {\n        mesh.material.setUniform('u_stroke_width', data);\n      } else if (name === 'strokeColor') {\n        mesh.material.setUniform('u_stroke_color', data);\n      } else if (name === 'strokeOpacity') {\n        mesh.material.setUniform('u_stroke_opacity', data);\n      } else if (name === 'opacity') {\n        mesh.material.setUniform('u_opacity', data);\n      } else if (name === 'blur') {\n        mesh.material.setUniform('u_blur', data);\n      }\n    }\n  }\n\n  protected onEntityCreated() {\n    this.shaderModuleService.registerModule('grid', {\n      vs: pointVert,\n      fs: pointFrag,\n    });\n    const {\n      vs,\n      fs,\n      uniforms: extractedUniforms,\n    } = this.shaderModuleService.getModule('grid');\n\n    const material = this.materialSystem.createShaderMaterial({\n      vertexShader: vs!,\n      fragmentShader: fs!,\n      cull: {\n        enable: false,\n      },\n      depth: {\n        enable: false,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.SRC_ALPHA,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          srcAlpha: 1,\n          dstAlpha: 1,\n        },\n      },\n    });\n\n    // TODO: support define stroke-relative props per point\n    material.setUniform({\n      u_device_pixel_ratio: window.devicePixelRatio,\n      ...extractedUniforms,\n    });\n\n    const attributes = this.buildAttributes();\n\n    const geometry = this.geometrySystem.createInstancedBufferGeometry({\n      maxInstancedCount: attributes.instancedOffsets.length / 2,\n      vertexCount: 6,\n    });\n\n    geometry.setIndex([0, 2, 1, 0, 3, 2]);\n\n    geometry.setAttribute('position', Float32Array.from(attributes.positions), {\n      arrayStride: 4 * 2,\n      stepMode: 'vertex',\n      attributes: [\n        {\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float2',\n        },\n      ],\n    });\n\n    geometry.setAttribute(\n      'offset',\n      Float32Array.from(attributes.instancedOffsets),\n      {\n        arrayStride: 4 * 2,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'color',\n      Float32Array.from(attributes.instancedColors),\n      {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float4',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'size',\n      Float32Array.from(attributes.instancedSizes),\n      {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 3,\n            offset: 0,\n            format: 'float',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'shape',\n      Float32Array.from(attributes.instancedShapes),\n      {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 4,\n            offset: 0,\n            format: 'float',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'a_PickingColor',\n      Float32Array.from(attributes.instancedPickingColors),\n      {\n        arrayStride: 4 * 3,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 6,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n    );\n\n    this.setMaterial(material);\n    this.setGeometry(geometry);\n  }\n\n  private buildAttribute(\n    config: Partial<IPointConfig>,\n    attributes: IInstanceAttributes,\n    index: number,\n  ) {\n    attributes.instancedPickingColors.push(\n      ...encodePickingColor(config.id || index),\n    );\n\n    attributes.instancedShapes.push(\n      pointShapes.indexOf(config.shape || 'circle'),\n    );\n    attributes.instancedColors.push(...(config.color || [1, 0, 0, 1]));\n    attributes.instancedOffsets.push(...(config.position || [0, 0]));\n    attributes.instancedSizes.push(...(config.size || [0.2, 0.2]));\n  }\n\n  private buildAttributes() {\n    const attributes: IInstanceAttributes = {\n      positions: [1, 1, 1, -1, -1, -1, -1, 1],\n      instancedOffsets: [],\n      instancedColors: [],\n      instancedSizes: [],\n      instancedShapes: [],\n      instancedPickingColors: [],\n    };\n\n    if (Array.isArray(this.config)) {\n      this.config.forEach((config, i) => {\n        this.buildAttribute(config, attributes, i);\n      });\n    } else {\n      this.buildAttribute(this.config, attributes, 0);\n    }\n\n    return attributes;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}