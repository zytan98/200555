{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\n\nexport class ForceLayout extends Base {\n  constructor(options) {\n    super();\n    /** 向心力作用点 */\n\n    this.center = [0, 0];\n    /** 节点作用力 */\n\n    this.nodeStrength = null;\n    /** 边的作用力, 默认为根据节点的入度出度自适应 */\n\n    this.edgeStrength = null;\n    /** 是否防止节点相互覆盖 */\n\n    this.preventOverlap = false;\n    /** 聚类节点作用力 */\n\n    this.clusterNodeStrength = null;\n    /** 聚类边作用力 */\n\n    this.clusterEdgeStrength = null;\n    /** 聚类边长度 */\n\n    this.clusterEdgeDistance = null;\n    /** 聚类节点大小 / 直径，直径越大，越分散 */\n\n    this.clusterNodeSize = null;\n    /** 用于 foci 的力 */\n\n    this.clusterFociStrength = null;\n    /** 默认边长度 */\n\n    this.linkDistance = 50;\n    /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n\n    this.alphaDecay = 0.028;\n    /** 停止迭代的阈值 */\n\n    this.alphaMin = 0.001;\n    /** 当前阈值 */\n\n    this.alpha = 0.3;\n    /** 防止重叠的力强度 */\n\n    this.collideStrength = 1;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n\n    this.tick = () => {};\n    /** 布局完成回调 */\n\n\n    this.onLayoutEnd = () => {};\n    /** 是否正在布局 */\n\n\n    this.ticking = undefined;\n\n    if (options) {\n      this.updateCfg(options);\n    }\n  }\n\n  getDefaultCfg() {\n    return {\n      center: [0, 0],\n      nodeStrength: null,\n      edgeStrength: null,\n      preventOverlap: false,\n      nodeSize: undefined,\n      nodeSpacing: undefined,\n      linkDistance: 50,\n      forceSimulation: null,\n      alphaDecay: 0.028,\n      alphaMin: 0.001,\n      alpha: 0.3,\n      collideStrength: 1,\n      clustering: false,\n      clusterNodeStrength: -1,\n      clusterEdgeStrength: 0.1,\n      clusterEdgeDistance: 100,\n      clusterFociStrength: 0.8,\n      clusterNodeSize: 10,\n\n      tick() {},\n\n      onLayoutEnd() {},\n\n      // 是否启用web worker。前提是在web worker里执行布局，否则无效\n      workerEnabled: false\n    };\n  }\n  /**\n   * 初始化\n   * @param {object} data 数据\n   */\n\n\n  init(data) {\n    const self = this;\n    self.nodes = data.nodes || [];\n    const edges = data.edges || [];\n    self.edges = edges.map(edge => {\n      const res = {};\n      const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n      Object.keys(edge).forEach(key => {\n        if (!(expectKeys.indexOf(key) > -1)) {\n          res[key] = edge[key];\n        }\n      });\n      return res;\n    });\n    self.ticking = false;\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute(reloadData) {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges; // 如果正在布局，忽略布局请求\n\n    if (self.ticking) {\n      return;\n    }\n\n    let simulation = self.forceSimulation;\n    const alphaMin = self.alphaMin;\n    const alphaDecay = self.alphaDecay;\n    const alpha = self.alpha;\n\n    if (!simulation) {\n      try {\n        // 定义节点的力\n        const nodeForce = d3Force.forceManyBody();\n\n        if (self.nodeStrength) {\n          nodeForce.strength(self.nodeStrength);\n        }\n\n        simulation = d3Force.forceSimulation().nodes(nodes);\n\n        if (self.clustering) {\n          const clusterForce = forceInABox();\n          clusterForce.centerX(self.center[0]).centerY(self.center[1]).template(\"force\").strength(self.clusterFociStrength);\n\n          if (edges) {\n            clusterForce.links(edges);\n          }\n\n          if (nodes) {\n            clusterForce.nodes(nodes);\n          }\n\n          clusterForce.forceLinkDistance(self.clusterEdgeDistance).forceLinkStrength(self.clusterEdgeStrength).forceCharge(self.clusterNodeStrength).forceNodeSize(self.clusterNodeSize);\n          self.clusterForce = clusterForce;\n          simulation.force(\"group\", clusterForce);\n        }\n\n        simulation.force(\"center\", d3Force.forceCenter(self.center[0], self.center[1])).force(\"charge\", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);\n\n        if (self.preventOverlap) {\n          self.overlapProcess(simulation);\n        } // 如果有边，定义边的力\n\n\n        if (edges) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n\n        if (self.workerEnabled && !isInWorker()) {\n          // 如果不是运行在web worker里，不用web worker布局\n          self.workerEnabled = false;\n          console.warn(\"workerEnabled option is only supported when running in web worker.\");\n        }\n\n        if (!self.workerEnabled) {\n          simulation.on(\"tick\", () => {\n            self.tick();\n          }).on(\"end\", () => {\n            self.ticking = false;\n            if (self.onLayoutEnd) self.onLayoutEnd();\n          });\n          self.ticking = true;\n        } else {\n          // worker is enabled\n          simulation.stop();\n          const totalTicks = getSimulationTicks(simulation);\n\n          for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\n            simulation.tick(); // currentTick starts from 1.\n\n            postMessage({\n              nodes,\n              currentTick,\n              totalTicks,\n              type: LAYOUT_MESSAGE.TICK\n            }, undefined);\n          }\n\n          self.ticking = false;\n        }\n\n        self.forceSimulation = simulation;\n        self.ticking = true;\n      } catch (e) {\n        self.ticking = false;\n        console.warn(e);\n      }\n    } else {\n      if (reloadData) {\n        if (self.clustering && self.clusterForce) {\n          self.clusterForce.nodes(nodes);\n          self.clusterForce.links(edges);\n        }\n\n        simulation.nodes(nodes);\n        if (edges && self.edgeForce) self.edgeForce.links(edges);else if (edges && !self.edgeForce) {\n          // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n          const edgeForce = d3Force.forceLink().id(d => d.id).links(edges);\n\n          if (self.edgeStrength) {\n            edgeForce.strength(self.edgeStrength);\n          }\n\n          if (self.linkDistance) {\n            edgeForce.distance(self.linkDistance);\n          }\n\n          self.edgeForce = edgeForce;\n          simulation.force(\"link\", edgeForce);\n        }\n      }\n\n      if (self.preventOverlap) {\n        self.overlapProcess(simulation);\n      }\n\n      simulation.alpha(alpha).restart();\n      this.ticking = true;\n    }\n  }\n  /**\n   * 防止重叠\n   * @param {object} simulation 力模拟模型\n   */\n\n\n  overlapProcess(simulation) {\n    const self = this;\n    const nodeSize = self.nodeSize;\n    const nodeSpacing = self.nodeSpacing;\n    let nodeSizeFunc;\n    let nodeSpacingFunc;\n    const collideStrength = self.collideStrength;\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = () => nodeSpacing;\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = () => 0;\n    }\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2 + nodeSpacingFunc(d);\n          }\n\n          return d.size / 2 + nodeSpacingFunc(d);\n        }\n\n        return 10 + nodeSpacingFunc(d);\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = d => {\n        const size = nodeSize(d);\n        return size + nodeSpacingFunc(d);\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else if (isNumber(nodeSize)) {\n      const radius = nodeSize / 2;\n\n      nodeSizeFunc = d => radius + nodeSpacingFunc(d);\n    } else {\n      nodeSizeFunc = () => 10;\n    } // forceCollide's parameter is a radius\n\n\n    simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n  }\n  /**\n   * 更新布局配置，但不执行布局\n   * @param {object} cfg 需要更新的配置项\n   */\n\n\n  updateCfg(cfg) {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.forceSimulation = null;\n    Object.assign(self, cfg);\n  }\n\n  destroy() {\n    const self = this;\n\n    if (self.ticking) {\n      self.forceSimulation.stop();\n      self.ticking = false;\n    }\n\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n} // Return total ticks of d3-force simulation\n\nfunction getSimulationTicks(simulation) {\n  const alphaMin = simulation.alphaMin();\n  const alphaTarget = simulation.alphaTarget();\n  const alpha = simulation.alpha();\n  const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());\n  const totalTicks = Math.ceil(totalTicksFloat);\n  return totalTicks;\n} // 判断是否运行在web worker里\n\n\nfunction isInWorker() {\n  // eslint-disable-next-line no-undef\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}","map":{"version":3,"sources":["../../../src/layout/force/force.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport * as d3Force from \"d3-force\";\nimport forceInABox from \"./force-in-a-box\";\nimport { isArray, isFunction, isNumber, isObject } from \"../../util\";\nimport { Base } from \"../base\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * 经典力导布局 force-directed\n */\nexport class ForceLayout extends Base {\n    constructor(options) {\n        super();\n        /** 向心力作用点 */\n        this.center = [0, 0];\n        /** 节点作用力 */\n        this.nodeStrength = null;\n        /** 边的作用力, 默认为根据节点的入度出度自适应 */\n        this.edgeStrength = null;\n        /** 是否防止节点相互覆盖 */\n        this.preventOverlap = false;\n        /** 聚类节点作用力 */\n        this.clusterNodeStrength = null;\n        /** 聚类边作用力 */\n        this.clusterEdgeStrength = null;\n        /** 聚类边长度 */\n        this.clusterEdgeDistance = null;\n        /** 聚类节点大小 / 直径，直径越大，越分散 */\n        this.clusterNodeSize = null;\n        /** 用于 foci 的力 */\n        this.clusterFociStrength = null;\n        /** 默认边长度 */\n        this.linkDistance = 50;\n        /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n        this.alphaDecay = 0.028;\n        /** 停止迭代的阈值 */\n        this.alphaMin = 0.001;\n        /** 当前阈值 */\n        this.alpha = 0.3;\n        /** 防止重叠的力强度 */\n        this.collideStrength = 1;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        this.workerEnabled = false;\n        this.tick = () => { };\n        /** 布局完成回调 */\n        this.onLayoutEnd = () => { };\n        /** 是否正在布局 */\n        this.ticking = undefined;\n        if (options) {\n            this.updateCfg(options);\n        }\n    }\n    getDefaultCfg() {\n        return {\n            center: [0, 0],\n            nodeStrength: null,\n            edgeStrength: null,\n            preventOverlap: false,\n            nodeSize: undefined,\n            nodeSpacing: undefined,\n            linkDistance: 50,\n            forceSimulation: null,\n            alphaDecay: 0.028,\n            alphaMin: 0.001,\n            alpha: 0.3,\n            collideStrength: 1,\n            clustering: false,\n            clusterNodeStrength: -1,\n            clusterEdgeStrength: 0.1,\n            clusterEdgeDistance: 100,\n            clusterFociStrength: 0.8,\n            clusterNodeSize: 10,\n            tick() { },\n            onLayoutEnd() { },\n            // 是否启用web worker。前提是在web worker里执行布局，否则无效\n            workerEnabled: false\n        };\n    }\n    /**\n     * 初始化\n     * @param {object} data 数据\n     */\n    init(data) {\n        const self = this;\n        self.nodes = data.nodes || [];\n        const edges = data.edges || [];\n        self.edges = edges.map((edge) => {\n            const res = {};\n            const expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n            Object.keys(edge).forEach((key) => {\n                if (!(expectKeys.indexOf(key) > -1)) {\n                    res[key] = edge[key];\n                }\n            });\n            return res;\n        });\n        self.ticking = false;\n    }\n    /**\n     * 执行布局\n     */\n    execute(reloadData) {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        // 如果正在布局，忽略布局请求\n        if (self.ticking) {\n            return;\n        }\n        let simulation = self.forceSimulation;\n        const alphaMin = self.alphaMin;\n        const alphaDecay = self.alphaDecay;\n        const alpha = self.alpha;\n        if (!simulation) {\n            try {\n                // 定义节点的力\n                const nodeForce = d3Force.forceManyBody();\n                if (self.nodeStrength) {\n                    nodeForce.strength(self.nodeStrength);\n                }\n                simulation = d3Force.forceSimulation().nodes(nodes);\n                if (self.clustering) {\n                    const clusterForce = forceInABox();\n                    clusterForce\n                        .centerX(self.center[0])\n                        .centerY(self.center[1])\n                        .template(\"force\")\n                        .strength(self.clusterFociStrength);\n                    if (edges) {\n                        clusterForce.links(edges);\n                    }\n                    if (nodes) {\n                        clusterForce.nodes(nodes);\n                    }\n                    clusterForce\n                        .forceLinkDistance(self.clusterEdgeDistance)\n                        .forceLinkStrength(self.clusterEdgeStrength)\n                        .forceCharge(self.clusterNodeStrength)\n                        .forceNodeSize(self.clusterNodeSize);\n                    self.clusterForce = clusterForce;\n                    simulation.force(\"group\", clusterForce);\n                }\n                simulation\n                    .force(\"center\", d3Force.forceCenter(self.center[0], self.center[1]))\n                    .force(\"charge\", nodeForce)\n                    .alpha(alpha)\n                    .alphaDecay(alphaDecay)\n                    .alphaMin(alphaMin);\n                if (self.preventOverlap) {\n                    self.overlapProcess(simulation);\n                }\n                // 如果有边，定义边的力\n                if (edges) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    const edgeForce = d3Force\n                        .forceLink()\n                        .id((d) => d.id)\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n                if (self.workerEnabled && !isInWorker()) {\n                    // 如果不是运行在web worker里，不用web worker布局\n                    self.workerEnabled = false;\n                    console.warn(\"workerEnabled option is only supported when running in web worker.\");\n                }\n                if (!self.workerEnabled) {\n                    simulation\n                        .on(\"tick\", () => {\n                        self.tick();\n                    })\n                        .on(\"end\", () => {\n                        self.ticking = false;\n                        if (self.onLayoutEnd)\n                            self.onLayoutEnd();\n                    });\n                    self.ticking = true;\n                }\n                else {\n                    // worker is enabled\n                    simulation.stop();\n                    const totalTicks = getSimulationTicks(simulation);\n                    for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {\n                        simulation.tick();\n                        // currentTick starts from 1.\n                        postMessage({\n                            nodes,\n                            currentTick,\n                            totalTicks,\n                            type: LAYOUT_MESSAGE.TICK\n                        }, undefined);\n                    }\n                    self.ticking = false;\n                }\n                self.forceSimulation = simulation;\n                self.ticking = true;\n            }\n            catch (e) {\n                self.ticking = false;\n                console.warn(e);\n            }\n        }\n        else {\n            if (reloadData) {\n                if (self.clustering && self.clusterForce) {\n                    self.clusterForce.nodes(nodes);\n                    self.clusterForce.links(edges);\n                }\n                simulation.nodes(nodes);\n                if (edges && self.edgeForce)\n                    self.edgeForce.links(edges);\n                else if (edges && !self.edgeForce) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    const edgeForce = d3Force\n                        .forceLink()\n                        .id((d) => d.id)\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n            }\n            if (self.preventOverlap) {\n                self.overlapProcess(simulation);\n            }\n            simulation.alpha(alpha).restart();\n            this.ticking = true;\n        }\n    }\n    /**\n     * 防止重叠\n     * @param {object} simulation 力模拟模型\n     */\n    overlapProcess(simulation) {\n        const self = this;\n        const nodeSize = self.nodeSize;\n        const nodeSpacing = self.nodeSpacing;\n        let nodeSizeFunc;\n        let nodeSpacingFunc;\n        const collideStrength = self.collideStrength;\n        if (isNumber(nodeSpacing)) {\n            nodeSpacingFunc = () => nodeSpacing;\n        }\n        else if (isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = () => 0;\n        }\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2 + nodeSpacingFunc(d);\n                    }\n                    if (isObject(d.size)) {\n                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return res / 2 + nodeSpacingFunc(d);\n                    }\n                    return d.size / 2 + nodeSpacingFunc(d);\n                }\n                return 10 + nodeSpacingFunc(d);\n            };\n        }\n        else if (isFunction(nodeSize)) {\n            nodeSizeFunc = (d) => {\n                const size = nodeSize(d);\n                return size + nodeSpacingFunc(d);\n            };\n        }\n        else if (isArray(nodeSize)) {\n            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            const radius = larger / 2;\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\n        }\n        else if (isNumber(nodeSize)) {\n            const radius = nodeSize / 2;\n            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);\n        }\n        else {\n            nodeSizeFunc = () => 10;\n        }\n        // forceCollide's parameter is a radius\n        simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n    }\n    /**\n     * 更新布局配置，但不执行布局\n     * @param {object} cfg 需要更新的配置项\n     */\n    updateCfg(cfg) {\n        const self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.forceSimulation = null;\n        Object.assign(self, cfg);\n    }\n    destroy() {\n        const self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    }\n}\n// Return total ticks of d3-force simulation\nfunction getSimulationTicks(simulation) {\n    const alphaMin = simulation.alphaMin();\n    const alphaTarget = simulation.alphaTarget();\n    const alpha = simulation.alpha();\n    const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) /\n        Math.log(1 - simulation.alphaDecay());\n    const totalTicks = Math.ceil(totalTicksFloat);\n    return totalTicks;\n}\n// 判断是否运行在web worker里\nfunction isInWorker() {\n    // eslint-disable-next-line no-undef\n    return (typeof WorkerGlobalScope !== \"undefined\" &&\n        self instanceof WorkerGlobalScope);\n}\n//# sourceMappingURL=force.js.map"]},"metadata":{},"sourceType":"module"}