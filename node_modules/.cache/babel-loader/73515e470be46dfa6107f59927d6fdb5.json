{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { mat3, vec3, vec4 } from 'gl-matrix';\nimport { Component } from '../../ComponentManager';\nimport { isTypedArray } from '../../utils/is-typedarray';\nexport var GeometryComponent = /*#__PURE__*/function (_Component) {\n  _inherits(GeometryComponent, _Component);\n\n  var _super = _createSuper(GeometryComponent); // instanced count\n\n\n  function GeometryComponent(data) {\n    var _this;\n\n    _classCallCheck(this, GeometryComponent);\n\n    _this = _super.call(this, data);\n    _this.dirty = true;\n    _this.attributes = [];\n    _this.indices = void 0;\n    _this.indicesBuffer = void 0;\n    _this.vertexCount = 0;\n    _this.maxInstancedCount = void 0;\n    _this.aabb = void 0;\n    _this.entity = void 0;\n    Object.assign(_assertThisInitialized(_this), data);\n    return _this;\n  }\n  /**\n   * @see https://threejs.org/docs/#api/en/core/BufferAttribute\n   */\n\n\n  _createClass(GeometryComponent, [{\n    key: \"setAttribute\",\n    value: function setAttribute(name, data, descriptor, bufferGetter) {\n      var existed = this.attributes.find(function (a) {\n        return a.name === name;\n      });\n\n      if (!existed) {\n        this.attributes.push(_objectSpread(_objectSpread({\n          dirty: true,\n          name: name,\n          data: data\n        }, descriptor), {}, {\n          bufferGetter: bufferGetter\n        }));\n      } else {\n        existed.data = data;\n        existed.dirty = true;\n      }\n\n      this.dirty = true;\n      return this;\n    }\n  }, {\n    key: \"setIndex\",\n    value: function setIndex(data) {\n      this.indices = new Uint32Array( // @ts-ignore\n      data.buffer ? data.buffer : data);\n      this.dirty = true;\n      return this;\n    }\n    /**\n     * when merge all the geometries into one, we need to transform every vertex's position\n     * and every face's normal\n     */\n\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      var positionAttribute = this.attributes.find(function (_ref) {\n        var name = _ref.name;\n        return name === 'position';\n      });\n      var normalAttribute = this.attributes.find(function (_ref2) {\n        var name = _ref2.name;\n        return name === 'normal';\n      });\n\n      if (positionAttribute) {\n        positionAttribute.dirty = true; // @ts-ignore\n\n        if (positionAttribute.data && positionAttribute.data.length) {\n          // @ts-ignore\n          for (var i = 0; i < positionAttribute.data.length; i += 3) {\n            var position = vec4.fromValues( // @ts-ignore\n            positionAttribute.data[i], // @ts-ignore\n            positionAttribute.data[i + 1], // @ts-ignore\n            positionAttribute.data[i + 2], 1);\n            vec4.transformMat4(position, position, matrix);\n\n            if (isTypedArray(positionAttribute.data)) {\n              // @ts-ignore\n              positionAttribute.data.set([position[0], position[1], position[2]], i);\n            } else {\n              // @ts-ignore\n              positionAttribute.data[i] = position[0]; // @ts-ignore\n\n              positionAttribute.data[i + 1] = position[1]; // @ts-ignore\n\n              positionAttribute.data[i + 2] = position[2];\n            }\n          }\n        }\n      }\n\n      if (normalAttribute) {\n        var normalMatrix = mat3.normalFromMat4(mat3.create(), matrix); // @ts-ignore\n\n        if (normalAttribute.data && normalAttribute.data.length) {\n          // @ts-ignore\n          for (var _i = 0; _i < normalAttribute.data.length; _i += 3) {\n            var normal = vec3.fromValues( // @ts-ignore\n            normalAttribute.data[_i], // @ts-ignore\n            normalAttribute.data[_i + 1], // @ts-ignore\n            normalAttribute.data[_i + 2]);\n            vec3.transformMat3(normal, normal, normalMatrix);\n            vec3.normalize(normal, normal);\n\n            if (isTypedArray(normalAttribute.data)) {\n              // @ts-ignore\n              normalAttribute.data.set([normal[0], normal[1], normal[2]], _i);\n            } else {\n              // @ts-ignore\n              normalAttribute.data[_i] = normal[0]; // @ts-ignore\n\n              normalAttribute.data[_i + 1] = normal[1]; // @ts-ignore\n\n              normalAttribute.data[_i + 2] = normal[2];\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return GeometryComponent;\n}(Component);","map":{"version":3,"sources":["../../../src/components/geometry/GeometryComponent.ts"],"names":["GeometryComponent","dirty","attributes","indices","indicesBuffer","vertexCount","maxInstancedCount","aabb","entity","Object","existed","a","name","data","bufferGetter","positionAttribute","normalAttribute","i","position","vec4","isTypedArray","normalMatrix","mat3","normal","vec3"],"mappings":"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","sourcesContent":["import { mat3, mat4, vec3, vec4 } from 'gl-matrix';\nimport { Entity } from '../..';\nimport { Component } from '../../ComponentManager';\nimport { NonFunctionProperties } from '../../ComponentManager';\nimport { AABB } from '../../shape/AABB';\nimport { isTypedArray } from '../../utils/is-typedarray';\nimport { IBuffer } from '../renderer/IBuffer';\nimport { IElements } from '../renderer/IElements';\nimport { BufferData } from '../renderer/IRendererService';\n\nexport class GeometryComponent extends Component<GeometryComponent> {\n  public dirty: boolean = true;\n\n  public attributes: Array<\n    {\n      dirty: boolean;\n      name: string;\n      data?: BufferData;\n      buffer?: IBuffer;\n      // 结合 Compute Pipeline 时，需要在运行时获取 PingPong buffer\n      bufferGetter?: () => IBuffer;\n    } & GPUVertexBufferLayoutDescriptor\n  > = [];\n\n  public indices: Uint32Array | null;\n  public indicesBuffer: IElements | null;\n\n  public vertexCount: number = 0;\n\n  // instanced count\n  public maxInstancedCount: number;\n\n  public aabb: AABB;\n\n  public entity: Entity;\n\n  constructor(data: Partial<NonFunctionProperties<GeometryComponent>>) {\n    super(data);\n\n    Object.assign(this, data);\n  }\n\n  /**\n   * @see https://threejs.org/docs/#api/en/core/BufferAttribute\n   */\n  public setAttribute(\n    name: string,\n    data: BufferData,\n    descriptor: GPUVertexBufferLayoutDescriptor,\n    bufferGetter?: () => IBuffer,\n  ) {\n    const existed = this.attributes.find((a) => a.name === name);\n    if (!existed) {\n      this.attributes.push({\n        dirty: true,\n        name,\n        data,\n        ...descriptor,\n        bufferGetter,\n      });\n    } else {\n      existed.data = data;\n      existed.dirty = true;\n    }\n    this.dirty = true;\n    return this;\n  }\n\n  public setIndex(data: number[] | Uint8Array | Uint16Array | Uint32Array) {\n    this.indices = new Uint32Array(\n      // @ts-ignore\n      data.buffer ? data.buffer : (data as number[]),\n    );\n    this.dirty = true;\n    return this;\n  }\n\n  /**\n   * when merge all the geometries into one, we need to transform every vertex's position\n   * and every face's normal\n   */\n  public applyMatrix(matrix: mat4) {\n    const positionAttribute = this.attributes.find(\n      ({ name }) => name === 'position',\n    );\n    const normalAttribute = this.attributes.find(\n      ({ name }) => name === 'normal',\n    );\n\n    if (positionAttribute) {\n      positionAttribute.dirty = true;\n\n      // @ts-ignore\n      if (positionAttribute.data && positionAttribute.data.length) {\n        // @ts-ignore\n        for (let i = 0; i < positionAttribute.data.length; i += 3) {\n          const position = vec4.fromValues(\n            // @ts-ignore\n            positionAttribute.data[i] as number,\n            // @ts-ignore\n            positionAttribute.data[i + 1] as number,\n            // @ts-ignore\n            positionAttribute.data[i + 2] as number,\n            1,\n          );\n          vec4.transformMat4(position, position, matrix);\n          if (isTypedArray(positionAttribute.data)) {\n            // @ts-ignore\n            positionAttribute.data.set(\n              [position[0], position[1], position[2]],\n              i,\n            );\n          } else {\n            // @ts-ignore\n            positionAttribute.data[i] = position[0];\n            // @ts-ignore\n            positionAttribute.data[i + 1] = position[1];\n            // @ts-ignore\n            positionAttribute.data[i + 2] = position[2];\n          }\n        }\n      }\n    }\n\n    if (normalAttribute) {\n      const normalMatrix = mat3.normalFromMat4(mat3.create(), matrix);\n      // @ts-ignore\n      if (normalAttribute.data && normalAttribute.data.length) {\n        // @ts-ignore\n        for (let i = 0; i < normalAttribute.data.length; i += 3) {\n          const normal = vec3.fromValues(\n            // @ts-ignore\n            normalAttribute.data[i] as number,\n            // @ts-ignore\n            normalAttribute.data[i + 1] as number,\n            // @ts-ignore\n            normalAttribute.data[i + 2] as number,\n          );\n          vec3.transformMat3(normal, normal, normalMatrix);\n          vec3.normalize(normal, normal);\n          if (isTypedArray(normalAttribute.data)) {\n            // @ts-ignore\n            normalAttribute.data.set([normal[0], normal[1], normal[2]], i);\n          } else {\n            // @ts-ignore\n            normalAttribute.data[i] = normal[0];\n            // @ts-ignore\n            normalAttribute.data[i + 1] = normal[1];\n            // @ts-ignore\n            normalAttribute.data[i + 2] = normal[2];\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}