{"ast":null,"code":"/**\n * Use cross product to judge the direction of the turn.\n * Returns a positive value, if OAB makes a clockwise turn,\n * negative for counter-clockwise turn, and zero if the points are collinear.\n */\nexport var cross = function cross(a, b, o) {\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\n};\n/**\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\n * @param points An array of [x, y] representing the coordinates of points.\n * @return a list of vertices of the convex hull in counter-clockwise order,\n */\n\nexport var genConvexHull = function genConvexHull(items) {\n  var points = items.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  });\n  points.sort(function (a, b) {\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\n  });\n\n  if (points.length === 1) {\n    return points;\n  } // build the lower hull\n\n\n  var lower = [];\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    lower.push(points[i]);\n  } // build the upper hull\n\n\n  var upper = [];\n\n  for (var i = points.length - 1; i >= 0; i--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  var strictHull = lower.concat(upper);\n  return strictHull;\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-core/es/element/hull/convexHull.js"],"names":["cross","a","b","o","y","x","genConvexHull","items","points","map","item","getModel","sort","length","lower","i","pop","push","upper","strictHull","concat"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIA,KAAK,GAAG,SAASA,KAAT,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwB;AACzC,SAAO,CAACF,CAAC,CAACG,CAAF,GAAMD,CAAC,CAACC,CAAT,KAAeF,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAvB,IAA4B,CAACJ,CAAC,CAACI,CAAF,GAAMF,CAAC,CAACE,CAAT,KAAeH,CAAC,CAACE,CAAF,GAAMD,CAAC,CAACC,CAAvB,CAAnC;AACD,CAFM;AAGP;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIE,aAAa,GAAG,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;AACvD,MAAIC,MAAM,GAAGD,KAAK,CAACE,GAAN,CAAU,UAAUC,IAAV,EAAgB;AACrC,WAAO;AACLL,MAAAA,CAAC,EAAEK,IAAI,CAACC,QAAL,GAAgBN,CADd;AAELD,MAAAA,CAAC,EAAEM,IAAI,CAACC,QAAL,GAAgBP;AAFd,KAAP;AAID,GALY,CAAb;AAMAI,EAAAA,MAAM,CAACI,IAAP,CAAY,UAAUX,CAAV,EAAaC,CAAb,EAAgB;AAC1B,WAAOD,CAAC,CAACI,CAAF,KAAQH,CAAC,CAACG,CAAV,GAAcJ,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAtB,GAA0BH,CAAC,CAACI,CAAF,GAAMH,CAAC,CAACG,CAAzC;AACD,GAFD;;AAIA,MAAIG,MAAM,CAACK,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAOL,MAAP;AACD,GAbsD,CAarD;;;AAGF,MAAIM,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,MAAM,CAACK,MAA3B,EAAmCE,CAAC,EAApC,EAAwC;AACtC,WAAOD,KAAK,CAACD,MAAN,IAAgB,CAAhB,IAAqBb,KAAK,CAACc,KAAK,CAACA,KAAK,CAACD,MAAN,GAAe,CAAhB,CAAN,EAA0BC,KAAK,CAACA,KAAK,CAACD,MAAN,GAAe,CAAhB,CAA/B,EAAmDL,MAAM,CAACO,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACnGD,MAAAA,KAAK,CAACE,GAAN;AACD;;AAEDF,IAAAA,KAAK,CAACG,IAAN,CAAWT,MAAM,CAACO,CAAD,CAAjB;AACD,GAxBsD,CAwBrD;;;AAGF,MAAIG,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIH,CAAC,GAAGP,MAAM,CAACK,MAAP,GAAgB,CAA7B,EAAgCE,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3C,WAAOG,KAAK,CAACL,MAAN,IAAgB,CAAhB,IAAqBb,KAAK,CAACkB,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAAN,EAA0BK,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAA/B,EAAmDL,MAAM,CAACO,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACnGG,MAAAA,KAAK,CAACF,GAAN;AACD;;AAEDE,IAAAA,KAAK,CAACD,IAAN,CAAWT,MAAM,CAACO,CAAD,CAAjB;AACD;;AAEDG,EAAAA,KAAK,CAACF,GAAN;AACAF,EAAAA,KAAK,CAACE,GAAN;AACA,MAAIG,UAAU,GAAGL,KAAK,CAACM,MAAN,CAAaF,KAAb,CAAjB;AACA,SAAOC,UAAP;AACD,CAzCM","sourcesContent":["/**\n * Use cross product to judge the direction of the turn.\n * Returns a positive value, if OAB makes a clockwise turn,\n * negative for counter-clockwise turn, and zero if the points are collinear.\n */\nexport var cross = function cross(a, b, o) {\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\n};\n/**\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\n * @param points An array of [x, y] representing the coordinates of points.\n * @return a list of vertices of the convex hull in counter-clockwise order,\n */\n\nexport var genConvexHull = function genConvexHull(items) {\n  var points = items.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  });\n  points.sort(function (a, b) {\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\n  });\n\n  if (points.length === 1) {\n    return points;\n  } // build the lower hull\n\n\n  var lower = [];\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    lower.push(points[i]);\n  } // build the upper hull\n\n\n  var upper = [];\n\n  for (var i = points.length - 1; i >= 0; i--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  var strictHull = lower.concat(upper);\n  return strictHull;\n};"]},"metadata":{},"sourceType":"module"}