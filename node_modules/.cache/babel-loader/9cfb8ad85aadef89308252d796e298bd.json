{"ast":null,"code":"import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nexport default class MDS {\n  constructor(params) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  layout() {\n    const self = this;\n    const {\n      dimension,\n      distances,\n      linkDistance\n    } = self;\n\n    try {\n      // square distances\n      const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      const rowMeans = M.mean('row');\n      const colMeans = M.mean('column');\n      const totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      const ret = new SingularValueDecomposition(M);\n      const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(row => {\n        return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n      });\n    } catch (_a) {\n      const res = [];\n\n      for (let i = 0; i < distances.length; i++) {\n        const x = Math.random() * linkDistance;\n        const y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n\n      return res;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/layout/radial/mds.ts"],"names":[],"mappings":"AACA,SAAS,MAAM,IAAI,QAAnB,EAA6B,0BAA7B,QAA+D,WAA/D;AAEA,eAAc,MAAO,GAAP,CAAU;AAUtB,EAAA,WAAA,CAAY,MAAZ,EAAqF;AACnF,SAAK,SAAL,GAAiB,MAAM,CAAC,SAAxB;AACA,SAAK,SAAL,GAAiB,MAAM,CAAC,SAAP,IAAoB,CAArC;AACA,SAAK,YAAL,GAAoB,MAAM,CAAC,YAA3B;AACD;;AAEM,EAAA,MAAM,GAAA;AACX,UAAM,IAAI,GAAG,IAAb;AACA,UAAM;AAAE,MAAA,SAAF;AAAa,MAAA,SAAb;AAAwB,MAAA;AAAxB,QAAyC,IAA/C;;AAEA,QAAI;AACF;AACA,YAAM,CAAC,GAAG,QAAQ,CAAC,GAAT,CAAa,QAAQ,CAAC,GAAT,CAAa,SAAb,EAAwB,CAAxB,CAAb,EAAyC,CAAC,GAA1C,CAAV,CAFE,CAIF;;AACA,YAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,KAAP,CAAjB;AACA,YAAM,QAAQ,GAAG,CAAC,CAAC,IAAF,CAAO,QAAP,CAAjB;AACA,YAAM,SAAS,GAAG,CAAC,CAAC,IAAF,EAAlB;AACA,MAAA,CAAC,CAAC,GAAF,CAAM,SAAN,EAAiB,YAAjB,CAA8B,QAA9B,EAAwC,eAAxC,CAAwD,QAAxD,EARE,CAUF;AACA;;AACA,YAAM,GAAG,GAAG,IAAI,0BAAJ,CAA+B,CAA/B,CAAZ;AACA,YAAM,WAAW,GAAG,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,cAAlB,EAAkC,QAAlC,EAApB;AACA,aAAO,GAAG,CAAC,mBAAJ,CAAwB,MAAxB,GAAiC,GAAjC,CAAsC,GAAD,IAAkB;AAC5D,eAAO,QAAQ,CAAC,GAAT,CAAa,CAAC,GAAD,CAAb,EAAoB,CAAC,WAAD,CAApB,EAAmC,MAAnC,GAA4C,CAA5C,EAA+C,MAA/C,CAAsD,CAAtD,EAAyD,SAAzD,CAAP;AACD,OAFM,CAAP;AAGD,KAjBD,CAiBE,OAAA,EAAA,EAAM;AACN,YAAM,GAAG,GAAiB,EAA1B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,cAAM,CAAC,GAAG,IAAI,CAAC,MAAL,KAAgB,YAA1B;AACA,cAAM,CAAC,GAAG,IAAI,CAAC,MAAL,KAAgB,YAA1B;AACA,QAAA,GAAG,CAAC,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,CAAT;AACD;;AACD,aAAO,GAAP;AACD;AACF;;AA9CqB","sourceRoot":"","sourcesContent":["import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nexport default class MDS {\n    constructor(params) {\n        this.distances = params.distances;\n        this.dimension = params.dimension || 2;\n        this.linkDistance = params.linkDistance;\n    }\n    layout() {\n        const self = this;\n        const { dimension, distances, linkDistance } = self;\n        try {\n            // square distances\n            const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n            // double centre the rows/columns\n            const rowMeans = M.mean('row');\n            const colMeans = M.mean('column');\n            const totalMean = M.mean();\n            M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);\n            // take the SVD of the double centred matrix, and return the\n            // points from it\n            const ret = new SingularValueDecomposition(M);\n            const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n            return ret.leftSingularVectors.toJSON().map((row) => {\n                return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n            });\n        }\n        catch (_a) {\n            const res = [];\n            for (let i = 0; i < distances.length; i++) {\n                const x = Math.random() * linkDistance;\n                const y = Math.random() * linkDistance;\n                res.push([x, y]);\n            }\n            return res;\n        }\n    }\n}\n//# sourceMappingURL=mds.js.map"]},"metadata":{},"sourceType":"module"}