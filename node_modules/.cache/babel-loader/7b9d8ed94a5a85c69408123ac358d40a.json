{"ast":null,"code":"import { isArray } from '@antv/util';\n/**\n * 根据 edges 获取对应的 node 结构\n */\n\nexport function getNodes(edges, sourceField, targetField) {\n  var nodes = [];\n  edges.forEach(function (e) {\n    var source = e[sourceField];\n    var target = e[targetField];\n\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    }\n\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    }\n  });\n  return nodes;\n}\n/**\n * 根据 edges 获取对应的 dfs 邻接矩阵\n */\n\nexport function getMatrix(edges, nodes, sourceField, targetField) {\n  var graphMatrix = {};\n  nodes.forEach(function (pre) {\n    graphMatrix[pre] = {};\n    nodes.forEach(function (next) {\n      graphMatrix[pre][next] = 0;\n    });\n  });\n  edges.forEach(function (edge) {\n    graphMatrix[edge[sourceField]][edge[targetField]] = 1;\n  });\n  return graphMatrix;\n}\n/**\n * 使用 DFS 思路切断桑基图数据中的环（会丢失数据），保证顺序\n * @param data\n * @param sourceField\n * @param targetField\n */\n\nexport function cutoffCircle(edges, sourceField, targetField) {\n  if (!isArray(edges)) return []; // 待删除的环状结构\n\n  var removedData = []; // 获取所有的节点\n\n  var nodes = getNodes(edges, sourceField, targetField); // 获取节点与边的邻接矩阵\n\n  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField); // visited：标记节点访问状态, 0：未访问,1：访问中, -1：已访问\n\n  var visited = {}; // 初始化visited\n\n  nodes.forEach(function (node) {\n    visited[node] = 0;\n  }); // 图的深度遍历函数\n\n  function DFS(dfsNode) {\n    // 节点状态置为正在访问\n    visited[dfsNode] = 1;\n    nodes.forEach(function (node) {\n      if (graphMatrix[dfsNode][node] != 0) {\n        // 当前节点在访问中，再次被访问，证明有环，移动到 removeData\n        if (visited[node] == 1) {\n          // 拼接为字符串，方便最后过滤\n          removedData.push(dfsNode + \"_\" + node);\n        } else if (visited[node] == -1) {\n          // 当前结点及后边的结点都被访问过，直接跳至下一个结点\n          return;\n        } else {\n          DFS(node); // 否则递归访问\n        }\n      }\n    }); //遍历过所有相连的结点后，把本节点标记为-1\n\n    visited[dfsNode] = -1;\n  } // 对每个节点执行 dfs 操作\n\n\n  nodes.forEach(function (node) {\n    //该结点后边的结点都被访问过了，跳过它\n    if (visited[node] == -1) {\n      return;\n    }\n\n    DFS(node);\n  });\n\n  if (removedData.length !== 0) {\n    console.warn(\"sankey data contains circle, \" + removedData.length + \" records removed.\", removedData);\n  } // 过滤 remove 路径\n\n\n  return edges.filter(function (edge) {\n    return removedData.findIndex(function (i) {\n      return i === edge[sourceField] + \"_\" + edge[targetField];\n    }) < 0;\n  });\n}","map":{"version":3,"sources":["../../../src/plots/sankey/circle.ts"],"names":[],"mappings":"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","sourcesContent":["import { isArray } from '@antv/util';\nimport { Data } from '../../types';\n\n/**\n * 根据 edges 获取对应的 node 结构\n */\nexport function getNodes(edges: Data, sourceField: string, targetField: string): string[] {\n  const nodes = [];\n  edges.forEach((e) => {\n    const source = e[sourceField] as string;\n    const target = e[targetField] as string;\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    }\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    }\n  });\n  return nodes;\n}\n\n/**\n * 根据 edges 获取对应的 dfs 邻接矩阵\n */\nexport function getMatrix(\n  edges: Data,\n  nodes: string[],\n  sourceField: string,\n  targetField: string\n): Record<string, Record<string, number>> {\n  const graphMatrix = {};\n\n  nodes.forEach((pre) => {\n    graphMatrix[pre] = {};\n    nodes.forEach((next) => {\n      graphMatrix[pre][next] = 0;\n    });\n  });\n\n  edges.forEach((edge) => {\n    graphMatrix[edge[sourceField]][edge[targetField]] = 1;\n  });\n\n  return graphMatrix;\n}\n\n/**\n * 使用 DFS 思路切断桑基图数据中的环（会丢失数据），保证顺序\n * @param data\n * @param sourceField\n * @param targetField\n */\nexport function cutoffCircle(edges: Data, sourceField: string, targetField: string): Data {\n  if (!isArray(edges)) return [];\n\n  // 待删除的环状结构\n  const removedData = [];\n\n  // 获取所有的节点\n  const nodes = getNodes(edges, sourceField, targetField);\n  // 获取节点与边的邻接矩阵\n  const graphMatrix = getMatrix(edges, nodes, sourceField, targetField);\n\n  // visited：标记节点访问状态, 0：未访问,1：访问中, -1：已访问\n  const visited = {};\n  // 初始化visited\n  nodes.forEach((node) => {\n    visited[node] = 0;\n  });\n\n  // 图的深度遍历函数\n  function DFS(dfsNode) {\n    // 节点状态置为正在访问\n    visited[dfsNode] = 1;\n    nodes.forEach((node) => {\n      if (graphMatrix[dfsNode][node] != 0) {\n        // 当前节点在访问中，再次被访问，证明有环，移动到 removeData\n        if (visited[node] == 1) {\n          // 拼接为字符串，方便最后过滤\n          removedData.push(`${dfsNode}_${node}`);\n        } else if (visited[node] == -1) {\n          // 当前结点及后边的结点都被访问过，直接跳至下一个结点\n          return;\n        } else {\n          DFS(node); // 否则递归访问\n        }\n      }\n    });\n    //遍历过所有相连的结点后，把本节点标记为-1\n    visited[dfsNode] = -1;\n  }\n\n  // 对每个节点执行 dfs 操作\n  nodes.forEach((node) => {\n    //该结点后边的结点都被访问过了，跳过它\n    if (visited[node] == -1) {\n      return;\n    }\n    DFS(node);\n  });\n\n  if (removedData.length !== 0) {\n    console.warn(`sankey data contains circle, ${removedData.length} records removed.`, removedData);\n  }\n\n  // 过滤 remove 路径\n  return edges.filter((edge) => removedData.findIndex((i) => i === `${edge[sourceField]}_${edge[targetField]}`) < 0);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}