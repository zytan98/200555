{"ast":null,"code":"import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  as: ['x', 'y', 'r'],\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  }\n};\nexport function pack(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var packLayout = function (data) {\n    return d3Hierarchy.pack().size(options.size).padding(options.padding)(d3Hierarchy.hierarchy(data).sum(function (d) {\n      return d[field];\n    }).sort(options.sort));\n  };\n\n  var root = packLayout(data);\n  var x = as[0];\n  var y = as[1];\n  var r = as[2];\n  root.each(function (node) {\n    node[x] = node.x;\n    node[y] = node.y;\n    node[r] = node.r;\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"sources":["../../../src/utils/hierarchy/pack.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,WAAZ,MAA6B,cAA7B;AACA,SAAS,MAAT,EAAiB,OAAjB,QAAgC,YAAhC;AACA,SAAS,QAAT,EAAmB,WAAnB,QAAsC,QAAtC;AAKA,IAAM,eAAe,GAAY;AAC/B,EAAA,KAAK,EAAE,OADwB;AAE/B,EAAA,EAAE,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAF2B;AAG/B;AACA,EAAA,IAAI,EAAE,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,CAAC,KAAF,GAAU,CAAC,CAAX,KAAA;AAAiB;AAJF,CAAjC;AAOA,OAAM,SAAU,IAAV,CAAe,IAAf,EAA0B,OAA1B,EAA0C;AAC9C,EAAA,OAAO,GAAG,MAAM,CAAC,EAAD,EAAgB,eAAhB,EAAiC,OAAjC,CAAhB;AACA,MAAM,EAAE,GAAG,OAAO,CAAC,EAAnB;;AACA,MAAI,CAAC,OAAO,CAAC,EAAD,CAAR,IAAgB,EAAE,CAAC,MAAH,KAAc,CAAlC,EAAqC;AACnC,UAAM,IAAI,SAAJ,CAAc,0EAAd,CAAN;AACD;;AAED,MAAI,KAAJ;;AACA,MAAI;AACF,IAAA,KAAK,GAAG,QAAQ,CAAC,OAAD,CAAhB;AACD,GAFD,CAEE,OAAO,CAAP,EAAU;AACV,IAAA,OAAO,CAAC,IAAR,CAAa,CAAb;AACD;;AAED,MAAM,UAAU,GAAG,UAAC,IAAD,EAAK;AACtB,WAAA,WAAW,CAAC,IAAZ,GAAmB,IAAnB,CAAwB,OAAO,CAAC,IAAhC,EAAsC,OAAtC,CAA8C,OAAO,CAAC,OAAtD,EACE,WAAW,CACR,SADH,CACa,IADb,EAEG,GAFH,CAEO,UAAC,CAAD,EAAE;AAAK,aAAA,CAAC,CAAD,KAAC,CAAD;AAAQ,KAFtB,EAGG,IAHH,CAGQ,OAAO,CAAC,IAHhB,CADF,CAAA;AAKC,GANH;;AAQA,MAAM,IAAI,GAAG,UAAU,CAAC,IAAD,CAAvB;AAEA,MAAM,CAAC,GAAG,EAAE,CAAC,CAAD,CAAZ;AACA,MAAM,CAAC,GAAG,EAAE,CAAC,CAAD,CAAZ;AACA,MAAM,CAAC,GAAG,EAAE,CAAC,CAAD,CAAZ;AACA,EAAA,IAAI,CAAC,IAAL,CAAU,UAAC,IAAD,EAAK;AACb,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,CAAC,CAAf;AACA,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,CAAC,CAAf;AACA,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,CAAC,CAAf;AACD,GAJD;AAMA,SAAO,WAAW,CAAC,IAAD,CAAlB;AACD","sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nimport { HierarchyOption } from './types';\n\ntype Options = Omit<HierarchyOption, 'as'> & { as?: [string, string, string] };\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  as: ['x', 'y', 'r'],\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n};\n\nexport function pack(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const packLayout = (data) =>\n    d3Hierarchy.pack().size(options.size).padding(options.padding)(\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) => d[field])\n        .sort(options.sort)\n    );\n\n  const root = packLayout(data);\n\n  const x = as[0];\n  const y = as[1];\n  const r = as[2];\n  root.each((node) => {\n    node[x] = node.x;\n    node[y] = node.y;\n    node[r] = node.r;\n  });\n\n  return getAllNodes(root);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}