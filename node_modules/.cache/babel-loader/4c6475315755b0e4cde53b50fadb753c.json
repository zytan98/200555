{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { AST_TOKEN_TYPES, createEntity, isSafari, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nvar WebGPUComputeModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n  function WebGPUComputeModel(engine, context) {\n    _classCallCheck(this, WebGPUComputeModel);\n\n    this.engine = engine;\n    this.context = context;\n    this.entity = createEntity();\n    this.uniformGPUBufferLayout = [];\n    this.uniformBuffer = void 0;\n    this.vertexBuffers = {};\n    this.outputBuffer = void 0;\n    this.bindGroupEntries = void 0;\n    this.bindGroup = void 0;\n    this.computePipeline = void 0;\n  }\n\n  _createClass(WebGPUComputeModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.compileComputePipelineStageDescriptor(this.context.shader);\n\n              case 2:\n                _yield$this$compileCo = _context.sent;\n                computeStage = _yield$this$compileCo.computeStage;\n                buffers = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.StorageBuffer;\n                });\n                uniforms = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.Uniform;\n                });\n                bufferBindingIndex = uniforms.length ? 1 : 0;\n                this.bindGroupEntries = [];\n\n                if (bufferBindingIndex) {\n                  offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n                  // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n\n                  mergedUniformData = [];\n                  uniforms.forEach(function (uniform) {\n                    if (isNumber(uniform.data)) {\n                      _this.uniformGPUBufferLayout.push({\n                        name: uniform.name,\n                        offset: offset\n                      });\n\n                      offset += 4; // @ts-ignore\n\n                      mergedUniformData.push(uniform.data);\n                    } else {\n                      var _uniform$data; // @ts-ignore\n\n\n                      var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;\n\n                      if (originDataLength === 3) {\n                        // vec3 -> vec4\n                        // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n                        originDataLength = 4; // @ts-ignore\n\n                        uniform.data.push(0);\n                      } // 4 elements per block/line\n\n\n                      var padding = offset / 4 % 4;\n\n                      if (padding > 0) {\n                        var space = 4 - padding;\n\n                        if (originDataLength > 1 && originDataLength <= space) {\n                          if (originDataLength === 2) {\n                            if (space === 3) {\n                              offset += 4;\n                              mergedUniformData.push(0);\n                            } // @ts-ignore\n\n\n                            mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                            _this.uniformGPUBufferLayout.push({\n                              name: uniform.name,\n                              offset: offset\n                            });\n                          }\n                        } else {\n                          for (var i = 0; i < space; i++) {\n                            offset += 4;\n                            mergedUniformData.push(0);\n                          } // @ts-ignore\n\n\n                          mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                          _this.uniformGPUBufferLayout.push({\n                            name: uniform.name,\n                            offset: offset\n                          });\n                        }\n                      }\n\n                      offset += 4 * originDataLength;\n                    }\n                  });\n                  this.uniformBuffer = new WebGPUBuffer(this.engine, {\n                    // TODO: 处理 Struct 和 boolean\n                    // @ts-ignore\n                    data: mergedUniformData instanceof Array ? // @ts-ignore\n                    new Float32Array(mergedUniformData) : mergedUniformData,\n                    usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n                  });\n                  this.bindGroupEntries.push({\n                    binding: 0,\n                    resource: {\n                      buffer: this.uniformBuffer.get()\n                    }\n                  });\n                } // create GPUBuffers for storeage buffers\n\n\n                buffers.forEach(function (buffer) {\n                  if (buffer.data !== null) {\n                    if (buffer.type === AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === AST_TOKEN_TYPES.FloatArray) {\n                      var gpuBuffer;\n\n                      if (buffer.name === _this.context.output.name) {\n                        gpuBuffer = new WebGPUBuffer(_this.engine, {\n                          // @ts-ignore\n                          data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                          usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                        });\n                        _this.outputBuffer = gpuBuffer;\n                        _this.context.output = {\n                          name: buffer.name,\n                          // @ts-ignore\n                          length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n                          typedArrayConstructor: Float32Array,\n                          gpuBuffer: gpuBuffer.get()\n                        };\n                      } else {\n                        if (buffer.isReferer) {\n                          // @ts-ignore\n                          if (buffer.data.model && buffer.data.model.outputBuffer) {\n                            // @ts-ignore\n                            gpuBuffer = buffer.data.model.outputBuffer;\n                          } else {// referred kernel haven't been executed\n                          }\n                        } else {\n                          gpuBuffer = new WebGPUBuffer(_this.engine, {\n                            // @ts-ignore\n                            data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                            usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                          });\n                        }\n                      } // @ts-ignore\n\n\n                      _this.vertexBuffers[buffer.name] = gpuBuffer;\n\n                      _this.bindGroupEntries.push({\n                        binding: bufferBindingIndex,\n                        resource: {\n                          name: buffer.name,\n                          refer: gpuBuffer ? undefined : buffer.data,\n                          // @ts-ignore\n                          buffer: gpuBuffer ? gpuBuffer.get() : undefined\n                        }\n                      });\n\n                      bufferBindingIndex++;\n                    }\n                  }\n                }); // create compute pipeline layout\n\n                this.computePipeline = this.engine.device.createComputePipeline({\n                  computeStage: computeStage\n                });\n                console.log(this.bindGroupEntries);\n                this.bindGroup = this.engine.device.createBindGroup({\n                  layout: this.computePipeline.getBindGroupLayout(0),\n                  entries: this.bindGroupEntries\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      if (this.uniformBuffer) {\n        this.uniformBuffer.destroy();\n      }\n\n      Object.keys(this.vertexBuffers).forEach(function (bufferName) {\n        return _this2.vertexBuffers[bufferName].destroy();\n      });\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var output, length, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                output = this.context.output;\n\n                if (!output) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                length = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;\n\n                if (!gpuBuffer) {\n                  _context2.next = 16;\n                  break;\n                } // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n                // const arraybuffer = gpuBuffer.getMappedRange();\n                // let arraybuffer;\n                // if (isSafari) {\n                //   arraybuffer = await gpuBuffer.mapReadAsync();\n                // } else {\n\n\n                byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT; // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n\n                gpuReadBuffer = this.engine.device.createBuffer({\n                  size: byteCount,\n                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n                });\n                encoder = this.engine.device.createCommandEncoder();\n                encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n                queue = isSafari ? // @ts-ignore\n                this.engine.device.getQueue() : this.engine.device.defaultQueue;\n                queue.submit([encoder.finish()]);\n                _context2.next = 12;\n                return gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n\n              case 12:\n                arraybuffer = gpuReadBuffer.getMappedRange();\n                typedArray = new typedArrayConstructor(arraybuffer.slice(0));\n                gpuReadBuffer.unmap();\n                return _context2.abrupt(\"return\", typedArray);\n\n              case 16:\n                return _context2.abrupt(\"return\", new Float32Array());\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.engine.currentComputePass) {\n        var _this$engine$currentC;\n\n        this.engine.currentComputePass.setPipeline(this.computePipeline); // this.bindGroupEntries.forEach((entry) => {\n        //   if (!entry.resource.buffer) {\n        //     // get referred kernel's output\n        //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n        //       .outputBuffer;\n        //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n        //     entry.resource.buffer = gpuBuffer.get();\n        //   }\n        // });\n        // const bindGroup = this.engine.device.createBindGroup({\n        //   layout: this.computePipeline.getBindGroupLayout(0),\n        //   entries: this.bindGroupEntries,\n        // });\n\n        this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n\n        (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, _toConsumableArray(this.context.dispatch));\n      }\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var buffer = this.vertexBuffers[bufferName];\n\n      if (buffer) {\n        buffer.subData({\n          data: data,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform(uniformName, data) {\n      var layout = this.uniformGPUBufferLayout.find(function (l) {\n        return l.name === uniformName;\n      });\n\n      if (layout) {\n        this.uniformBuffer.subData({\n          data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),\n          offset: layout.offset\n        });\n      }\n    }\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      // copy output GPUBuffer of kernel\n      var inputBuffer = this.vertexBuffers[inputName];\n      var outputBuffer = model.outputBuffer;\n\n      if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n        var encoder = this.engine.device.createCommandEncoder();\n        var _context$output = model.context.output,\n            length = _context$output.length,\n            typedArrayConstructor = _context$output.typedArrayConstructor;\n        var byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT;\n        encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);\n        var queue = isSafari ? // @ts-ignore\n        this.engine.device.getQueue() : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n      }\n    }\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"compileComputePipelineStageDescriptor\",\n    value: function () {\n      var _compileComputePipelineStageDescriptor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(computeCode) {\n        var computeShader, shaderVersion;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                computeShader = computeCode;\n                shaderVersion = '#version 450\\n';\n\n                if (this.engine.options.useWGSL) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this.compileShaderToSpirV(computeCode, 'compute', shaderVersion);\n\n              case 5:\n                computeShader = _context3.sent;\n\n              case 6:\n                return _context3.abrupt(\"return\", {\n                  computeStage: {\n                    module: this.engine.device.createShaderModule({\n                      code: computeShader,\n                      // @ts-ignore\n                      isWHLSL: isSafari\n                    }),\n                    entryPoint: 'main'\n                  }\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function compileComputePipelineStageDescriptor(_x) {\n        return _compileComputePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compileComputePipelineStageDescriptor;\n    }()\n  }]);\n\n  return WebGPUComputeModel;\n}();\n\nexport { WebGPUComputeModel as default };","map":{"version":3,"sources":["../../src/webgpu/WebGPUComputeModel.ts"],"names":["WebGPUComputeModel","entity","createEntity","uniformGPUBufferLayout","uniformBuffer","vertexBuffers","outputBuffer","bindGroupEntries","bindGroup","computePipeline","engine","context","computeStage","buffers","uniform","STORAGE_CLASS","uniforms","bufferBindingIndex","offset","mergedUniformData","isNumber","name","originDataLength","padding","space","i","data","usage","WebGPUConstants","CopyDst","binding","resource","buffer","AST_TOKEN_TYPES","gpuBuffer","isFinite","Number","CopySrc","length","typedArrayConstructor","refer","undefined","console","layout","entries","Object","output","byteCount","BYTES_PER_ELEMENT","gpuReadBuffer","size","GPUBufferUsage","MAP_READ","encoder","queue","isSafari","defaultQueue","arraybuffer","typedArray","bufferName","uniformName","l","model","inputName","inputBuffer","source","type","shaderVersion","computeCode","computeShader","useWGSL","module","code","isWHLSL","entryPoint"],"mappings":"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","sourcesContent":["import {\n  AST_TOKEN_TYPES,\n  createEntity,\n  GLSLContext,\n  IComputeModel,\n  isSafari,\n  STORAGE_CLASS,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nexport default class WebGPUComputeModel implements IComputeModel {\n  private entity = createEntity();\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  private uniformBuffer: WebGPUBuffer;\n  private vertexBuffers: Record<string, WebGPUBuffer> = {};\n  private outputBuffer: WebGPUBuffer;\n  private bindGroupEntries: GPUBindGroupEntry[];\n  private bindGroup: GPUBindGroup;\n\n  private computePipeline: GPUComputePipeline;\n\n  constructor(private engine: WebGPUEngine, private context: GLSLContext) {}\n\n  public async init() {\n    const { computeStage } = await this.compileComputePipelineStageDescriptor(\n      this.context.shader!,\n    );\n\n    const buffers = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.StorageBuffer,\n    );\n    const uniforms = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.Uniform,\n    );\n\n    let bufferBindingIndex = uniforms.length ? 1 : 0;\n    this.bindGroupEntries = [];\n    if (bufferBindingIndex) {\n      let offset = 0;\n      // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n      // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n      const mergedUniformData: number[] = [];\n      uniforms.forEach((uniform) => {\n        if (isNumber(uniform.data)) {\n          this.uniformGPUBufferLayout.push({\n            name: uniform.name,\n            offset,\n          });\n          offset += 4;\n          // @ts-ignore\n          mergedUniformData.push(uniform.data);\n        } else {\n          // @ts-ignore\n          let originDataLength = uniform.data?.length || 1;\n          if (originDataLength === 3) {\n            // vec3 -> vec4\n            // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n            originDataLength = 4;\n            // @ts-ignore\n            uniform.data.push(0);\n          }\n          // 4 elements per block/line\n          const padding = (offset / 4) % 4;\n          if (padding > 0) {\n            const space = 4 - padding;\n            if (originDataLength > 1 && originDataLength <= space) {\n              if (originDataLength === 2) {\n                if (space === 3) {\n                  offset += 4;\n                  mergedUniformData.push(0);\n                }\n                // @ts-ignore\n                mergedUniformData.push(...uniform.data);\n                this.uniformGPUBufferLayout.push({\n                  name: uniform.name,\n                  offset,\n                });\n              }\n            } else {\n              for (let i = 0; i < space; i++) {\n                offset += 4;\n                mergedUniformData.push(0);\n              }\n              // @ts-ignore\n              mergedUniformData.push(...uniform.data);\n              this.uniformGPUBufferLayout.push({\n                name: uniform.name,\n                offset,\n              });\n            }\n          }\n\n          offset += 4 * originDataLength;\n        }\n      });\n\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n\n      this.bindGroupEntries.push({\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(),\n        },\n      });\n    }\n\n    // create GPUBuffers for storeage buffers\n    buffers.forEach((buffer) => {\n      if (buffer.data !== null) {\n        if (\n          buffer.type === AST_TOKEN_TYPES.Vector4FloatArray ||\n          buffer.type === AST_TOKEN_TYPES.FloatArray\n        ) {\n          let gpuBuffer;\n          if (buffer.name === this.context.output.name) {\n            gpuBuffer = new WebGPUBuffer(this.engine, {\n              // @ts-ignore\n              data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n              usage:\n                WebGPUConstants.BufferUsage.Storage |\n                WebGPUConstants.BufferUsage.CopyDst |\n                WebGPUConstants.BufferUsage.CopySrc,\n            });\n            this.outputBuffer = gpuBuffer;\n            this.context.output = {\n              name: buffer.name,\n              // @ts-ignore\n              length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n              typedArrayConstructor: Float32Array,\n              gpuBuffer: gpuBuffer.get(),\n            };\n          } else {\n            if (buffer.isReferer) {\n              // @ts-ignore\n              if (buffer.data.model && buffer.data.model.outputBuffer) {\n                // @ts-ignore\n                gpuBuffer = (buffer.data.model as WebGPUComputeModel)\n                  .outputBuffer;\n              } else {\n                // referred kernel haven't been executed\n              }\n            } else {\n              gpuBuffer = new WebGPUBuffer(this.engine, {\n                // @ts-ignore\n                data: isFinite(Number(buffer.data))\n                  ? [buffer.data]\n                  : buffer.data,\n                usage:\n                  WebGPUConstants.BufferUsage.Storage |\n                  WebGPUConstants.BufferUsage.CopyDst |\n                  WebGPUConstants.BufferUsage.CopySrc,\n              });\n            }\n          }\n\n          // @ts-ignore\n          this.vertexBuffers[buffer.name] = gpuBuffer;\n          this.bindGroupEntries.push({\n            binding: bufferBindingIndex,\n            resource: {\n              name: buffer.name,\n              refer: gpuBuffer ? undefined : buffer.data,\n              // @ts-ignore\n              buffer: gpuBuffer ? gpuBuffer.get() : undefined,\n            },\n          });\n          bufferBindingIndex++;\n        }\n      }\n    });\n\n    // create compute pipeline layout\n    this.computePipeline = this.engine.device.createComputePipeline({\n      computeStage,\n    });\n\n    console.log(this.bindGroupEntries);\n\n    this.bindGroup = this.engine.device.createBindGroup({\n      layout: this.computePipeline.getBindGroupLayout(0),\n      entries: this.bindGroupEntries,\n    });\n  }\n\n  public destroy(): void {\n    if (this.uniformBuffer) {\n      this.uniformBuffer.destroy();\n    }\n\n    Object.keys(this.vertexBuffers).forEach((bufferName) =>\n      this.vertexBuffers[bufferName].destroy(),\n    );\n  }\n\n  public async readData() {\n    const { output } = this.context;\n    if (output) {\n      const { length, typedArrayConstructor, gpuBuffer } = output;\n      if (gpuBuffer) {\n        // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        // const arraybuffer = gpuBuffer.getMappedRange();\n        // let arraybuffer;\n\n        // if (isSafari) {\n        //   arraybuffer = await gpuBuffer.mapReadAsync();\n        // } else {\n        const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n\n        // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n        const gpuReadBuffer = this.engine.device.createBuffer({\n          size: byteCount,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        const encoder = this.engine.device.createCommandEncoder();\n        encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n        const queue: GPUQueue = isSafari\n          ? // @ts-ignore\n            this.engine.device.getQueue()\n          : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n\n        await gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        const arraybuffer = gpuReadBuffer.getMappedRange();\n        const typedArray = new typedArrayConstructor!(arraybuffer.slice(0));\n        gpuReadBuffer.unmap();\n\n        return typedArray;\n      }\n    }\n    return new Float32Array();\n  }\n\n  public run() {\n    if (this.engine.currentComputePass) {\n      this.engine.currentComputePass.setPipeline(this.computePipeline);\n\n      // this.bindGroupEntries.forEach((entry) => {\n      //   if (!entry.resource.buffer) {\n      //     // get referred kernel's output\n      //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n      //       .outputBuffer;\n      //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n      //     entry.resource.buffer = gpuBuffer.get();\n      //   }\n      // });\n\n      // const bindGroup = this.engine.device.createBindGroup({\n      //   layout: this.computePipeline.getBindGroupLayout(0),\n      //   entries: this.bindGroupEntries,\n      // });\n      this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n      this.engine.currentComputePass.dispatch(...this.context.dispatch);\n    }\n  }\n\n  public updateBuffer(\n    bufferName: string,\n    data:\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n    offset: number = 0,\n  ) {\n    const buffer = this.vertexBuffers[bufferName];\n    if (buffer) {\n      buffer.subData({ data, offset });\n    }\n  }\n\n  public updateUniform(\n    uniformName: string,\n    data:\n      | number\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n  ) {\n    const layout = this.uniformGPUBufferLayout.find(\n      (l) => l.name === uniformName,\n    );\n\n    if (layout) {\n      this.uniformBuffer.subData({\n        data: Number.isFinite(data)\n          ? new Float32Array([data as number])\n          : new Float32Array(\n              data as\n                | number[]\n                | Float32Array\n                | Uint8Array\n                | Uint16Array\n                | Uint32Array\n                | Int8Array\n                | Int16Array\n                | Int32Array,\n            ),\n        offset: layout.offset,\n      });\n    }\n  }\n\n  public confirmInput(model: IComputeModel, inputName: string): void {\n    // copy output GPUBuffer of kernel\n    const inputBuffer = this.vertexBuffers[inputName];\n    const outputBuffer = (model as WebGPUComputeModel).outputBuffer;\n\n    if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n      const encoder = this.engine.device.createCommandEncoder();\n      const {\n        length,\n        typedArrayConstructor,\n      } = (model as WebGPUComputeModel).context.output;\n      const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n      encoder.copyBufferToBuffer(\n        outputBuffer.get(),\n        0,\n        inputBuffer.get(),\n        0,\n        byteCount,\n      );\n      const queue: GPUQueue = isSafari\n        ? // @ts-ignore\n          this.engine.device.getQueue()\n        : this.engine.device.defaultQueue;\n      queue.submit([encoder.finish()]);\n    }\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private async compileComputePipelineStageDescriptor(\n    computeCode: string,\n  ): Promise<Pick<GPUComputePipelineDescriptor, 'computeStage'>> {\n    let computeShader: Uint32Array | string = computeCode;\n    const shaderVersion = '#version 450\\n';\n    if (!this.engine.options.useWGSL) {\n      computeShader = await this.compileShaderToSpirV(\n        computeCode,\n        'compute',\n        shaderVersion,\n      );\n    }\n\n    return {\n      computeStage: {\n        module: this.engine.device.createShaderModule({\n          code: computeShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}