{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { isSafari } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\n\nvar WebGPUBuffer = /*#__PURE__*/function () {\n  function WebGPUBuffer(engine, options) {\n    _classCallCheck(this, WebGPUBuffer);\n\n    this.engine = engine;\n    this.options = options;\n    this.buffer = void 0;\n    var _options = options,\n        data = _options.data,\n        usage = _options.usage,\n        type = _options.type;\n    this.buffer = this.createBuffer(data instanceof Array ? new Float32Array(data) : data, // TODO: WebGL 和 WebGPU buffer usage 映射关系\n    usage || WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\n  }\n\n  _createClass(WebGPUBuffer, [{\n    key: \"get\",\n    value: function get() {\n      return this.buffer;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.buffer.destroy();\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(_ref) {\n      var data = _ref.data,\n          offset = _ref.offset;\n      this.setSubData(this.buffer, offset, data instanceof Array ? new Float32Array(data) : data);\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(view, flags) {\n      // @ts-ignore\n      var padding = view.byteLength % 4;\n      var verticesBufferDescriptor = {\n        // @ts-ignore\n        size: view.byteLength + padding,\n        usage: flags\n      };\n      var buffer = this.engine.device.createBuffer(verticesBufferDescriptor);\n      this.setSubData(buffer, 0, view);\n      return buffer;\n    }\n    /**\n     * 不同于 Babylon.js 的版本，使用最新的 GPUQueue.writeBuffer 方法\n     * @see https://gpuweb.github.io/gpuweb/#dom-gpuqueue-writebuffer\n     * 已废弃创建一个临时的 mapped buffer 用于拷贝数据 @see https://gpuweb.github.io/gpuweb/#GPUDevice-createBufferMapped\n     * @see https://github.com/gpuweb/gpuweb/blob/master/design/BufferOperations.md#updating-data-to-an-existing-buffer-like-webgls-buffersubdata\n     */\n\n  }, {\n    key: \"setSubData\",\n    value: function setSubData(destBuffer, destOffset, srcArrayBuffer) {\n      // deprecated API setSubData\n      // destBuffer.setSubData(0, srcArrayBuffer);\n      // deprecated API createBufferMapped\n      // use createBuffer & getMappedRange instead\n      // const [srcBuffer, arrayBuffer] = this.engine.device.createBufferMapped({\n      //   size: byteCount,\n      //   usage: WebGPUConstants.BufferUsage.CopySrc,\n      // });\n      var queue = isSafari ? // @ts-ignore\n      this.engine.device.getQueue() : this.engine.device.defaultQueue; // @ts-ignore\n\n      queue.writeBuffer(destBuffer, destOffset, srcArrayBuffer);\n    }\n  }]);\n\n  return WebGPUBuffer;\n}();\n\nexport { WebGPUBuffer as default };","map":{"version":3,"sources":["../../src/webgpu/WebGPUBuffer.ts"],"names":["WebGPUBuffer","buffer","engine","options","data","usage","type","WebGPUConstants","offset","view","flags","padding","verticesBufferDescriptor","size","destBuffer","destOffset","srcArrayBuffer","queue","isSafari"],"mappings":";;AAAA,SAAA,QAAA,QAAA,qBAAA;AAOA,OAAO,KAAP,eAAA,MAAA,8BAAA;;IAGqBA,Y;AAGnB,WAAA,YAAA,CAAA,MAAA,EAAA,OAAA,EAGE;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;;AAAA,SAFQE,MAER,GAFQA,MAER;AAAA,SADQC,OACR,GADQA,OACR;AAAA,SALMF,MAKN,GAAA,KAAA,CAAA;AAAA,QAAA,QAAA,GAAA,OAAA;AAAA,QACQG,IADR,GAAA,QAAA,CAAA,IAAA;AAAA,QACcC,KADd,GAAA,QAAA,CAAA,KAAA;AAAA,QACqBC,IADrB,GAAA,QAAA,CAAA,IAAA;AAEA,SAAA,MAAA,GAAc,KAAA,YAAA,CACZF,IAAI,YAAJA,KAAAA,GAAwB,IAAA,YAAA,CAAxBA,IAAwB,CAAxBA,GADY,IAAA,EAEZ;AACAC,IAAAA,KAAK,IACHE,eAAe,CAAfA,WAAAA,CAAAA,MAAAA,GACEA,eAAe,CAAfA,WAAAA,CALN,OAAc,CAAd;AAOD;;;;0BAEY;AACX,aAAO,KAAP,MAAA;AACD;;;8BAEgB;AACf,WAAA,MAAA,CAAA,OAAA;AACD;;;kCAEsE;AAAA,UAAtDH,IAAsD,GAAA,IAAA,CAAtDA,IAAsD;AAAA,UAAhDI,MAAgD,GAAA,IAAA,CAAhDA,MAAgD;AACrE,WAAA,UAAA,CACE,KADF,MAAA,EAAA,MAAA,EAGEJ,IAAI,YAAJA,KAAAA,GAAwB,IAAA,YAAA,CAAxBA,IAAwB,CAAxBA,GAHF,IAAA;AAKD;;;iCAGCK,I,EACAC,K,EACW;AACX;AACA,UAAMC,OAAO,GAAGF,IAAI,CAAJA,UAAAA,GAAhB,CAAA;AACA,UAAMG,wBAAwB,GAAG;AAC/B;AACAC,QAAAA,IAAI,EAAEJ,IAAI,CAAJA,UAAAA,GAFyB,OAAA;AAG/BJ,QAAAA,KAAK,EAAEK;AAHwB,OAAjC;AAKA,UAAMT,MAAM,GAAG,KAAA,MAAA,CAAA,MAAA,CAAA,YAAA,CAAf,wBAAe,CAAf;AAEA,WAAA,UAAA,CAAA,MAAA,EAAA,CAAA,EAAA,IAAA;AAEA,aAAA,MAAA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;+BAEIa,U,EACAC,U,EACAC,c,EACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,UAAMC,KAAe,GAAGC,QAAQ,GAC5B;AACA,WAAA,MAAA,CAAA,MAAA,CAF4B,QAE5B,EAF4B,GAG5B,KAAA,MAAA,CAAA,MAAA,CAdJ,YAWA,CAXA,CAeA;;AACAD,MAAAA,KAAK,CAALA,WAAAA,CAAAA,UAAAA,EAAAA,UAAAA,EAAAA,cAAAA;AACD;;;;;;SA9EkBjB,Y","sourcesContent":["import {\n  BufferData,\n  gl,\n  IBuffer,\n  IBufferInitializationOptions,\n  isSafari,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\n\nexport default class WebGPUBuffer implements IBuffer {\n  private buffer: GPUBuffer;\n\n  constructor(\n    private engine: WebGPUEngine,\n    private options: IBufferInitializationOptions,\n  ) {\n    const { data, usage, type } = options;\n    this.buffer = this.createBuffer(\n      data instanceof Array ? new Float32Array(data) : data,\n      // TODO: WebGL 和 WebGPU buffer usage 映射关系\n      usage ||\n        WebGPUConstants.BufferUsage.Vertex |\n          WebGPUConstants.BufferUsage.CopyDst,\n    );\n  }\n\n  public get() {\n    return this.buffer;\n  }\n\n  public destroy() {\n    this.buffer.destroy();\n  }\n\n  public subData({ data, offset }: { data: BufferData; offset: number }) {\n    this.setSubData(\n      this.buffer,\n      offset,\n      data instanceof Array ? new Float32Array(data) : data,\n    );\n  }\n\n  private createBuffer(\n    view: Exclude<BufferData, number[]>,\n    flags: GPUBufferUsageFlags,\n  ): GPUBuffer {\n    // @ts-ignore\n    const padding = view.byteLength % 4;\n    const verticesBufferDescriptor = {\n      // @ts-ignore\n      size: view.byteLength + padding,\n      usage: flags,\n    };\n    const buffer = this.engine.device.createBuffer(verticesBufferDescriptor);\n\n    this.setSubData(buffer, 0, view);\n\n    return buffer;\n  }\n\n  /**\n   * 不同于 Babylon.js 的版本，使用最新的 GPUQueue.writeBuffer 方法\n   * @see https://gpuweb.github.io/gpuweb/#dom-gpuqueue-writebuffer\n   * 已废弃创建一个临时的 mapped buffer 用于拷贝数据 @see https://gpuweb.github.io/gpuweb/#GPUDevice-createBufferMapped\n   * @see https://github.com/gpuweb/gpuweb/blob/master/design/BufferOperations.md#updating-data-to-an-existing-buffer-like-webgls-buffersubdata\n   */\n  private setSubData(\n    destBuffer: GPUBuffer,\n    destOffset: number,\n    srcArrayBuffer: Exclude<BufferData, number[]>,\n  ) {\n    // deprecated API setSubData\n    // destBuffer.setSubData(0, srcArrayBuffer);\n\n    // deprecated API createBufferMapped\n    // use createBuffer & getMappedRange instead\n    // const [srcBuffer, arrayBuffer] = this.engine.device.createBufferMapped({\n    //   size: byteCount,\n    //   usage: WebGPUConstants.BufferUsage.CopySrc,\n    // });\n\n    const queue: GPUQueue = isSafari\n      ? // @ts-ignore\n        this.engine.device.getQueue()\n      : this.engine.device.defaultQueue;\n    // @ts-ignore\n    queue.writeBuffer(destBuffer, destOffset, srcArrayBuffer);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}