{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { Action } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { findViewById } from '../../../../utils';\nimport { EDGES_VIEW_ID, NODES_VIEW_ID } from '../../constant';\n\nvar SankeyNodeDragAction =\n/** @class */\nfunction (_super) {\n  __extends(SankeyNodeDragAction, _super);\n\n  function SankeyNodeDragAction() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * 是否在拖拽中的标记\n     */\n\n\n    _this.isDragging = false;\n    return _this;\n  }\n  /**\n   * 当前操作的是否是 element\n   */\n\n\n  SankeyNodeDragAction.prototype.isNodeElement = function () {\n    var shape = get(this.context, 'event.target');\n\n    if (shape) {\n      var element = shape.get('element');\n      return element && element.getModel().data.isNode;\n    }\n\n    return false;\n  };\n\n  SankeyNodeDragAction.prototype.getNodeView = function () {\n    return findViewById(this.context.view, NODES_VIEW_ID);\n  };\n\n  SankeyNodeDragAction.prototype.getEdgeView = function () {\n    return findViewById(this.context.view, EDGES_VIEW_ID);\n  };\n  /**\n   * 获取当前操作的 index\n   * @param element\n   */\n\n\n  SankeyNodeDragAction.prototype.getCurrentDatumIdx = function (element) {\n    return this.getNodeView().geometries[0].elements.indexOf(element);\n  };\n  /**\n   * 点击下去，开始\n   */\n\n\n  SankeyNodeDragAction.prototype.start = function () {\n    // 记录开始了的状态\n    if (this.isNodeElement()) {\n      this.prevPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var element = this.context.event.target.get('element');\n      var idx = this.getCurrentDatumIdx(element);\n\n      if (idx === -1) {\n        return;\n      }\n\n      this.currentElementIdx = idx;\n      this.context.isDragging = true;\n      this.isDragging = true; // 关闭动画并暂存配置\n\n      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;\n      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;\n      this.getNodeView().animate(false);\n      this.getEdgeView().animate(false);\n    }\n  };\n  /**\n   * 移动过程中，平移\n   */\n\n\n  SankeyNodeDragAction.prototype.translate = function () {\n    if (this.isDragging) {\n      var chart = this.context.view;\n      var currentPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var x = currentPoint.x - this.prevPoint.x;\n      var y = currentPoint.y - this.prevPoint.y;\n      var nodeView = this.getNodeView();\n      var element = nodeView.geometries[0].elements[this.currentElementIdx]; // 修改数据\n\n      if (element && element.getModel()) {\n        var prevDatum = element.getModel().data;\n        var data = nodeView.getOptions().data;\n        var coordinate = nodeView.getCoordinate();\n        var datumGap_1 = {\n          x: x / coordinate.getWidth(),\n          y: y / coordinate.getHeight()\n        };\n\n        var nextDatum = __assign(__assign({}, prevDatum), {\n          x: prevDatum.x.map(function (x) {\n            return x += datumGap_1.x;\n          }),\n          y: prevDatum.y.map(function (y) {\n            return y += datumGap_1.y;\n          })\n        }); // 处理一下在 [0, 1] 范围\n        // 1. 更新 node 数据\n\n\n        var newData = __spreadArrays(data);\n\n        newData[this.currentElementIdx] = nextDatum;\n        nodeView.data(newData); // 2. 更新 edge 数据\n\n        var name_1 = prevDatum.name;\n        var edgeView = this.getEdgeView();\n        var edgeData = edgeView.getOptions().data;\n        edgeData.forEach(function (datum) {\n          // 2.1 以该 node 为 source 的边，修改 [x0, x1, x2, x3] 中的 x0, x1\n          if (datum.source === name_1) {\n            datum.x[0] += datumGap_1.x;\n            datum.x[1] += datumGap_1.x;\n            datum.y[0] += datumGap_1.y;\n            datum.y[1] += datumGap_1.y;\n          } // 2.2 以该 node 为 target 的边，修改 [x0, x1, x2, x3] 中的 x2, x3\n\n\n          if (datum.target === name_1) {\n            datum.x[2] += datumGap_1.x;\n            datum.x[3] += datumGap_1.x;\n            datum.y[2] += datumGap_1.y;\n            datum.y[3] += datumGap_1.y;\n          }\n        });\n        edgeView.data(edgeData); // 3. 更新最新位置\n\n        this.prevPoint = currentPoint; // node edge 都改变了，所以要从底层 render\n\n        chart.render(true);\n      }\n    }\n  };\n  /**\n   * 结论，清除状态\n   */\n\n\n  SankeyNodeDragAction.prototype.end = function () {\n    this.isDragging = false;\n    this.context.isDragging = false;\n    this.prevPoint = null;\n    this.currentElementIdx = null; // 还原动画\n\n    this.getNodeView().animate(this.prevNodeAnimateCfg);\n    this.getEdgeView().animate(this.prevEdgeAnimateCfg);\n  };\n\n  return SankeyNodeDragAction;\n}(Action);\n\nexport { SankeyNodeDragAction };","map":{"version":3,"sources":["../../../../../src/plots/sankey/interactions/actions/node-drag.ts"],"names":[],"mappings":"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","sourcesContent":["import { Action, Element } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { Datum, Point } from '../../../../types';\nimport { findViewById } from '../../../../utils';\nimport { EDGES_VIEW_ID, NODES_VIEW_ID } from '../../constant';\n\nexport class SankeyNodeDragAction extends Action {\n  /**\n   * 是否在拖拽中的标记\n   */\n  private isDragging = false;\n\n  /**\n   * 鼠标上一次的位置的坐标点\n   */\n  private prevPoint: Point;\n  /**\n   * 之前的节点动画配置\n   */\n  private prevNodeAnimateCfg: any;\n  /**\n   * 之前的边动画配置\n   */\n  private prevEdgeAnimateCfg: any;\n  /**\n   * 当前拖拽的 element 索引\n   */\n  private currentElementIdx: number;\n\n  /**\n   * 当前操作的是否是 element\n   */\n  private isNodeElement() {\n    const shape = get(this.context, 'event.target');\n    if (shape) {\n      const element = shape.get('element');\n      return element && element.getModel().data.isNode;\n    }\n    return false;\n  }\n\n  private getNodeView() {\n    return findViewById(this.context.view, NODES_VIEW_ID);\n  }\n\n  private getEdgeView() {\n    return findViewById(this.context.view, EDGES_VIEW_ID);\n  }\n\n  /**\n   * 获取当前操作的 index\n   * @param element\n   */\n  private getCurrentDatumIdx(element: Element) {\n    return this.getNodeView().geometries[0].elements.indexOf(element);\n  }\n\n  /**\n   * 点击下去，开始\n   */\n  public start() {\n    // 记录开始了的状态\n    if (this.isNodeElement()) {\n      this.prevPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y'),\n      };\n\n      const element = this.context.event.target.get('element');\n      const idx = this.getCurrentDatumIdx(element);\n\n      if (idx === -1) {\n        return;\n      }\n\n      this.currentElementIdx = idx;\n      this.context.isDragging = true;\n      this.isDragging = true;\n\n      // 关闭动画并暂存配置\n      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;\n      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;\n      this.getNodeView().animate(false);\n      this.getEdgeView().animate(false);\n    }\n  }\n\n  /**\n   * 移动过程中，平移\n   */\n  public translate() {\n    if (this.isDragging) {\n      const chart = this.context.view;\n\n      const currentPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y'),\n      };\n\n      const x = currentPoint.x - this.prevPoint.x;\n      const y = currentPoint.y - this.prevPoint.y;\n\n      const nodeView = this.getNodeView();\n      const element = nodeView.geometries[0].elements[this.currentElementIdx];\n\n      // 修改数据\n      if (element && element.getModel()) {\n        const prevDatum: Datum = element.getModel().data;\n        const data = nodeView.getOptions().data;\n        const coordinate = nodeView.getCoordinate();\n\n        const datumGap = {\n          x: x / coordinate.getWidth(),\n          y: y / coordinate.getHeight(),\n        };\n\n        const nextDatum = {\n          ...prevDatum,\n          x: prevDatum.x.map((x: number) => (x += datumGap.x)),\n          y: prevDatum.y.map((y: number) => (y += datumGap.y)),\n        };\n        // 处理一下在 [0, 1] 范围\n\n        // 1. 更新 node 数据\n        const newData = [...data];\n        newData[this.currentElementIdx] = nextDatum;\n        nodeView.data(newData);\n\n        // 2. 更新 edge 数据\n        const name = prevDatum.name;\n        const edgeView = this.getEdgeView();\n        const edgeData = edgeView.getOptions().data;\n\n        edgeData.forEach((datum) => {\n          // 2.1 以该 node 为 source 的边，修改 [x0, x1, x2, x3] 中的 x0, x1\n          if (datum.source === name) {\n            datum.x[0] += datumGap.x;\n            datum.x[1] += datumGap.x;\n            datum.y[0] += datumGap.y;\n            datum.y[1] += datumGap.y;\n          }\n\n          // 2.2 以该 node 为 target 的边，修改 [x0, x1, x2, x3] 中的 x2, x3\n          if (datum.target === name) {\n            datum.x[2] += datumGap.x;\n            datum.x[3] += datumGap.x;\n            datum.y[2] += datumGap.y;\n            datum.y[3] += datumGap.y;\n          }\n        });\n        edgeView.data(edgeData);\n\n        // 3. 更新最新位置\n        this.prevPoint = currentPoint;\n\n        // node edge 都改变了，所以要从底层 render\n        chart.render(true);\n      }\n    }\n  }\n\n  /**\n   * 结论，清除状态\n   */\n  public end() {\n    this.isDragging = false;\n    this.context.isDragging = false;\n    this.prevPoint = null;\n    this.currentElementIdx = null;\n\n    // 还原动画\n    this.getNodeView().animate(this.prevNodeAnimateCfg);\n    this.getEdgeView().animate(this.prevEdgeAnimateCfg);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}