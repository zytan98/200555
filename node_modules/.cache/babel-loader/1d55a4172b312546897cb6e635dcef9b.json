{"ast":null,"code":"const SPEED_DIVISOR = 800;\nexport default class RadialNonoverlapForce {\n  constructor(params) {\n    this.disp = [];\n    this.positions = params.positions;\n    this.adjMatrix = params.adjMatrix;\n    this.focusID = params.focusID;\n    this.radii = params.radii;\n    this.iterations = params.iterations || 10;\n    this.height = params.height || 10;\n    this.width = params.width || 10;\n    this.speed = params.speed || 100;\n    this.gravity = params.gravity || 10;\n    this.nodeSizeFunc = params.nodeSizeFunc;\n    this.k = params.k || 5;\n    this.strictRadial = params.strictRadial;\n    this.nodes = params.nodes;\n  }\n\n  layout() {\n    const self = this;\n    const positions = self.positions;\n    const disp = [];\n    const iterations = self.iterations;\n    const maxDisplace = self.width / 10;\n    self.maxDisplace = maxDisplace;\n    self.disp = disp;\n\n    for (let i = 0; i < iterations; i++) {\n      positions.forEach((_, k) => {\n        disp[k] = {\n          x: 0,\n          y: 0\n        };\n      }); // 给重叠的节点增加斥力\n\n      self.getRepulsion();\n      self.updatePositions();\n    }\n\n    return positions;\n  }\n\n  getRepulsion() {\n    const self = this;\n    const positions = self.positions;\n    const nodes = self.nodes;\n    const disp = self.disp;\n    const k = self.k;\n    const radii = self.radii || [];\n    positions.forEach((v, i) => {\n      disp[i] = {\n        x: 0,\n        y: 0\n      };\n      positions.forEach((u, j) => {\n        if (i === j) {\n          return;\n        } // v and u are not on the same circle, return\n\n\n        if (radii[i] !== radii[j]) {\n          return;\n        }\n\n        let vecx = v[0] - u[0];\n        let vecy = v[1] - u[1];\n        let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n\n        if (vecLength === 0) {\n          vecLength = 1;\n          const sign = i > j ? 1 : -1;\n          vecx = 0.01 * sign;\n          vecy = 0.01 * sign;\n        } // these two nodes overlap\n\n\n        if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n          const common = k * k / vecLength;\n          disp[i].x += vecx / vecLength * common;\n          disp[i].y += vecy / vecLength * common;\n        }\n      });\n    });\n  }\n\n  updatePositions() {\n    const self = this;\n    const positions = self.positions;\n    const disp = self.disp;\n    const speed = self.speed;\n    const strictRadial = self.strictRadial;\n    const f = self.focusID;\n    const maxDisplace = self.maxDisplace || self.width / 10;\n\n    if (strictRadial) {\n      disp.forEach((di, i) => {\n        const vx = positions[i][0] - positions[f][0];\n        const vy = positions[i][1] - positions[f][1];\n        const vLength = Math.sqrt(vx * vx + vy * vy);\n        let vpx = vy / vLength;\n        let vpy = -vx / vLength;\n        const diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n        let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n\n        if (alpha > Math.PI / 2) {\n          alpha -= Math.PI / 2;\n          vpx *= -1;\n          vpy *= -1;\n        }\n\n        const tdispLength = Math.cos(alpha) * diLength;\n        di.x = vpx * tdispLength;\n        di.y = vpy * tdispLength;\n      });\n    } // move\n\n\n    const radii = self.radii;\n    positions.forEach((n, i) => {\n      if (i === f) {\n        return;\n      }\n\n      const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n\n      if (distLength > 0 && i !== f) {\n        const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n[0] += disp[i].x / distLength * limitedDist;\n        n[1] += disp[i].y / distLength * limitedDist;\n\n        if (strictRadial) {\n          let vx = n[0] - positions[f][0];\n          let vy = n[1] - positions[f][1];\n          const nfDis = Math.sqrt(vx * vx + vy * vy);\n          vx = vx / nfDis * radii[i];\n          vy = vy / nfDis * radii[i];\n          n[0] = positions[f][0] + vx;\n          n[1] = positions[f][1] + vy;\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/layout/radial/radialNonoverlapForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["const SPEED_DIVISOR = 800;\nexport default class RadialNonoverlapForce {\n    constructor(params) {\n        this.disp = [];\n        this.positions = params.positions;\n        this.adjMatrix = params.adjMatrix;\n        this.focusID = params.focusID;\n        this.radii = params.radii;\n        this.iterations = params.iterations || 10;\n        this.height = params.height || 10;\n        this.width = params.width || 10;\n        this.speed = params.speed || 100;\n        this.gravity = params.gravity || 10;\n        this.nodeSizeFunc = params.nodeSizeFunc;\n        this.k = params.k || 5;\n        this.strictRadial = params.strictRadial;\n        this.nodes = params.nodes;\n    }\n    layout() {\n        const self = this;\n        const positions = self.positions;\n        const disp = [];\n        const iterations = self.iterations;\n        const maxDisplace = self.width / 10;\n        self.maxDisplace = maxDisplace;\n        self.disp = disp;\n        for (let i = 0; i < iterations; i++) {\n            positions.forEach((_, k) => {\n                disp[k] = { x: 0, y: 0 };\n            });\n            // 给重叠的节点增加斥力\n            self.getRepulsion();\n            self.updatePositions();\n        }\n        return positions;\n    }\n    getRepulsion() {\n        const self = this;\n        const positions = self.positions;\n        const nodes = self.nodes;\n        const disp = self.disp;\n        const k = self.k;\n        const radii = self.radii || [];\n        positions.forEach((v, i) => {\n            disp[i] = { x: 0, y: 0 };\n            positions.forEach((u, j) => {\n                if (i === j) {\n                    return;\n                }\n                // v and u are not on the same circle, return\n                if (radii[i] !== radii[j]) {\n                    return;\n                }\n                let vecx = v[0] - u[0];\n                let vecy = v[1] - u[1];\n                let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n                if (vecLength === 0) {\n                    vecLength = 1;\n                    const sign = i > j ? 1 : -1;\n                    vecx = 0.01 * sign;\n                    vecy = 0.01 * sign;\n                }\n                // these two nodes overlap\n                if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n                    const common = (k * k) / vecLength;\n                    disp[i].x += (vecx / vecLength) * common;\n                    disp[i].y += (vecy / vecLength) * common;\n                }\n            });\n        });\n    }\n    updatePositions() {\n        const self = this;\n        const positions = self.positions;\n        const disp = self.disp;\n        const speed = self.speed;\n        const strictRadial = self.strictRadial;\n        const f = self.focusID;\n        const maxDisplace = self.maxDisplace || self.width / 10;\n        if (strictRadial) {\n            disp.forEach((di, i) => {\n                const vx = positions[i][0] - positions[f][0];\n                const vy = positions[i][1] - positions[f][1];\n                const vLength = Math.sqrt(vx * vx + vy * vy);\n                let vpx = vy / vLength;\n                let vpy = -vx / vLength;\n                const diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n                let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n                if (alpha > Math.PI / 2) {\n                    alpha -= Math.PI / 2;\n                    vpx *= -1;\n                    vpy *= -1;\n                }\n                const tdispLength = Math.cos(alpha) * diLength;\n                di.x = vpx * tdispLength;\n                di.y = vpy * tdispLength;\n            });\n        }\n        // move\n        const radii = self.radii;\n        positions.forEach((n, i) => {\n            if (i === f) {\n                return;\n            }\n            const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n            if (distLength > 0 && i !== f) {\n                const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n                n[0] += (disp[i].x / distLength) * limitedDist;\n                n[1] += (disp[i].y / distLength) * limitedDist;\n                if (strictRadial) {\n                    let vx = n[0] - positions[f][0];\n                    let vy = n[1] - positions[f][1];\n                    const nfDis = Math.sqrt(vx * vx + vy * vy);\n                    vx = (vx / nfDis) * radii[i];\n                    vy = (vy / nfDis) * radii[i];\n                    n[0] = positions[f][0] + vx;\n                    n[1] = positions[f][1] + vy;\n                }\n            }\n        });\n    }\n}\n//# sourceMappingURL=radialNonoverlapForce.js.map"]},"metadata":{},"sourceType":"module"}