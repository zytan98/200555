{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.fmin = global.fmin || {});\n})(this, function (exports) {\n  'use strict';\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n          fMid = f(mid);\n\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n\n    return a + delta;\n  } // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n\n\n  function zeros(x) {\n    var r = new Array(x);\n\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n\n    return r;\n  }\n\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n\n  function dot(a, b) {\n    var ret = 0;\n\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n\n    return ret;\n  }\n\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n  /** minimizes a function using the downhill simplex method */\n\n\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = parameters.rho !== undefined ? parameters.rho : 1,\n        chi = parameters.chi !== undefined ? parameters.chi : 2,\n        psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n        sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n        maxDiff; // initialize simplex.\n\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n\n      simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function (a, b) {\n      return a.fx - b.fx;\n    };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n\n      maxDiff = 0;\n\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      } // compute the centroid of all but the worst point in the simplex\n\n\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n\n        centroid[i] /= N;\n      } // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n\n\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected); // if the reflected point is the best seen, then possibly expand\n\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      } // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        var shouldReduce = false;\n\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break; // do a reduction\n\n          for (i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  } /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n\n\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n        phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0,\n        phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n\n      return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n\n    return a;\n  }\n\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        next = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        yk = initial.slice(),\n        pk,\n        temp,\n        a = 1,\n        maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a); // todo: history in wrong spot?\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polakâ€“Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n            beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n\n    return current;\n  }\n\n  function gradientDescent(f, initial, params) {\n    params = params || {};\n    var maxIterations = params.maxIterations || initial.length * 100,\n        learnRate = params.learnRate || 0.001,\n        current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    };\n\n    for (var i = 0; i < maxIterations; ++i) {\n      current.fx = f(current.x, current.fxprime);\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice()\n        });\n      }\n\n      weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n\n    return current;\n  }\n\n  function gradientDescentLineSearch(f, initial, params) {\n    params = params || {};\n    var current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        next = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        maxIterations = params.maxIterations || initial.length * 100,\n        learnRate = params.learnRate || 1,\n        pk = initial.slice(),\n        c1 = params.c1 || 1e-3,\n        c2 = params.c2 || 0.1,\n        temp,\n        functionCalls = [];\n\n    if (params.history) {\n      // wrap the function call to track linesearch samples\n      var inner = f;\n\n      f = function (x, fxprime) {\n        functionCalls.push(x.slice());\n        return inner(x, fxprime);\n      };\n    }\n\n    current.fx = f(current.x, current.fxprime);\n\n    for (var i = 0; i < maxIterations; ++i) {\n      scale(pk, current.fxprime, -1);\n      learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          functionCalls: functionCalls,\n          learnRate: learnRate,\n          alpha: learnRate\n        });\n        functionCalls = [];\n      }\n\n      temp = current;\n      current = next;\n      next = temp;\n      if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n    }\n\n    return current;\n  }\n\n  exports.bisect = bisect;\n  exports.nelderMead = nelderMead;\n  exports.conjugateGradient = conjugateGradient;\n  exports.gradientDescent = gradientDescent;\n  exports.gradientDescentLineSearch = gradientDescentLineSearch;\n  exports.zeros = zeros;\n  exports.zerosM = zerosM;\n  exports.norm2 = norm2;\n  exports.weightedSum = weightedSum;\n  exports.scale = scale;\n});","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/fmin/build/fmin.js"],"names":["global","factory","exports","module","define","amd","fmin","bisect","f","a","b","parameters","maxIterations","tolerance","fA","fB","delta","i","mid","fMid","Math","abs","zeros","x","r","Array","zerosM","y","map","dot","ret","length","norm2","sqrt","scale","value","c","weightedSum","w1","v1","w2","v2","j","nelderMead","x0","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","id","point","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","max","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","beta_k","gradientDescent","learnRate","gradientDescentLineSearch","functionCalls","inner"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.fmin = global.fmin || {})));\n}(this, function (exports) { 'use strict';\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function scale(ret, value, c) {\n        for (var i = 0; i < value.length; ++i) {\n            ret[i] = value[i] * c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.05,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n            chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n            maxDiff;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n            simplex[i+1].id = i+1;\n        }\n\n        function updateSimplex(value) {\n            for (var i = 0; i < value.length; i++) {\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function (x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n                parameters.history.push({x: simplex[0].slice(),\n                                         fx: simplex[0].fx,\n                                         simplex: sortedSimplex});\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                }  else {\n                    updateSimplex(reflected);\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n\n                    // do a reduction\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        simplex.sort(sortOrder);\n        return {fx : simplex[0].fx,\n                x : simplex[0]};\n    }\n\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return a;\n    }\n\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime,-1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            a = wolfeLineSearch(f, pk, current, next, a);\n\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     alpha: a});\n            }\n\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n\n            } else {\n                // update direction using Polakâ€“Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        return current;\n    }\n\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 0.001,\n            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};\n\n        for (var i = 0; i < maxIterations; ++i) {\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice()});\n            }\n\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        return current;\n    }\n\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 1,\n            pk = initial.slice(),\n            c1 = params.c1 || 1e-3,\n            c2 = params.c2 || 0.1,\n            temp,\n            functionCalls = [];\n\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n\n        current.fx = f(current.x, current.fxprime);\n        for (var i = 0; i < maxIterations; ++i) {\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     functionCalls: functionCalls,\n                                     learnRate: learnRate,\n                                     alpha: learnRate});\n                functionCalls = [];\n            }\n\n\n            temp = current;\n            current = next;\n            next = temp;\n\n            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;\n        }\n\n        return current;\n    }\n\n    exports.bisect = bisect;\n    exports.nelderMead = nelderMead;\n    exports.conjugateGradient = conjugateGradient;\n    exports.gradientDescent = gradientDescent;\n    exports.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports.zeros = zeros;\n    exports.zerosM = zerosM;\n    exports.norm2 = norm2;\n    exports.weightedSum = weightedSum;\n    exports.scale = scale;\n\n}));"]},"metadata":{},"sourceType":"script"}