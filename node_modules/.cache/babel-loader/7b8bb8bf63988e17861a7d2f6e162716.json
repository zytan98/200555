{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nexport var\n/**\n * borrow from playcanvas\n */\nSphere = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Sphere, _Geometry);\n\n  var _super = _createSuper(Sphere);\n\n  function Sphere() {\n    _classCallCheck(this, Sphere);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Sphere, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n          _this$config$radius = _this$config.radius,\n          radius = _this$config$radius === void 0 ? 0.5 : _this$config$radius,\n          _this$config$latitude = _this$config.latitudeBands,\n          latitudeBands = _this$config$latitude === void 0 ? 16 : _this$config$latitude,\n          _this$config$longitud = _this$config.longitudeBands,\n          longitudeBands = _this$config$longitud === void 0 ? 16 : _this$config$longitud;\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var indices = [];\n\n      for (var lat = 0; lat <= latitudeBands; lat++) {\n        var theta = lat * Math.PI / latitudeBands;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n\n        for (var lon = 0; lon <= longitudeBands; lon++) {\n          // Sweep the sphere from the positive Z axis to match a 3DS Max sphere\n          var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;\n          var sinPhi = Math.sin(phi);\n          var cosPhi = Math.cos(phi);\n          var x = cosPhi * sinTheta;\n          var y = cosTheta;\n          var z = sinPhi * sinTheta;\n          var u = 1.0 - lon / longitudeBands;\n          var v = 1.0 - lat / latitudeBands;\n          positions.push(x * radius, y * radius, z * radius);\n          normals.push(x, y, z);\n          uvs.push(u, v);\n        }\n      }\n\n      for (var _lat = 0; _lat < latitudeBands; ++_lat) {\n        for (var _lon = 0; _lon < longitudeBands; ++_lon) {\n          var first = _lat * (longitudeBands + 1) + _lon;\n          var second = first + longitudeBands + 1;\n          indices.push(first + 1, second, first);\n          indices.push(first + 1, second + 1, second);\n        }\n      } // generate AABB\n\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = positions.length / 3;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n\n  return Sphere;\n}(Geometry)) || _class);","map":{"version":3,"sources":["../../src/geometry/Sphere.ts"],"names":["injectable","Sphere","radius","latitudeBands","longitudeBands","positions","normals","uvs","indices","lat","theta","Math","sinTheta","cosTheta","lon","phi","sinPhi","cosPhi","x","y","z","u","v","first","second","aabb","generateAABBFromVertices","component","Uint32Array","dirty","name","data","Float32Array","arrayStride","stepMode","attributes","shaderLocation","offset","format"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,wBAAA,QAAA,qBAAA;AAEA,SAAA,UAAA,QAAA,WAAA;AACA,SAAA,QAAA,QAAA,GAAA;AAYA,OAAA;AAHA;AACA;AACA;AACaC,MAAb,IAAA,IAAA,GAJCD,UAAU,EAIX,EAAA,IAAA,CAAA,MAAA,GAAA,aAAA,UAAA,SAAA,EAAA;AAAA,EAAA,SAAA,CAAA,MAAA,EAAA,SAAA,CAAA;;AAAA,MAAA,MAAA,GAAA,YAAA,CAAA,MAAA,CAAA;;AAAA,WAAA,MAAA,GAAA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;AAAA,WAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;AAAA;;AAAA,EAAA,YAAA,CAAA,MAAA,EAAA,CAAA;AAAA,IAAA,GAAA,EAAA,iBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,eAAA,GAC8B;AAAA,UAAA,YAAA,GAKtB,KALsB,MAAA;AAAA,UAAA,mBAAA,GAAA,YAAA,CAAA,MAAA;AAAA,UAExBE,MAFwB,GAAA,mBAAA,KAAA,KAAA,CAAA,GAAA,GAAA,GAAA,mBAAA;AAAA,UAAA,qBAAA,GAAA,YAAA,CAAA,aAAA;AAAA,UAGxBC,aAHwB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,qBAAA;AAAA,UAAA,qBAAA,GAAA,YAAA,CAAA,cAAA;AAAA,UAIxBC,cAJwB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,qBAAA;AAO1B,UAAMC,SAAmB,GAAzB,EAAA;AACA,UAAMC,OAAiB,GAAvB,EAAA;AACA,UAAMC,GAAa,GAAnB,EAAA;AACA,UAAMC,OAAiB,GAAvB,EAAA;;AAEA,WAAK,IAAIC,GAAG,GAAZ,CAAA,EAAkBA,GAAG,IAArB,aAAA,EAAwCA,GAAxC,EAAA,EAA+C;AAC7C,YAAMC,KAAK,GAAID,GAAG,GAAGE,IAAI,CAAX,EAACF,GAAf,aAAA;AACA,YAAMG,QAAQ,GAAGD,IAAI,CAAJA,GAAAA,CAAjB,KAAiBA,CAAjB;AACA,YAAME,QAAQ,GAAGF,IAAI,CAAJA,GAAAA,CAAjB,KAAiBA,CAAjB;;AAEA,aAAK,IAAIG,GAAG,GAAZ,CAAA,EAAkBA,GAAG,IAArB,cAAA,EAAyCA,GAAzC,EAAA,EAAgD;AAC9C;AACA,cAAMC,GAAG,GAAID,GAAG,GAAHA,CAAAA,GAAUH,IAAI,CAAf,EAACG,GAAD,cAACA,GAAsCH,IAAI,CAAJA,EAAAA,GAAnD,GAAA;AACA,cAAMK,MAAM,GAAGL,IAAI,CAAJA,GAAAA,CAAf,GAAeA,CAAf;AACA,cAAMM,MAAM,GAAGN,IAAI,CAAJA,GAAAA,CAAf,GAAeA,CAAf;AAEA,cAAMO,CAAC,GAAGD,MAAM,GAAhB,QAAA;AACA,cAAME,CAAC,GAAP,QAAA;AACA,cAAMC,CAAC,GAAGJ,MAAM,GAAhB,QAAA;AACA,cAAMK,CAAC,GAAG,MAAMP,GAAG,GAAnB,cAAA;AACA,cAAMQ,CAAC,GAAG,MAAMb,GAAG,GAAnB,aAAA;AAEAJ,UAAAA,SAAS,CAATA,IAAAA,CAAea,CAAC,GAAhBb,MAAAA,EAA2Bc,CAAC,GAA5Bd,MAAAA,EAAuCe,CAAC,GAAxCf,MAAAA;AACAC,UAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA;AACAC,UAAAA,GAAG,CAAHA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACD;AACF;;AAED,WAAK,IAAIE,IAAG,GAAZ,CAAA,EAAkBA,IAAG,GAArB,aAAA,EAAuC,EAAvC,IAAA,EAA8C;AAC5C,aAAK,IAAIK,IAAG,GAAZ,CAAA,EAAkBA,IAAG,GAArB,cAAA,EAAwC,EAAxC,IAAA,EAA+C;AAC7C,cAAMS,KAAK,GAAGd,IAAG,IAAIL,cAAc,GAArBK,CAAG,CAAHA,GAAd,IAAA;AACA,cAAMe,MAAM,GAAGD,KAAK,GAALA,cAAAA,GAAf,CAAA;AAEAf,UAAAA,OAAO,CAAPA,IAAAA,CAAae,KAAK,GAAlBf,CAAAA,EAAAA,MAAAA,EAAAA,KAAAA;AACAA,UAAAA,OAAO,CAAPA,IAAAA,CAAae,KAAK,GAAlBf,CAAAA,EAAwBgB,MAAM,GAA9BhB,CAAAA,EAAAA,MAAAA;AACD;AA1CuB,OAAA,CA6C1B;;;AACA,UAAMiB,IAAI,GAAGC,wBAAwB,CAArC,SAAqC,CAArC;AAEA,UAAMC,SAAS,GAAG,KAAlB,YAAkB,EAAlB;AACAA,MAAAA,SAAS,CAATA,OAAAA,GAAoBC,WAAW,CAAXA,IAAAA,CAApBD,OAAoBC,CAApBD;AACAA,MAAAA,SAAS,CAATA,IAAAA,GAAAA,IAAAA;AACAA,MAAAA,SAAS,CAATA,WAAAA,GAAwBtB,SAAS,CAATA,MAAAA,GAAxBsB,CAAAA;AACAA,MAAAA,SAAS,CAATA,UAAAA,GAAuB,CACrB;AACEE,QAAAA,KAAK,EADP,IAAA;AAEEC,QAAAA,IAAI,EAFN,UAAA;AAGEC,QAAAA,IAAI,EAAEC,YAAY,CAAZA,IAAAA,CAHR,SAGQA,CAHR;AAIEC,QAAAA,WAAW,EAAE,IAJf,CAAA;AAKEC,QAAAA,QAAQ,EALV,QAAA;AAMEC,QAAAA,UAAU,EAAE,CACV;AACEC,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AANd,OADqB,EAerB;AACET,QAAAA,KAAK,EADP,IAAA;AAEEC,QAAAA,IAAI,EAFN,QAAA;AAGEC,QAAAA,IAAI,EAAEC,YAAY,CAAZA,IAAAA,CAHR,OAGQA,CAHR;AAIEC,QAAAA,WAAW,EAAE,IAJf,CAAA;AAKEC,QAAAA,QAAQ,EALV,QAAA;AAMEC,QAAAA,UAAU,EAAE,CACV;AACEC,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AANd,OAfqB,EA6BrB;AACET,QAAAA,KAAK,EADP,IAAA;AAEEC,QAAAA,IAAI,EAFN,IAAA;AAGEC,QAAAA,IAAI,EAAEC,YAAY,CAAZA,IAAAA,CAHR,GAGQA,CAHR;AAIEC,QAAAA,WAAW,EAAE,IAJf,CAAA;AAKEC,QAAAA,QAAQ,EALV,QAAA;AAMEC,QAAAA,UAAU,EAAE,CACV;AACEC,UAAAA,cAAc,EADhB,CAAA;AAEEC,UAAAA,MAAM,EAFR,CAAA;AAGEC,UAAAA,MAAM,EAAE;AAHV,SADU;AANd,OA7BqB,CAAvBX,CApD0B,CAiG1B;AACD;AAnGH,GAAA,CAAA,CAAA;;AAAA,SAAA,MAAA;AAAA,CAAA,CAAA,QAAA,CAAA,CAAA,IAAA,MAAA,CAAA","sourcesContent":["import { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Geometry } from '.';\n\nexport interface ISphereGeometryParams {\n  radius: number;\n  latitudeBands: number;\n  longitudeBands: number;\n}\n\n@injectable()\n/**\n * borrow from playcanvas\n */\nexport class Sphere extends Geometry<Partial<ISphereGeometryParams>> {\n  protected onEntityCreated() {\n    const {\n      radius = 0.5,\n      latitudeBands = 16,\n      longitudeBands = 16,\n    } = this.config;\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    for (let lat = 0; lat <= latitudeBands; lat++) {\n      const theta = (lat * Math.PI) / latitudeBands;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n\n      for (let lon = 0; lon <= longitudeBands; lon++) {\n        // Sweep the sphere from the positive Z axis to match a 3DS Max sphere\n        const phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2.0;\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n\n        const x = cosPhi * sinTheta;\n        const y = cosTheta;\n        const z = sinPhi * sinTheta;\n        const u = 1.0 - lon / longitudeBands;\n        const v = 1.0 - lat / latitudeBands;\n\n        positions.push(x * radius, y * radius, z * radius);\n        normals.push(x, y, z);\n        uvs.push(u, v);\n      }\n    }\n\n    for (let lat = 0; lat < latitudeBands; ++lat) {\n      for (let lon = 0; lon < longitudeBands; ++lon) {\n        const first = lat * (longitudeBands + 1) + lon;\n        const second = first + longitudeBands + 1;\n\n        indices.push(first + 1, second, first);\n        indices.push(first + 1, second + 1, second);\n      }\n    }\n\n    // generate AABB\n    const aabb = generateAABBFromVertices(positions);\n\n    const component = this.getComponent();\n    component.indices = Uint32Array.from(indices);\n    component.aabb = aabb;\n    component.vertexCount = positions.length / 3;\n    component.attributes = [\n      {\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    ];\n\n    // TODO: barycentric & tangent\n  }\n}\n"]},"metadata":{},"sourceType":"module"}