{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport Global from '../global';\nimport { applyMatrix } from './math';\nimport letterAspectRatio from './letterAspectRatio';\nimport { isString, clone, isNumber, isObject } from '@antv/util';\nvar PI = Math.PI,\n    sin = Math.sin,\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\n\nvar SELF_LINK_SIN = sin(PI / 8);\nvar SELF_LINK_COS = cos(PI / 8);\nexport var getBBox = function getBBox(element, group) {\n  var bbox = element.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }; // 根据父元素变换矩阵\n\n  if (group) {\n    var matrix = group.getMatrix();\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    leftTop = applyMatrix(leftTop, matrix);\n    rightBottom = applyMatrix(rightBottom, matrix);\n  }\n\n  var lx = leftTop.x,\n      ly = leftTop.y;\n  var rx = rightBottom.x,\n      ry = rightBottom.y;\n  return {\n    x: lx,\n    y: ly,\n    minX: lx,\n    minY: ly,\n    maxX: rx,\n    maxY: ry,\n    width: rx - lx,\n    height: ry - ly\n  };\n};\n/**\n * get loop edge config\n * @param cfg edge config\n */\n\nexport var getLoopCfgs = function getLoopCfgs(cfg) {\n  var item = cfg.sourceNode || cfg.targetNode;\n  var container = item.get('group');\n  var containerMatrix = container.getMatrix();\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var keyShape = item.getKeyShape();\n  var bbox = keyShape.getBBox();\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\n\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\n\n  var position = loopCfg.position || Global.defaultLoopPosition; // 中心取group上真实位置\n\n  var center = [containerMatrix[6], containerMatrix[7]];\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\n  var rstart = bbox.height / 2;\n  var rend = bbox.height / 2;\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\n  var cosDeltaStart = rstart * SELF_LINK_COS;\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\n\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\n    switch (position) {\n      case 'top':\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      case 'top-right':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'right':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'bottom-right':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom':\n        rstart = bbox.height / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom-left':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'left':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'top-left':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      default:\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n    } // 如果逆时针画，交换起点和终点\n\n\n    if (loopCfg.clockwise === false) {\n      var swap = [startPoint[0], startPoint[1]];\n      startPoint = [endPoint[0], endPoint[1]];\n      endPoint = [swap[0], swap[1]];\n    }\n  }\n\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\n  var scaleRateStart = (rstart + dist) / rstart;\n  var scaleRateEnd = (rend + dist) / rend;\n\n  if (loopCfg.clockwise === false) {\n    scaleRateStart = (rend + dist) / rend;\n    scaleRateEnd = (rstart + dist) / rstart;\n  }\n\n  var startExtendVec = vec2.scale([0, 0], startVec, scaleRateStart);\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\n  var endExtendVec = vec2.scale([0, 0], endVec, scaleRateEnd);\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\n  cfg.startPoint = {\n    x: startPoint[0],\n    y: startPoint[1]\n  };\n  cfg.endPoint = {\n    x: endPoint[0],\n    y: endPoint[1]\n  };\n  cfg.controlPoints = [{\n    x: controlPoint1[0],\n    y: controlPoint1[1]\n  }, {\n    x: controlPoint2[0],\n    y: controlPoint2[1]\n  }];\n  return cfg;\n};\n/**\n * 根据 label 所在线条的位置百分比，计算 label 坐标\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\n * @param {number}  percent    范围 0 - 1 的线条百分比\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\n * @param {boolean} rotate     是否根据线条斜率旋转文本\n * @return {object} 文本的 x, y, 文本的旋转角度\n */\n\nexport var getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\n  var TAN_OFFSET = 0.0001;\n  var vector = [];\n  var point = pathShape.getPoint(percent);\n\n  if (point === null) {\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\n\n\n  if (percent < TAN_OFFSET) {\n    vector = pathShape.getStartTangent().reverse();\n  } else if (percent > 1 - TAN_OFFSET) {\n    vector = pathShape.getEndTangent();\n  } else {\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\n    vector.push([point.x, point.y]);\n    vector.push([offsetPoint.x, offsetPoint.y]);\n  }\n\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\n\n  if (rad < 0) {\n    rad += PI * 2;\n  }\n\n  if (refX) {\n    point.x += cos(rad) * refX;\n    point.y += sin(rad) * refX;\n  }\n\n  if (refY) {\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\n\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      normal -= PI;\n    }\n\n    point.x += cos(normal) * refY;\n    point.y += sin(normal) * refY;\n  }\n\n  var result = {\n    x: point.x,\n    y: point.y,\n    angle: rad\n  };\n\n  if (rotate) {\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      rad -= PI;\n    }\n\n    return __assign({\n      rotate: rad\n    }, result);\n  }\n\n  return result;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverse = function traverse(data, fn) {\n  if (fn(data) === false) {\n    return false;\n  }\n\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverse(data.children[i], fn)) return false;\n    }\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (fn(data) === false) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nexport var traverseTree = function traverseTree(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverse(data, fn);\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\nexport var traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n/**\n *\n * @param letter the letter\n * @param fontSize\n * @return the letter's width\n */\n\nexport var getLetterWidth = function getLetterWidth(letter, fontSize) {\n  return fontSize * (letterAspectRatio[letter] || 1);\n};\n/**\n *\n * @param text the text\n * @param fontSize\n * @return the text's size\n */\n\nexport var getTextSize = function getTextSize(text, fontSize) {\n  var width = 0;\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\n  text.split('').forEach(function (letter) {\n    if (pattern.test(letter)) {\n      // 中文字符\n      width += fontSize;\n    } else {\n      width += getLetterWidth(letter, fontSize);\n    }\n  });\n  return [width, fontSize];\n};\n/**\n * construct the trees from combos data\n * @param array the combos array\n * @param nodes the nodes array\n * @return the tree\n */\n\nexport var plainCombosToTrees = function plainCombosToTrees(array, nodes) {\n  var result = [];\n  var addedMap = {};\n  var modelMap = {};\n  array.forEach(function (d) {\n    modelMap[d.id] = d;\n  });\n  array.forEach(function (d, i) {\n    var cd = clone(d);\n    cd.itemType = 'combo';\n    cd.children = undefined;\n\n    if (cd.parentId === cd.id) {\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\n      delete cd.parentId;\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\n      delete cd.parentId;\n    }\n\n    var mappedObj = addedMap[cd.id];\n\n    if (mappedObj) {\n      cd.children = mappedObj.children;\n      addedMap[cd.id] = cd;\n      mappedObj = cd;\n\n      if (!mappedObj.parentId) {\n        result.push(mappedObj);\n        return;\n      }\n\n      var mappedParent = addedMap[mappedObj.parentId];\n\n      if (mappedParent) {\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\n      } else {\n        var parent_1 = {\n          id: mappedObj.parentId,\n          children: [mappedObj]\n        };\n        addedMap[mappedObj.parentId] = parent_1;\n        addedMap[cd.id] = cd;\n      }\n\n      return;\n    }\n\n    if (isString(d.parentId)) {\n      var parent_2 = addedMap[d.parentId];\n\n      if (parent_2) {\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\n        addedMap[cd.id] = cd;\n      } else {\n        var pa = {\n          id: d.parentId,\n          children: [cd]\n        };\n        addedMap[pa.id] = pa;\n        addedMap[cd.id] = cd;\n      }\n    } else {\n      result.push(cd);\n      addedMap[cd.id] = cd;\n    }\n  }); // proccess the nodes\n\n  var nodeMap = {};\n  (nodes || []).forEach(function (node) {\n    nodeMap[node.id] = node;\n    var combo = addedMap[node.comboId];\n\n    if (combo) {\n      var cnode = {\n        id: node.id,\n        comboId: node.comboId\n      };\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\n      cnode.itemType = 'node';\n      addedMap[node.id] = cnode;\n    }\n  }); // assign the depth for each element\n\n  var maxDepth = 0;\n  result.forEach(function (tree) {\n    tree.depth = maxDepth + 10;\n    traverse(tree, function (child) {\n      var parent;\n      var itemType = addedMap[child.id].itemType;\n\n      if (itemType === 'node') {\n        parent = addedMap[child.comboId];\n      } else {\n        parent = addedMap[child.parentId];\n      }\n\n      if (parent) {\n        if (itemType === 'node') child.depth = maxDepth + 1;else child.depth = maxDepth + 10;\n      } else {\n        child.depth = maxDepth + 10;\n      }\n\n      if (maxDepth < child.depth) maxDepth = child.depth;\n      var oriNodeModel = nodeMap[child.id];\n\n      if (oriNodeModel) {\n        oriNodeModel.depth = child.depth;\n      }\n\n      return true;\n    });\n  });\n  return result;\n};\nexport var reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\n  var brothers = trees;\n  var subtree;\n  var comboChildsMap = {\n    root: {\n      children: trees\n    }\n  };\n  var foundSubTree = false;\n  var oldParentId = 'root';\n  (trees || []).forEach(function (tree) {\n    if (foundSubTree) return;\n\n    if (tree.id === subtreeId) {\n      subtree = tree;\n\n      if (tree.itemType === 'combo') {\n        subtree.parentId = newParentId;\n      } else {\n        subtree.comboId = newParentId;\n      }\n\n      foundSubTree = true;\n      return;\n    }\n\n    traverseTree(tree, function (child) {\n      comboChildsMap[child.id] = {\n        children: child.children\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\n\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\n\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\n        oldParentId = child.parentId || child.comboId || 'root';\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\n\n        if (child.itemType === 'combo') {\n          subtree.parentId = newParentId;\n        } else {\n          subtree.comboId = newParentId;\n        }\n\n        foundSubTree = true;\n        return false;\n      }\n\n      return true;\n    });\n  });\n  brothers = comboChildsMap[oldParentId].children;\n  var index = brothers ? brothers.indexOf(subtree) : -1;\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\n\n  if (!foundSubTree) {\n    subtree = {\n      id: subtreeId,\n      itemType: 'node',\n      comboId: newParentId\n    };\n    comboChildsMap[subtreeId] = {\n      children: undefined\n    };\n  } // append to new parent\n\n\n  if (subtreeId) {\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\n\n    if (newParentId) {\n      var newParentDepth_1 = 0;\n      (trees || []).forEach(function (tree) {\n        if (found_1) return; // terminate\n\n        traverseTree(tree, function (child) {\n          // append subtree to the new parent ans assign the depth to the subtree\n          if (newParentId === child.id) {\n            found_1 = true;\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\n            newParentDepth_1 = child.depth;\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\n            return false; // terminate\n          }\n\n          return true;\n        });\n      });\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\n      trees.push(subtree);\n    } // update the depth of the subtree and its children from the subtree\n\n\n    var currentDepth_1 = subtree.depth;\n    traverseTree(subtree, function (child) {\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\n      child.depth = currentDepth_1;\n      return true;\n    });\n  }\n\n  return trees;\n};\nexport var getComboBBox = function getComboBBox(children, graph) {\n  var comboBBox = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    x: undefined,\n    y: undefined,\n    width: undefined,\n    height: undefined,\n    centerX: undefined,\n    centerY: undefined\n  };\n\n  if (!children || children.length === 0) {\n    return comboBBox;\n  }\n\n  children.forEach(function (child) {\n    var childItem = graph.findById(child.id);\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\n\n    childItem.set('bboxCanvasCache', undefined);\n    var childBBox = childItem.getCanvasBBox();\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\n  });\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\n  Object.keys(comboBBox).forEach(function (key) {\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\n      comboBBox[key] = undefined;\n    }\n  });\n  return comboBBox;\n};\nexport var shouldRefreshEdge = function shouldRefreshEdge(cfg) {\n  var refreshEdge = isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;\n  if (cfg.style) refreshEdge = refreshEdge || isNumber(cfg.style.r) || isNumber(cfg.style.width) || isNumber(cfg.style.height) || isNumber(cfg.style.rx) || isNumber(cfg.style.ry);\n  return refreshEdge;\n};\nexport var cloneBesidesImg = function cloneBesidesImg(obj) {\n  var clonedObj = {};\n  Object.keys(obj).forEach(function (key1) {\n    var obj2 = obj[key1];\n\n    if (isObject(obj2)) {\n      var clonedObj2_1 = {};\n      Object.keys(obj2).forEach(function (key2) {\n        var v = obj2[key2];\n        if (key2 === 'img' && !isString(v)) return;\n        clonedObj2_1[key2] = clone(v);\n      });\n      clonedObj[key1] = clonedObj2_1;\n    } else {\n      clonedObj[key1] = clone(obj2);\n    }\n  });\n  return clonedObj;\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-core/es/util/graphic.js"],"names":["__assign","vec2","Global","applyMatrix","letterAspectRatio","isString","clone","isNumber","isObject","PI","Math","sin","cos","SELF_LINK_SIN","SELF_LINK_COS","getBBox","element","group","bbox","leftTop","x","minX","y","minY","rightBottom","maxX","maxY","matrix","getMatrix","lx","ly","rx","ry","width","height","getLoopCfgs","cfg","item","sourceNode","targetNode","container","get","containerMatrix","keyShape","getKeyShape","loopCfg","dist","max","position","defaultLoopPosition","center","startPoint","endPoint","rstart","rend","sinDeltaStart","cosDeltaStart","sinDeltaEnd","cosDeltaEnd","clockwise","swap","startVec","scaleRateStart","scaleRateEnd","startExtendVec","scale","controlPoint1","endVec","endExtendVec","controlPoint2","controlPoints","getLabelPosition","pathShape","percent","refX","refY","rotate","TAN_OFFSET","vector","point","getPoint","angle","getStartTangent","reverse","getEndTangent","offsetPoint","push","rad","atan2","normal","result","traverse","data","fn","children","i","length","traverseUp","traverseTree","traverseTreeUp","getLetterWidth","letter","fontSize","getTextSize","text","pattern","RegExp","split","forEach","test","plainCombosToTrees","array","nodes","addedMap","modelMap","d","id","cd","itemType","undefined","parentId","console","warn","mappedObj","mappedParent","parent_1","parent_2","pa","nodeMap","node","combo","comboId","cnode","maxDepth","tree","depth","child","parent","oriNodeModel","reconstructTree","trees","subtreeId","newParentId","brothers","subtree","comboChildsMap","root","foundSubTree","oldParentId","removed","index","indexOf","splice","found_1","newParentDepth_1","currentDepth_1","getComboBBox","graph","comboBBox","Infinity","centerX","centerY","childItem","findById","isVisible","set","childBBox","getCanvasBBox","Object","keys","key","shouldRefreshEdge","refreshEdge","type","anchorPoints","size","style","r","cloneBesidesImg","obj","clonedObj","key1","obj2","clonedObj2_1","key2","v"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport Global from '../global';\nimport { applyMatrix } from './math';\nimport letterAspectRatio from './letterAspectRatio';\nimport { isString, clone, isNumber, isObject } from '@antv/util';\nvar PI = Math.PI,\n    sin = Math.sin,\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\n\nvar SELF_LINK_SIN = sin(PI / 8);\nvar SELF_LINK_COS = cos(PI / 8);\nexport var getBBox = function getBBox(element, group) {\n  var bbox = element.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }; // 根据父元素变换矩阵\n\n  if (group) {\n    var matrix = group.getMatrix();\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    leftTop = applyMatrix(leftTop, matrix);\n    rightBottom = applyMatrix(rightBottom, matrix);\n  }\n\n  var lx = leftTop.x,\n      ly = leftTop.y;\n  var rx = rightBottom.x,\n      ry = rightBottom.y;\n  return {\n    x: lx,\n    y: ly,\n    minX: lx,\n    minY: ly,\n    maxX: rx,\n    maxY: ry,\n    width: rx - lx,\n    height: ry - ly\n  };\n};\n/**\n * get loop edge config\n * @param cfg edge config\n */\n\nexport var getLoopCfgs = function getLoopCfgs(cfg) {\n  var item = cfg.sourceNode || cfg.targetNode;\n  var container = item.get('group');\n  var containerMatrix = container.getMatrix();\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var keyShape = item.getKeyShape();\n  var bbox = keyShape.getBBox();\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\n\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\n\n  var position = loopCfg.position || Global.defaultLoopPosition; // 中心取group上真实位置\n\n  var center = [containerMatrix[6], containerMatrix[7]];\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\n  var rstart = bbox.height / 2;\n  var rend = bbox.height / 2;\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\n  var cosDeltaStart = rstart * SELF_LINK_COS;\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\n\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\n    switch (position) {\n      case 'top':\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      case 'top-right':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'right':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'bottom-right':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom':\n        rstart = bbox.height / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom-left':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'left':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'top-left':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      default:\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n    } // 如果逆时针画，交换起点和终点\n\n\n    if (loopCfg.clockwise === false) {\n      var swap = [startPoint[0], startPoint[1]];\n      startPoint = [endPoint[0], endPoint[1]];\n      endPoint = [swap[0], swap[1]];\n    }\n  }\n\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\n  var scaleRateStart = (rstart + dist) / rstart;\n  var scaleRateEnd = (rend + dist) / rend;\n\n  if (loopCfg.clockwise === false) {\n    scaleRateStart = (rend + dist) / rend;\n    scaleRateEnd = (rstart + dist) / rstart;\n  }\n\n  var startExtendVec = vec2.scale([0, 0], startVec, scaleRateStart);\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\n  var endExtendVec = vec2.scale([0, 0], endVec, scaleRateEnd);\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\n  cfg.startPoint = {\n    x: startPoint[0],\n    y: startPoint[1]\n  };\n  cfg.endPoint = {\n    x: endPoint[0],\n    y: endPoint[1]\n  };\n  cfg.controlPoints = [{\n    x: controlPoint1[0],\n    y: controlPoint1[1]\n  }, {\n    x: controlPoint2[0],\n    y: controlPoint2[1]\n  }];\n  return cfg;\n};\n/**\n * 根据 label 所在线条的位置百分比，计算 label 坐标\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\n * @param {number}  percent    范围 0 - 1 的线条百分比\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\n * @param {boolean} rotate     是否根据线条斜率旋转文本\n * @return {object} 文本的 x, y, 文本的旋转角度\n */\n\nexport var getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\n  var TAN_OFFSET = 0.0001;\n  var vector = [];\n  var point = pathShape.getPoint(percent);\n\n  if (point === null) {\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\n\n\n  if (percent < TAN_OFFSET) {\n    vector = pathShape.getStartTangent().reverse();\n  } else if (percent > 1 - TAN_OFFSET) {\n    vector = pathShape.getEndTangent();\n  } else {\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\n    vector.push([point.x, point.y]);\n    vector.push([offsetPoint.x, offsetPoint.y]);\n  }\n\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\n\n  if (rad < 0) {\n    rad += PI * 2;\n  }\n\n  if (refX) {\n    point.x += cos(rad) * refX;\n    point.y += sin(rad) * refX;\n  }\n\n  if (refY) {\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\n\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      normal -= PI;\n    }\n\n    point.x += cos(normal) * refY;\n    point.y += sin(normal) * refY;\n  }\n\n  var result = {\n    x: point.x,\n    y: point.y,\n    angle: rad\n  };\n\n  if (rotate) {\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      rad -= PI;\n    }\n\n    return __assign({\n      rotate: rad\n    }, result);\n  }\n\n  return result;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverse = function traverse(data, fn) {\n  if (fn(data) === false) {\n    return false;\n  }\n\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverse(data.children[i], fn)) return false;\n    }\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (fn(data) === false) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nexport var traverseTree = function traverseTree(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverse(data, fn);\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\nexport var traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n/**\n *\n * @param letter the letter\n * @param fontSize\n * @return the letter's width\n */\n\nexport var getLetterWidth = function getLetterWidth(letter, fontSize) {\n  return fontSize * (letterAspectRatio[letter] || 1);\n};\n/**\n *\n * @param text the text\n * @param fontSize\n * @return the text's size\n */\n\nexport var getTextSize = function getTextSize(text, fontSize) {\n  var width = 0;\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\n  text.split('').forEach(function (letter) {\n    if (pattern.test(letter)) {\n      // 中文字符\n      width += fontSize;\n    } else {\n      width += getLetterWidth(letter, fontSize);\n    }\n  });\n  return [width, fontSize];\n};\n/**\n * construct the trees from combos data\n * @param array the combos array\n * @param nodes the nodes array\n * @return the tree\n */\n\nexport var plainCombosToTrees = function plainCombosToTrees(array, nodes) {\n  var result = [];\n  var addedMap = {};\n  var modelMap = {};\n  array.forEach(function (d) {\n    modelMap[d.id] = d;\n  });\n  array.forEach(function (d, i) {\n    var cd = clone(d);\n    cd.itemType = 'combo';\n    cd.children = undefined;\n\n    if (cd.parentId === cd.id) {\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\n      delete cd.parentId;\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\n      delete cd.parentId;\n    }\n\n    var mappedObj = addedMap[cd.id];\n\n    if (mappedObj) {\n      cd.children = mappedObj.children;\n      addedMap[cd.id] = cd;\n      mappedObj = cd;\n\n      if (!mappedObj.parentId) {\n        result.push(mappedObj);\n        return;\n      }\n\n      var mappedParent = addedMap[mappedObj.parentId];\n\n      if (mappedParent) {\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\n      } else {\n        var parent_1 = {\n          id: mappedObj.parentId,\n          children: [mappedObj]\n        };\n        addedMap[mappedObj.parentId] = parent_1;\n        addedMap[cd.id] = cd;\n      }\n\n      return;\n    }\n\n    if (isString(d.parentId)) {\n      var parent_2 = addedMap[d.parentId];\n\n      if (parent_2) {\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\n        addedMap[cd.id] = cd;\n      } else {\n        var pa = {\n          id: d.parentId,\n          children: [cd]\n        };\n        addedMap[pa.id] = pa;\n        addedMap[cd.id] = cd;\n      }\n    } else {\n      result.push(cd);\n      addedMap[cd.id] = cd;\n    }\n  }); // proccess the nodes\n\n  var nodeMap = {};\n  (nodes || []).forEach(function (node) {\n    nodeMap[node.id] = node;\n    var combo = addedMap[node.comboId];\n\n    if (combo) {\n      var cnode = {\n        id: node.id,\n        comboId: node.comboId\n      };\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\n      cnode.itemType = 'node';\n      addedMap[node.id] = cnode;\n    }\n  }); // assign the depth for each element\n\n  var maxDepth = 0;\n  result.forEach(function (tree) {\n    tree.depth = maxDepth + 10;\n    traverse(tree, function (child) {\n      var parent;\n      var itemType = addedMap[child.id].itemType;\n\n      if (itemType === 'node') {\n        parent = addedMap[child.comboId];\n      } else {\n        parent = addedMap[child.parentId];\n      }\n\n      if (parent) {\n        if (itemType === 'node') child.depth = maxDepth + 1;else child.depth = maxDepth + 10;\n      } else {\n        child.depth = maxDepth + 10;\n      }\n\n      if (maxDepth < child.depth) maxDepth = child.depth;\n      var oriNodeModel = nodeMap[child.id];\n\n      if (oriNodeModel) {\n        oriNodeModel.depth = child.depth;\n      }\n\n      return true;\n    });\n  });\n  return result;\n};\nexport var reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\n  var brothers = trees;\n  var subtree;\n  var comboChildsMap = {\n    root: {\n      children: trees\n    }\n  };\n  var foundSubTree = false;\n  var oldParentId = 'root';\n  (trees || []).forEach(function (tree) {\n    if (foundSubTree) return;\n\n    if (tree.id === subtreeId) {\n      subtree = tree;\n\n      if (tree.itemType === 'combo') {\n        subtree.parentId = newParentId;\n      } else {\n        subtree.comboId = newParentId;\n      }\n\n      foundSubTree = true;\n      return;\n    }\n\n    traverseTree(tree, function (child) {\n      comboChildsMap[child.id] = {\n        children: child.children\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\n\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\n\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\n        oldParentId = child.parentId || child.comboId || 'root';\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\n\n        if (child.itemType === 'combo') {\n          subtree.parentId = newParentId;\n        } else {\n          subtree.comboId = newParentId;\n        }\n\n        foundSubTree = true;\n        return false;\n      }\n\n      return true;\n    });\n  });\n  brothers = comboChildsMap[oldParentId].children;\n  var index = brothers ? brothers.indexOf(subtree) : -1;\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\n\n  if (!foundSubTree) {\n    subtree = {\n      id: subtreeId,\n      itemType: 'node',\n      comboId: newParentId\n    };\n    comboChildsMap[subtreeId] = {\n      children: undefined\n    };\n  } // append to new parent\n\n\n  if (subtreeId) {\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\n\n    if (newParentId) {\n      var newParentDepth_1 = 0;\n      (trees || []).forEach(function (tree) {\n        if (found_1) return; // terminate\n\n        traverseTree(tree, function (child) {\n          // append subtree to the new parent ans assign the depth to the subtree\n          if (newParentId === child.id) {\n            found_1 = true;\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\n            newParentDepth_1 = child.depth;\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\n            return false; // terminate\n          }\n\n          return true;\n        });\n      });\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\n      trees.push(subtree);\n    } // update the depth of the subtree and its children from the subtree\n\n\n    var currentDepth_1 = subtree.depth;\n    traverseTree(subtree, function (child) {\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\n      child.depth = currentDepth_1;\n      return true;\n    });\n  }\n\n  return trees;\n};\nexport var getComboBBox = function getComboBBox(children, graph) {\n  var comboBBox = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    x: undefined,\n    y: undefined,\n    width: undefined,\n    height: undefined,\n    centerX: undefined,\n    centerY: undefined\n  };\n\n  if (!children || children.length === 0) {\n    return comboBBox;\n  }\n\n  children.forEach(function (child) {\n    var childItem = graph.findById(child.id);\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\n\n    childItem.set('bboxCanvasCache', undefined);\n    var childBBox = childItem.getCanvasBBox();\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\n  });\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\n  Object.keys(comboBBox).forEach(function (key) {\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\n      comboBBox[key] = undefined;\n    }\n  });\n  return comboBBox;\n};\nexport var shouldRefreshEdge = function shouldRefreshEdge(cfg) {\n  var refreshEdge = isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;\n  if (cfg.style) refreshEdge = refreshEdge || isNumber(cfg.style.r) || isNumber(cfg.style.width) || isNumber(cfg.style.height) || isNumber(cfg.style.rx) || isNumber(cfg.style.ry);\n  return refreshEdge;\n};\nexport var cloneBesidesImg = function cloneBesidesImg(obj) {\n  var clonedObj = {};\n  Object.keys(obj).forEach(function (key1) {\n    var obj2 = obj[key1];\n\n    if (isObject(obj2)) {\n      var clonedObj2_1 = {};\n      Object.keys(obj2).forEach(function (key2) {\n        var v = obj2[key2];\n        if (key2 === 'img' && !isString(v)) return;\n        clonedObj2_1[key2] = clone(v);\n      });\n      clonedObj[key1] = clonedObj2_1;\n    } else {\n      clonedObj[key1] = clone(obj2);\n    }\n  });\n  return clonedObj;\n};"]},"metadata":{},"sourceType":"module"}