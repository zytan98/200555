{"ast":null,"code":"// @ts-nocheck\n\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\"; // @ts-ignore\n\nimport { World } from \"@antv/g-webgpu\";\nimport { proccessToFunc, buildTextureDataWithTwoEdgeAttr, arrayToTextureData } from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * graphin 中的 force 布局\n */\n\nexport class GForceGPULayout extends Base {\n  constructor(options) {\n    super();\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 1000;\n    /** 弹簧引力系数 */\n\n    this.edgeStrength = 200;\n    /** 斥力系数 */\n\n    this.nodeStrength = 1000;\n    /** 库伦系数 */\n\n    this.coulombDisScale = 0.005;\n    /** 阻尼系数 */\n\n    this.damping = 0.9;\n    /** 最大速度 */\n\n    this.maxSpeed = 1000;\n    /** 一次迭代的平均移动距离小于该值时停止迭代 */\n\n    this.minMovement = 0.5;\n    /** 迭代中衰减 */\n\n    this.interval = 0.02;\n    /** 斥力的一个系数 */\n\n    this.factor = 1;\n    /** 理想边长 */\n\n    this.linkDistance = 1;\n    /** 重力大小 */\n\n    this.gravity = 10;\n    /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n\n    this.workerEnabled = false;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.nodeMap = {};\n    this.nodeIdxMap = {};\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 2000,\n      gravity: 10,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n\n      if (!nodes || nodes.length === 0) {\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      if (!self.center) {\n        self.center = [self.width / 2, self.height / 2];\n      }\n\n      const center = self.center;\n\n      if (nodes.length === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        if (self.onLayoutEnd) self.onLayoutEnd();\n        return;\n      }\n\n      const nodeMap = {};\n      const nodeIdxMap = {};\n      nodes.forEach((node, i) => {\n        if (!isNumber(node.x)) node.x = Math.random() * self.width;\n        if (!isNumber(node.y)) node.y = Math.random() * self.height;\n        nodeMap[node.id] = node;\n        nodeIdxMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      self.nodeIdxMap = nodeIdxMap;\n      self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n      self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n      yield self.run();\n    });\n  }\n\n  executeWithWorker(canvas, ctx) {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    const nodeMap = {};\n    const nodeIdxMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * self.width;\n      if (!isNumber(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1); // layout\n\n    self.run(canvas, ctx);\n  }\n\n  run(canvas, ctx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this;\n      const nodes = self.nodes;\n      const edges = self.edges;\n      const maxIteration = self.maxIteration;\n\n      if (!self.width && typeof window !== \"undefined\") {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== \"undefined\") {\n        self.height = window.innerHeight;\n      }\n\n      const numParticles = nodes.length;\n      self.linkDistance = proccessToFunc(self.linkDistance);\n      self.edgeStrength = proccessToFunc(self.edgeStrength);\n      const {\n        maxEdgePerVetex,\n        array: nodesEdgesArray\n      } = buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength); // init degree for mass\n\n      self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n      const masses = [];\n      const nodeStrengths = [];\n      const centerXs = [];\n      const centerYs = [];\n      const centerGravities = [];\n      const fxs = [];\n      const fys = [];\n\n      if (!self.getMass) {\n        self.getMass = d => {\n          return self.degrees[self.nodeIdxMap[d.id]] || 1;\n        };\n      }\n\n      const gravity = self.gravity;\n      const center = self.center;\n      nodes.forEach((node, i) => {\n        masses.push(self.getMass(node));\n        nodeStrengths.push(self.nodeStrength(node));\n        if (!self.degrees[i]) self.degrees[i] = 0;\n        let nodeGravity = [center[0], center[1], gravity];\n\n        if (self.getCenter) {\n          const customCenter = self.getCenter(node, self.degrees[i]);\n\n          if (customCenter && isNumber(customCenter[0]) && isNumber(customCenter[1]) && isNumber(customCenter[2])) {\n            nodeGravity = customCenter;\n          }\n        }\n\n        centerXs.push(nodeGravity[0]);\n        centerYs.push(nodeGravity[1]);\n        centerGravities.push(nodeGravity[2]);\n\n        if (isNumber(node.fx) && isNumber(node.fy)) {\n          fxs.push(node.fx || 0.001);\n          fys.push(node.fy || 0.001);\n        } else {\n          fxs.push(0);\n          fys.push(0);\n        }\n      }); // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n\n      const nodeAttributeArray1 = arrayToTextureData([masses, self.degrees, nodeStrengths, fxs]); // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n\n      const nodeAttributeArray2 = arrayToTextureData([centerXs, centerYs, centerGravities, fys]);\n      const workerEnabled = self.workerEnabled;\n      let world;\n\n      if (workerEnabled) {\n        world = World.create({\n          canvas,\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } else {\n        world = World.create({\n          engineOptions: {\n            supportCompute: true\n          }\n        });\n      } // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n      // const compiler = new Compiler();\n      // const gForceBundle = compiler.compileBundle(gForceCode);\n      // console.log(gForceBundle.toString());\n\n\n      const onLayoutEnd = self.onLayoutEnd;\n      const initPreviousData = [];\n      nodesEdgesArray.forEach(value => {\n        initPreviousData.push(value);\n      });\n\n      for (let i = 0; i < 4; i++) {\n        initPreviousData.push(0);\n      }\n\n      const kernelGForce = world.createKernel(gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        u_damping: self.damping,\n        u_maxSpeed: self.maxSpeed,\n        u_minMovement: self.minMovement,\n        u_coulombDisScale: self.coulombDisScale,\n        u_factor: self.factor,\n        u_NodeAttributeArray1: nodeAttributeArray1,\n        u_NodeAttributeArray2: nodeAttributeArray2,\n        MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: initPreviousData,\n        u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n\n      }); // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n      // console.log(aveMovementBundle.toString());\n\n      const kernelAveMovement = world.createKernel(aveMovementBundle).setDispatch([1, 1, 1]).setBinding({\n        u_Data: nodesEdgesArray,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: [0, 0, 0, 0]\n      }); // 执行迭代\n      // let midRes = nodesEdgesArray;\n\n      const execute = () => __awaiter(this, void 0, void 0, function* () {\n        for (let i = 0; i < maxIteration; i++) {\n          // TODO: 似乎都来自 kernelGForce 是一个引用\n          // 当前坐标作为下一次迭代的 PreviousData\n          // if (i > 0) {\n          //   kernelAveMovement.setBinding({\n          //     u_PreviousData: kernelGForce\n          //   });\n          // }\n          // eslint-disable-next-line no-await-in-loop\n          yield kernelGForce.execute(); // midRes = await kernelGForce.getOutput();\n          // 每次迭代完成后\n          // 计算平均位移，用于提前终止迭代\n\n          kernelAveMovement.setBinding({\n            u_Data: kernelGForce\n          }); // eslint-disable-next-line no-await-in-loop\n\n          yield kernelAveMovement.execute(); // 更新衰减函数\n\n          const stepInterval = Math.max(0.02, self.interval - i * 0.002);\n          kernelGForce.setBinding({\n            u_interval: stepInterval,\n            u_AveMovement: kernelAveMovement\n          });\n        }\n\n        const finalParticleData = yield kernelGForce.getOutput(); // 所有迭代完成后\n\n        if (canvas) {\n          // 传递数据给主线程\n          ctx.postMessage({\n            type: LAYOUT_MESSAGE.GPUEND,\n            vertexEdgeData: finalParticleData // edgeIndexBufferData,\n\n          });\n        } else {\n          nodes.forEach((node, i) => {\n            const x = finalParticleData[4 * i];\n            const y = finalParticleData[4 * i + 1];\n            node.x = x;\n            node.y = y;\n          });\n        }\n\n        if (onLayoutEnd) onLayoutEnd();\n      });\n\n      yield execute();\n    });\n  }\n\n  getType() {\n    return \"gForce-gpu\";\n  }\n\n}","map":{"version":3,"sources":["../../../src/layout/gpu/gForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\";\n// @ts-ignore\nimport { World } from \"@antv/g-webgpu\";\nimport { proccessToFunc, buildTextureDataWithTwoEdgeAttr, arrayToTextureData } from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n/**\n * graphin 中的 force 布局\n */\nexport class GForceGPULayout extends Base {\n    constructor(options) {\n        super();\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        this.edgeStrength = 200;\n        /** 斥力系数 */\n        this.nodeStrength = 1000;\n        /** 库伦系数 */\n        this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        this.damping = 0.9;\n        /** 最大速度 */\n        this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        this.interval = 0.02;\n        /** 斥力的一个系数 */\n        this.factor = 1;\n        /** 理想边长 */\n        this.linkDistance = 1;\n        /** 重力大小 */\n        this.gravity = 10;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        this.workerEnabled = false;\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        this.nodeMap = {};\n        this.nodeIdxMap = {};\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 2000,\n            gravity: 10,\n            clustering: false,\n            clusterGravity: 10\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            const nodes = self.nodes;\n            if (!nodes || nodes.length === 0) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                return;\n            }\n            if (!self.width && typeof window !== \"undefined\") {\n                self.width = window.innerWidth;\n            }\n            if (!self.height && typeof window !== \"undefined\") {\n                self.height = window.innerHeight;\n            }\n            if (!self.center) {\n                self.center = [self.width / 2, self.height / 2];\n            }\n            const center = self.center;\n            if (nodes.length === 1) {\n                nodes[0].x = center[0];\n                nodes[0].y = center[1];\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                return;\n            }\n            const nodeMap = {};\n            const nodeIdxMap = {};\n            nodes.forEach((node, i) => {\n                if (!isNumber(node.x))\n                    node.x = Math.random() * self.width;\n                if (!isNumber(node.y))\n                    node.y = Math.random() * self.height;\n                nodeMap[node.id] = node;\n                nodeIdxMap[node.id] = i;\n            });\n            self.nodeMap = nodeMap;\n            self.nodeIdxMap = nodeIdxMap;\n            self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n            self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n            // layout\n            yield self.run();\n        });\n    }\n    executeWithWorker(canvas, ctx) {\n        const self = this;\n        const nodes = self.nodes;\n        const center = self.center;\n        if (!nodes || nodes.length === 0) {\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            return;\n        }\n        const nodeMap = {};\n        const nodeIdxMap = {};\n        nodes.forEach((node, i) => {\n            if (!isNumber(node.x))\n                node.x = Math.random() * self.width;\n            if (!isNumber(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n        // layout\n        self.run(canvas, ctx);\n    }\n    run(canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            const nodes = self.nodes;\n            const edges = self.edges;\n            const maxIteration = self.maxIteration;\n            if (!self.width && typeof window !== \"undefined\") {\n                self.width = window.innerWidth;\n            }\n            if (!self.height && typeof window !== \"undefined\") {\n                self.height = window.innerHeight;\n            }\n            const numParticles = nodes.length;\n            self.linkDistance = proccessToFunc(self.linkDistance);\n            self.edgeStrength = proccessToFunc(self.edgeStrength);\n            const { maxEdgePerVetex, array: nodesEdgesArray } = buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength);\n            // init degree for mass\n            self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges);\n            const masses = [];\n            const nodeStrengths = [];\n            const centerXs = [];\n            const centerYs = [];\n            const centerGravities = [];\n            const fxs = [];\n            const fys = [];\n            if (!self.getMass) {\n                self.getMass = (d) => {\n                    return self.degrees[self.nodeIdxMap[d.id]] || 1;\n                };\n            }\n            const gravity = self.gravity;\n            const center = self.center;\n            nodes.forEach((node, i) => {\n                masses.push(self.getMass(node));\n                nodeStrengths.push(self.nodeStrength(node));\n                if (!self.degrees[i])\n                    self.degrees[i] = 0;\n                let nodeGravity = [center[0], center[1], gravity];\n                if (self.getCenter) {\n                    const customCenter = self.getCenter(node, self.degrees[i]);\n                    if (customCenter &&\n                        isNumber(customCenter[0]) &&\n                        isNumber(customCenter[1]) &&\n                        isNumber(customCenter[2])) {\n                        nodeGravity = customCenter;\n                    }\n                }\n                centerXs.push(nodeGravity[0]);\n                centerYs.push(nodeGravity[1]);\n                centerGravities.push(nodeGravity[2]);\n                if (isNumber(node.fx) && isNumber(node.fy)) {\n                    fxs.push(node.fx || 0.001);\n                    fys.push(node.fy || 0.001);\n                }\n                else {\n                    fxs.push(0);\n                    fys.push(0);\n                }\n            });\n            // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n            const nodeAttributeArray1 = arrayToTextureData([\n                masses,\n                self.degrees,\n                nodeStrengths,\n                fxs\n            ]);\n            // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n            const nodeAttributeArray2 = arrayToTextureData([\n                centerXs,\n                centerYs,\n                centerGravities,\n                fys\n            ]);\n            const workerEnabled = self.workerEnabled;\n            let world;\n            if (workerEnabled) {\n                world = World.create({\n                    canvas,\n                    engineOptions: {\n                        supportCompute: true\n                    }\n                });\n            }\n            else {\n                world = World.create({\n                    engineOptions: {\n                        supportCompute: true\n                    }\n                });\n            }\n            // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n            // const compiler = new Compiler();\n            // const gForceBundle = compiler.compileBundle(gForceCode);\n            // console.log(gForceBundle.toString());\n            const onLayoutEnd = self.onLayoutEnd;\n            const initPreviousData = [];\n            nodesEdgesArray.forEach((value) => {\n                initPreviousData.push(value);\n            });\n            for (let i = 0; i < 4; i++) {\n                initPreviousData.push(0);\n            }\n            const kernelGForce = world\n                .createKernel(gForceBundle)\n                .setDispatch([numParticles, 1, 1])\n                .setBinding({\n                u_Data: nodesEdgesArray,\n                u_damping: self.damping,\n                u_maxSpeed: self.maxSpeed,\n                u_minMovement: self.minMovement,\n                u_coulombDisScale: self.coulombDisScale,\n                u_factor: self.factor,\n                u_NodeAttributeArray1: nodeAttributeArray1,\n                u_NodeAttributeArray2: nodeAttributeArray2,\n                MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                VERTEX_COUNT: numParticles,\n                u_AveMovement: initPreviousData,\n                u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n            });\n            // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n            // console.log(aveMovementBundle.toString());\n            const kernelAveMovement = world\n                .createKernel(aveMovementBundle)\n                .setDispatch([1, 1, 1])\n                .setBinding({\n                u_Data: nodesEdgesArray,\n                VERTEX_COUNT: numParticles,\n                u_AveMovement: [0, 0, 0, 0]\n            });\n            // 执行迭代\n            // let midRes = nodesEdgesArray;\n            const execute = () => __awaiter(this, void 0, void 0, function* () {\n                for (let i = 0; i < maxIteration; i++) {\n                    // TODO: 似乎都来自 kernelGForce 是一个引用\n                    // 当前坐标作为下一次迭代的 PreviousData\n                    // if (i > 0) {\n                    //   kernelAveMovement.setBinding({\n                    //     u_PreviousData: kernelGForce\n                    //   });\n                    // }\n                    // eslint-disable-next-line no-await-in-loop\n                    yield kernelGForce.execute();\n                    // midRes = await kernelGForce.getOutput();\n                    // 每次迭代完成后\n                    // 计算平均位移，用于提前终止迭代\n                    kernelAveMovement.setBinding({\n                        u_Data: kernelGForce\n                    });\n                    // eslint-disable-next-line no-await-in-loop\n                    yield kernelAveMovement.execute();\n                    // 更新衰减函数\n                    const stepInterval = Math.max(0.02, self.interval - i * 0.002);\n                    kernelGForce.setBinding({\n                        u_interval: stepInterval,\n                        u_AveMovement: kernelAveMovement\n                    });\n                }\n                const finalParticleData = yield kernelGForce.getOutput();\n                // 所有迭代完成后\n                if (canvas) {\n                    // 传递数据给主线程\n                    ctx.postMessage({\n                        type: LAYOUT_MESSAGE.GPUEND,\n                        vertexEdgeData: finalParticleData\n                        // edgeIndexBufferData,\n                    });\n                }\n                else {\n                    nodes.forEach((node, i) => {\n                        const x = finalParticleData[4 * i];\n                        const y = finalParticleData[4 * i + 1];\n                        node.x = x;\n                        node.y = y;\n                    });\n                }\n                if (onLayoutEnd)\n                    onLayoutEnd();\n            });\n            yield execute();\n        });\n    }\n    getType() {\n        return \"gForce-gpu\";\n    }\n}\n//# sourceMappingURL=gForce.js.map"]},"metadata":{},"sourceType":"module"}