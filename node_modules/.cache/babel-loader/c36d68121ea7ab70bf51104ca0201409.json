{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { vec3 } from 'gl-matrix';\nexport var Plane = /*#__PURE__*/function () {\n  /**\n   * lookup table for p-vertex & n-vertex when doing frustum culling\n   */\n  function Plane(distance, normal) {\n    _classCallCheck(this, Plane);\n\n    this.distance = void 0;\n    this.normal = void 0;\n    this.pnVertexFlag = void 0;\n    this.distance = distance || 0;\n    this.normal = normal || vec3.fromValues(0, 1, 0);\n    this.updatePNVertexFlag();\n  }\n\n  _createClass(Plane, [{\n    key: \"updatePNVertexFlag\",\n    value: function updatePNVertexFlag() {\n      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return vec3.dot(point, this.normal) - this.distance;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var invLen = 1 / vec3.len(this.normal);\n      vec3.scale(this.normal, this.normal, invLen);\n      this.distance *= invLen;\n    }\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(start, end, point) {\n      var d0 = this.distanceToPoint(start);\n      var d1 = this.distanceToPoint(end);\n      var t = d0 / (d0 - d1);\n      var intersects = t >= 0 && t <= 1;\n\n      if (intersects && point) {\n        vec3.lerp(point, start, end, t);\n      }\n\n      return intersects;\n    }\n  }]);\n\n  return Plane;\n}();","map":{"version":3,"sources":["../../src/shape/Plane.ts"],"names":["Plane","distance","normal","pnVertexFlag","vec3","Number","invLen","d0","d1","t","intersects"],"mappings":";;AAAA,SAAA,IAAA,QAAA,WAAA;AAEA,OAAA,IAAaA,KAAb,GAAA,aAAA,YAAA;AAIE;AACF;AACA;AAGE,WAAA,KAAA,CAAA,QAAA,EAAA,MAAA,EAA8C;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;AAAA,SARvCC,QAQuC,GAAA,KAAA,CAAA;AAAA,SAPvCC,MAOuC,GAAA,KAAA,CAAA;AAAA,SAFvCC,YAEuC,GAAA,KAAA,CAAA;AAC5C,SAAA,QAAA,GAAgBF,QAAQ,IAAxB,CAAA;AACA,SAAA,MAAA,GAAcC,MAAM,IAAIE,IAAI,CAAJA,UAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAxB,CAAwBA,CAAxB;AACA,SAAA,kBAAA;AACD;;AAbH,EAAA,YAAA,CAAA,KAAA,EAAA,CAAA;AAAA,IAAA,GAAA,EAAA,oBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,kBAAA,GAe8B;AAC1B,WAAA,YAAA,GACE,CAACC,MAAM,CAAC,KAAA,MAAA,CAAA,CAAA,KAAPA,CAAM,CAANA,IAAD,CAAA,KACCA,MAAM,CAAC,KAAA,MAAA,CAAA,CAAA,KAAPA,CAAM,CAANA,IADD,CAAA,IAEAA,MAAM,CAAC,KAAA,MAAA,CAAA,CAAA,KAHT,CAGQ,CAHR;AAID;AApBH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,iBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,eAAA,CAAA,KAAA,EAsBsC;AAClC,aAAOD,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,EAAgB,KAAhBA,MAAAA,IAA+B,KAAtC,QAAA;AACD;AAxBH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,WAAA;AAAA,IAAA,KAAA,EAAA,SAAA,SAAA,GA0BqB;AACjB,UAAME,MAAM,GAAG,IAAIF,IAAI,CAAJA,GAAAA,CAAS,KAA5B,MAAmBA,CAAnB;AACAA,MAAAA,IAAI,CAAJA,KAAAA,CAAW,KAAXA,MAAAA,EAAwB,KAAxBA,MAAAA,EAAAA,MAAAA;AACA,WAAA,QAAA,IAAA,MAAA;AACD;AA9BH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,gBAAA;AAAA,IAAA,KAAA,EAAA,SAAA,cAAA,CAAA,KAAA,EAAA,GAAA,EAAA,KAAA,EAgC8D;AAC1D,UAAMG,EAAE,GAAG,KAAA,eAAA,CAAX,KAAW,CAAX;AACA,UAAMC,EAAE,GAAG,KAAA,eAAA,CAAX,GAAW,CAAX;AACA,UAAMC,CAAC,GAAGF,EAAE,IAAIA,EAAE,GAAlB,EAAY,CAAZ;AACA,UAAMG,UAAU,GAAGD,CAAC,IAADA,CAAAA,IAAUA,CAAC,IAA9B,CAAA;;AACA,UAAIC,UAAU,IAAd,KAAA,EAAyB;AACvBN,QAAAA,IAAI,CAAJA,IAAAA,CAAAA,KAAAA,EAAAA,KAAAA,EAAAA,GAAAA,EAAAA,CAAAA;AACD;;AACD,aAAA,UAAA;AACD;AAzCH,GAAA,CAAA,CAAA;;AAAA,SAAA,KAAA;AAAA,CAAA,EAAA","sourcesContent":["import { vec3 } from 'gl-matrix';\n\nexport class Plane {\n  public distance: number;\n  public normal: vec3;\n\n  /**\n   * lookup table for p-vertex & n-vertex when doing frustum culling\n   */\n  public pnVertexFlag: number;\n\n  constructor(distance?: number, normal?: vec3) {\n    this.distance = distance || 0;\n    this.normal = normal || vec3.fromValues(0, 1, 0);\n    this.updatePNVertexFlag();\n  }\n\n  public updatePNVertexFlag() {\n    this.pnVertexFlag =\n      (Number(this.normal[0] >= 0) << 8) +\n      (Number(this.normal[1] >= 0) << 4) +\n      Number(this.normal[2] >= 0);\n  }\n\n  public distanceToPoint(point: vec3) {\n    return vec3.dot(point, this.normal) - this.distance;\n  }\n\n  public normalize() {\n    const invLen = 1 / vec3.len(this.normal);\n    vec3.scale(this.normal, this.normal, invLen);\n    this.distance *= invLen;\n  }\n\n  public intersectsLine(start: vec3, end: vec3, point?: vec3) {\n    const d0 = this.distanceToPoint(start);\n    const d1 = this.distanceToPoint(end);\n    const t = d0 / (d0 - d1);\n    const intersects = t >= 0 && t <= 1;\n    if (intersects && point) {\n      vec3.lerp(point, start, end, t);\n    }\n    return intersects;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}