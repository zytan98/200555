{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height) {\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: 5\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-plugin/es/timeBar/path.js"],"names":["__spreadArray","to","from","i","il","length","j","pathUtil","Category","Linear","map","each","isEqual","head","isArray","pointsToPath","points","p","idx","command","x","y","getLinePath","getSmoothLinePath","data","slice","push","path","catmullRom2Bezier","_a","unshift","dataToPath","width","height","smooth","values","v","scale","dataToRectPath","rectPoints","point","param","y0","size","rectPoint","getRectPoints","apply","getRectPath","getAreaLineY","lineY","Math","max","min","linePathToAreaPath","areaPath","lineYPx","pointInfo","yMin","yMax","xMin","xMax","isClosed","firstPoint","len"],"mappings":"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","sourcesContent":["var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height) {\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: 5\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}"]},"metadata":{},"sourceType":"module"}