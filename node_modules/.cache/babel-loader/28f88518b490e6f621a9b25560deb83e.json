{"ast":null,"code":"import getAdjMatrix from './adjacent-matrix';\n\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n\n  modularity *= 1 / param;\n  return modularity;\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\n\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {}; // the sum of the weights of all edges in the graph\n\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++; // pre compute some values for current clusters\n\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n            target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    }); // move the nodes to increase the delta modularity\n\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\n\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\n\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // the neightbors of the node\n\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\n\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\n\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\n\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        }); // modurarity for **adding** node i into this neighbor cluster\n\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // the increase modurarity is the difference between addModurarity and removeModurarity\n\n        var increase = addModurarity - removeModurarity; // find the best cluster to move node i into\n\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      }); // if found a best cluster to move into\n\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id; // move the node to the best cluster\n\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\n\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n              target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\n\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  } // delete the empty clusters, assign increasing clusterId\n\n\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n      return;\n    }\n\n    var newId = String(clusterIdx + 1);\n\n    if (newId === clusterId) {\n      return;\n    }\n\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    clusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete clusters[clusterId];\n    clusterIdx++;\n  });\n  nodes.forEach(function (node) {\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default louvain;","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/algorithm/es/louvain.js"],"names":["getAdjMatrix","getModularity","nodes","adjMatrix","ks","m","length","param","modularity","i","clusteri","clusterId","j","clusterj","entry","ki","kj","louvain","graphData","directed","weightPropertyName","threshold","_a","_b","edges","uniqueId","clusters","nodeMap","forEach","node","cid","String","id","idx","neighbors","row","k","iid","jid","push","totalModularity","Infinity","previousModularity","iter","Math","abs","Object","keys","sumTot","edge","source","target","sourceClusterId","targetClusterId","selfCluster","bestIncrease","bestCluster","commonParam","kiin","selfClusterNodes","scNode","scNodeIdx","removeModurarity","nodeNeighborIds","neighborNodeId","neighborNode","neighborClusterId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","addModurarity","increase","previousClusterId_1","nodeInSelfClusterIdx","indexOf","splice","neighborClusterSumTot_1","selfClusterSumTot_1","newClusterIdMap","clusterIdx","cluster","newId","map","item","clusterEdges","clusterEdgeMap","weight","newEdgeId","count","newEdge","clustersArray"],"mappings":"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","sourcesContent":["import getAdjMatrix from './adjacent-matrix';\n\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n\n  modularity *= 1 / param;\n  return modularity;\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\n\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {}; // the sum of the weights of all edges in the graph\n\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++; // pre compute some values for current clusters\n\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n            target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    }); // move the nodes to increase the delta modularity\n\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\n\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\n\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // the neightbors of the node\n\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\n\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\n\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\n\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        }); // modurarity for **adding** node i into this neighbor cluster\n\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // the increase modurarity is the difference between addModurarity and removeModurarity\n\n        var increase = addModurarity - removeModurarity; // find the best cluster to move node i into\n\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      }); // if found a best cluster to move into\n\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id; // move the node to the best cluster\n\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\n\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n              target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\n\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  } // delete the empty clusters, assign increasing clusterId\n\n\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n      return;\n    }\n\n    var newId = String(clusterIdx + 1);\n\n    if (newId === clusterId) {\n      return;\n    }\n\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    clusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete clusters[clusterId];\n    clusterIdx++;\n  });\n  nodes.forEach(function (node) {\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default louvain;"]},"metadata":{},"sourceType":"module"}