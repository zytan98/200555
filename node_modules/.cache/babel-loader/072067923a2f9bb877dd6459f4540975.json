{"ast":null,"code":"export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = p.x + \"|||\" + p.y;\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  } // when it is a point\n\n\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, // 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint, // 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  // const { minX, minY, maxX, maxY } = bbox;\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n        pa = _a[0],\n        pb = _a[1],\n        pc = _a[2],\n        pd = _a[3];\n\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current, lowestFScore;\n\n  while (openSet.length) {\n    current = undefined;\n    lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] <= lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  } // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset); // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-element/es/edges/polyline-util.js"],"names":["getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","pointsMap","pointsLength","length","i","id","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","anotherPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","concat","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","reconstructPath","pathPoints","pointById","cameFrom","currentId","iterator","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","pd1","pd2","pd3","pd4","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","current","lowestFScore","undefined","Infinity","neighbor","tentativeGScore","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","join","getPolylinePoints","end","sNode","tNode","getType","sNodeKeyShape","getKeyShape","getCanvasBBox","getBBox","tNodeKeyShape","sxBBox","txBBox","lineBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter"],"mappings":"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","sourcesContent":["export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = p.x + \"|||\" + p.y;\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  } // when it is a point\n\n\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, // 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint, // 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  // const { minX, minY, maxX, maxY } = bbox;\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n        pa = _a[0],\n        pb = _a[1],\n        pc = _a[2],\n        pd = _a[3];\n\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current, lowestFScore;\n\n  while (openSet.length) {\n    current = undefined;\n    lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] <= lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  } // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset); // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};"]},"metadata":{},"sourceType":"module"}