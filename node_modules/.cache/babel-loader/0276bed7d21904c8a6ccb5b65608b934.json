{"ast":null,"code":"/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[x + \"|||\" + y] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange; // return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, // 被 gridSize 格式化后的位置（anchorPoint）\noriPoint, // 未被 gridSize 格式化的位置（anchorPoint）\nnode, // 原始节点，用于获取 bbox\nanotherPoint, // 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return [point];\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = insterctP_1.x + \"|||\" + insterctP_1.y;\n          points.push(insterctP_1);\n        }\n      }\n    }\n\n    return points;\n  } // 如果 anchorPoint 在节点上，只有一个可选方向\n\n\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n  return [insterctP];\n};\n\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n\n  if (!cameFrom[current.id]) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n\n  var prevDirectionAngle = getDirectionAngle({\n    x: cameFrom[current.id].x,\n    y: cameFrom[current.id].y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\n\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    // if (scaleEndPoint.x === endPoint.x && scaleEndPoint.y === endPoint.y)\n    //   controlPoints.unshift({\n    //     x: endPoint.x,\n    //     y: endPoint.y\n    //   })\n    // else\n    //   controlPoints.unshift({\n    //     x: lastPoint.x * gridSize,\n    //     y: lastPoint.y * gridSize,\n    //   });\n    controlPoints.unshift({\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    });\n  }\n\n  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var preId = cameFrom[currentId].id;\n    var preX = cameFrom[currentId].x;\n    var preY = cameFrom[currentId].y;\n    var prePoint = {\n      x: preX,\n      y: preY,\n      id: preId\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      // if (prePoint.x === point.x && prePoint.y === point.y)\n      //   controlPoints.unshift({\n      //     x: controlPoints[0].x,\n      //     y: controlPoints[0].y\n      //   })\n      // else\n      //   controlPoints.unshift({\n      //     x: prePoint.x * gridSize,\n      //     y: prePoint.y * gridSize,\n      //   });\n      controlPoints.unshift({\n        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize\n      });\n    }\n\n    currentId = preId;\n    currentX = preX;\n    currentY = preY;\n  } // 和startNode对齐\n\n\n  var firstPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  }; // if (firstPoint.x === scaleStartPoint.x && firstPoint.y === scaleStartPoint.y) {\n  //   controlPoints[0].x = startPoint.x;\n  //   controlPoints[0].y = startPoint.y;\n  // }\n\n  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"|||\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"|||\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var remainLoops = cfg.maximumLoops;\n  var penalties = cfg.penalties;\n  var current, curCost, direction, neighbor, neighborCost, costFromStart, directionChange;\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    current = undefined;\n    curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    Object.keys(openSet).forEach(function (key) {\n      var id = openSet[key].id;\n\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    });\n    if (!current) break; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: Math.round(current.x) + direction.stepX + \"|||\" + (Math.round(current.y) + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);\n      costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-element/es/edges/router.js"],"names":["Util","deepMix","getExpandedBBox","getExpandedBBoxPoint","getPolylinePoints","simplifyPolyline","isSegmentCrossingBBox","manhattanDist","p1","p2","Math","abs","x","y","eucliDist","sqrt","pow","straightPath","start","end","simplePolyline","startNode","endNode","cfg","offset","defaultCfg","maxAllowedDirectionChange","PI","maximumLoops","gridSize","directions","stepX","stepY","penalties","distFunc","fallbackRoute","octolinearCfg","pos2GridIx","pos","gridIx","round","sign","getObstacleMap","items","map","forEach","item","bbox","getBBox","minX","maxX","minY","maxY","getDirectionAngle","deltaX","deltaY","atan2","getAngleDiff","angle1","angle2","directionChange","estimateCost","from","endPoints","min","Infinity","i","len","length","cost","getBoxPoints","point","oriPoint","node","anotherPoint","points","isInside","expandBBox","_i","directions_1","dir","bounds","boundLine","insterctP_1","getLineIntersect","width","height","id","push","insterctP","getDirectionChange","current","neighbor","cameFrom","scaleStartPoint","directionAngle","startAngle","prevDirectionAngle","getControlPoints","endPoint","startPoint","scaleEndPoint","controlPoints","currentId","currentX","currentY","lastPoint","unshift","preId","preX","preY","prePoint","firstPoint","pathFinder","routerCfg","isNaN","obstacles","concat","startPoints","openSet","closedSet","gScore","fScore","firstStep","remainLoops","curCost","direction","neighborCost","costFromStart","Object","keys","undefined","key","findIndex"],"mappings":"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","sourcesContent":["/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[x + \"|||\" + y] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange; // return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, // 被 gridSize 格式化后的位置（anchorPoint）\noriPoint, // 未被 gridSize 格式化的位置（anchorPoint）\nnode, // 原始节点，用于获取 bbox\nanotherPoint, // 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return [point];\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = insterctP_1.x + \"|||\" + insterctP_1.y;\n          points.push(insterctP_1);\n        }\n      }\n    }\n\n    return points;\n  } // 如果 anchorPoint 在节点上，只有一个可选方向\n\n\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n  return [insterctP];\n};\n\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n\n  if (!cameFrom[current.id]) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n\n  var prevDirectionAngle = getDirectionAngle({\n    x: cameFrom[current.id].x,\n    y: cameFrom[current.id].y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\n\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    // if (scaleEndPoint.x === endPoint.x && scaleEndPoint.y === endPoint.y)\n    //   controlPoints.unshift({\n    //     x: endPoint.x,\n    //     y: endPoint.y\n    //   })\n    // else\n    //   controlPoints.unshift({\n    //     x: lastPoint.x * gridSize,\n    //     y: lastPoint.y * gridSize,\n    //   });\n    controlPoints.unshift({\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    });\n  }\n\n  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var preId = cameFrom[currentId].id;\n    var preX = cameFrom[currentId].x;\n    var preY = cameFrom[currentId].y;\n    var prePoint = {\n      x: preX,\n      y: preY,\n      id: preId\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      // if (prePoint.x === point.x && prePoint.y === point.y)\n      //   controlPoints.unshift({\n      //     x: controlPoints[0].x,\n      //     y: controlPoints[0].y\n      //   })\n      // else\n      //   controlPoints.unshift({\n      //     x: prePoint.x * gridSize,\n      //     y: prePoint.y * gridSize,\n      //   });\n      controlPoints.unshift({\n        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize\n      });\n    }\n\n    currentId = preId;\n    currentX = preX;\n    currentY = preY;\n  } // 和startNode对齐\n\n\n  var firstPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  }; // if (firstPoint.x === scaleStartPoint.x && firstPoint.y === scaleStartPoint.y) {\n  //   controlPoints[0].x = startPoint.x;\n  //   controlPoints[0].y = startPoint.y;\n  // }\n\n  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"|||\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"|||\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var remainLoops = cfg.maximumLoops;\n  var penalties = cfg.penalties;\n  var current, curCost, direction, neighbor, neighborCost, costFromStart, directionChange;\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    current = undefined;\n    curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    Object.keys(openSet).forEach(function (key) {\n      var id = openSet[key].id;\n\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    });\n    if (!current) break; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: Math.round(current.x) + direction.stepX + \"|||\" + (Math.round(current.y) + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);\n      costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};"]},"metadata":{},"sourceType":"module"}