{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { AST_TOKEN_TYPES, createEntity, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport { isTypedArray } from '../utils/is-typedarray';\n/* babel-plugin-inline-import './shaders/quad.vert.glsl' */\n\nvar quadVert = \"attribute vec3 a_Position;\\nattribute vec2 a_TexCoord;\\n\\nvarying vec2 v_TexCoord;\\n\\nvoid main() {\\n  gl_Position = vec4(a_Position, 1.0);\\n  v_TexCoord = a_TexCoord;\\n}\";\nvar textureId = 0;\nvar debug = false;\n/**\n * adaptor for regl.DrawCommand\n */\n\nvar ReglComputeModel = /*#__PURE__*/function () {\n  function ReglComputeModel(reGl, context) {\n    var _this = this;\n\n    _classCallCheck(this, ReglComputeModel);\n\n    this.reGl = reGl;\n    this.context = context;\n    this.entity = createEntity();\n    this.texFBO = void 0;\n    this.computeCommand = void 0;\n    this.textureCache = {};\n    this.outputTextureName = void 0;\n    this.swapOutputTextureName = void 0;\n    this.compiledPingpong = void 0;\n    this.dynamicPingpong = void 0;\n    var uniforms = {};\n    this.context.uniforms.forEach(function (uniform) {\n      var name = uniform.name,\n          type = uniform.type,\n          data = uniform.data,\n          isReferer = uniform.isReferer,\n          storageClass = uniform.storageClass; // store data with a 2D texture\n\n      if (storageClass === STORAGE_CLASS.StorageBuffer) {\n        if (!isReferer) {\n          _this.textureCache[name] = _this.calcDataTexture(name, type, data);\n          var _this$textureCache$na = _this.textureCache[name],\n              width = _this$textureCache$na.textureWidth,\n              isOutput = _this$textureCache$na.isOutput;\n          uniforms[\"\".concat(name, \"Size\")] = [width, width];\n\n          if (isOutput) {\n            _this.outputTextureName = name;\n\n            if (_this.context.needPingpong) {\n              _this.outputTextureName = \"\".concat(name, \"Output\");\n              _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);\n            }\n          }\n        } else {\n          // @ts-ignore\n          _this.textureCache[name] = {\n            data: undefined\n          }; // refer to another kernel's output,\n          // the referred kernel may not have been initialized, so we use dynamic way here\n\n          uniforms[\"\".concat(name, \"Size\")] = function () {\n            return (// @ts-ignore\n              data.compiledBundle.context.output.textureSize\n            );\n          };\n        }\n\n        uniforms[name] = function () {\n          if (debug) {\n            console.log(\"[\".concat(_this.entity, \"]: \").concat(name, \" \").concat(_this.textureCache[name].id));\n          }\n\n          return _this.textureCache[name].texture;\n        };\n      } else if (storageClass === STORAGE_CLASS.Uniform) {\n        if (data && (Array.isArray(data) || isTypedArray(data)) && data.length > 16) {\n          // up to mat4 which includes 16 elements\n          throw new Error(\"invalid data type \".concat(type));\n        } // get uniform dynamically\n\n\n        uniforms[name] = function () {\n          return uniform.data;\n        };\n      }\n    });\n\n    var _this$getOuputDataTex = this.getOuputDataTexture(),\n        textureWidth = _this$getOuputDataTex.textureWidth,\n        texelCount = _this$getOuputDataTex.texelCount; // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出\n\n\n    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];\n    uniforms.u_OutputTexelCount = texelCount; // 保存在 Kernel 的上下文中，供其他 Kernel 引用\n\n    this.context.output.textureSize = [textureWidth, textureWidth];\n    var drawParams = {\n      attributes: {\n        a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],\n        a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]\n      },\n      frag: \"#ifdef GL_FRAGMENT_PRECISION_HIGH\\n  precision highp float;\\n#else\\n  precision mediump float;\\n#endif\\n\".concat(this.context.shader),\n      uniforms: uniforms,\n      vert: quadVert,\n      // TODO: use a fullscreen triangle instead.\n      primitive: 'triangle strip',\n      count: 4\n    };\n    this.computeCommand = this.reGl(drawParams);\n  }\n\n  _createClass(ReglComputeModel, [{\n    key: \"run\",\n    value: function run() {\n      var _this2 = this;\n\n      if (this.context.maxIteration > 1 && this.context.needPingpong) {\n        this.compiledPingpong = true;\n      } // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`\n      // this.needPingpong =\n      //   !!(this.context.maxIteration > 1 && this.context.needPingpong);\n      // if (this.relativeOutputTextureNames.length) {\n      //   const { id, texture } = this.getOuputDataTexture();\n      //   this.relativeOutputTextureNames.forEach((name) => {\n      //     this.textureCache[name].id = id;\n      //     this.textureCache[name].texture = texture;\n      //   });\n      //   this.swap();\n      // }\n\n\n      if (this.compiledPingpong || this.dynamicPingpong) {\n        this.swap();\n      }\n\n      this.texFBO = this.reGl.framebuffer({\n        color: this.getOuputDataTexture().texture\n      });\n      this.texFBO.use(function () {\n        _this2.computeCommand();\n      });\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.reGl({\n                  framebuffer: this.texFBO\n                })(function () {\n                  pixels = _this3.reGl.read();\n                }); // @ts-ignore\n\n                if (!pixels) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;\n                formattedPixels = [];\n\n                if (elementsPerTexel !== 4) {\n                  for (i = 0; i < pixels.length; i += 4) {\n                    if (elementsPerTexel === 1) {\n                      formattedPixels.push(pixels[i]);\n                    } else if (elementsPerTexel === 2) {\n                      formattedPixels.push(pixels[i], pixels[i + 1]);\n                    } else {\n                      formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);\n                    }\n                  }\n                } else {\n                  // @ts-ignore\n                  formattedPixels = pixels;\n                } // 截取多余的部分\n                // @ts-ignore\n\n\n                return _context.abrupt(\"return\", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));\n\n              case 6:\n                return _context.abrupt(\"return\", new Float32Array());\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      var inputModel; // refer to self, same as pingpong\n\n      if (this.entity === model.entity) {\n        this.dynamicPingpong = true;\n        inputModel = this;\n      } else {\n        inputModel = model;\n      }\n\n      this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;\n      this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: confirm input \").concat(inputName, \" from model \").concat(inputModel.entity, \", \").concat(inputModel.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform() {// already get uniform's data dynamically when created, do nothing here\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // regenerate data texture\n\n      var buffer = this.context.uniforms.find(function (_ref) {\n        var name = _ref.name;\n        return name === bufferName;\n      });\n\n      if (buffer) {\n        var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data),\n            texture = _this$calcDataTexture.texture,\n            paddingData = _this$calcDataTexture.data; // TODO: destroy outdated texture\n\n\n        this.textureCache[bufferName].data = paddingData;\n        this.textureCache[bufferName].texture = texture;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {// regl will destroy all resources\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (!this.swapOutputTextureName) {\n        this.createSwapOutputDataTexture();\n      }\n\n      if (this.compiledPingpong) {\n        var outputTextureUniformName = this.context.output.name;\n        this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;\n        this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;\n      }\n\n      var tmp = this.outputTextureName;\n      this.outputTextureName = this.swapOutputTextureName;\n      this.swapOutputTextureName = tmp;\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: after swap, output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"getOuputDataTexture\",\n    value: function getOuputDataTexture() {\n      return this.textureCache[this.outputTextureName];\n    }\n  }, {\n    key: \"createSwapOutputDataTexture\",\n    value: function createSwapOutputDataTexture() {\n      var texture = this.cloneDataTexture(this.getOuputDataTexture());\n      this.swapOutputTextureName = \"\".concat(this.entity, \"-swap\");\n      this.textureCache[this.swapOutputTextureName] = texture;\n    }\n  }, {\n    key: \"cloneDataTexture\",\n    value: function cloneDataTexture(texture) {\n      var data = texture.data,\n          textureWidth = texture.textureWidth;\n      return _objectSpread(_objectSpread({}, texture), {}, {\n        id: textureId++,\n        // @ts-ignore\n        texture: this.reGl.texture({\n          width: textureWidth,\n          height: textureWidth,\n          data: data,\n          type: 'float'\n        })\n      });\n    }\n  }, {\n    key: \"calcDataTexture\",\n    value: function calcDataTexture(name, type, data) {\n      var elementsPerTexel = 1;\n\n      if (type === AST_TOKEN_TYPES.Vector4FloatArray) {\n        elementsPerTexel = 4;\n      } // 用 0 补全不足 vec4 的部分\n\n\n      var paddingData = [];\n\n      for (var i = 0; i < data.length; i += elementsPerTexel) {\n        if (elementsPerTexel === 1) {\n          paddingData.push(data[i], 0, 0, 0);\n        } else if (elementsPerTexel === 2) {\n          paddingData.push(data[i], data[i + 1], 0, 0);\n        } else if (elementsPerTexel === 3) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], 0);\n        } else if (elementsPerTexel === 4) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], data[i + 3]);\n        }\n      } // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充\n\n\n      var originalDataLength = data.length;\n      var texelCount = Math.ceil(originalDataLength / elementsPerTexel);\n      var width = Math.ceil(Math.sqrt(texelCount));\n      var paddingTexelCount = width * width;\n\n      if (texelCount < paddingTexelCount) {\n        paddingData.push.apply(paddingData, _toConsumableArray(new Array((paddingTexelCount - texelCount) * 4).fill(0)));\n      }\n\n      var texture = this.reGl.texture({\n        width: width,\n        height: width,\n        data: paddingData,\n        type: 'float'\n      });\n      return {\n        id: textureId++,\n        data: paddingData,\n        originalDataLength: originalDataLength,\n        typedArrayConstructor: isTypedArray(data) ? data.constructor : undefined,\n        textureWidth: width,\n        texture: texture,\n        texelCount: texelCount,\n        elementsPerTexel: elementsPerTexel,\n        isOutput: name === this.context.output.name\n      };\n    }\n  }]);\n\n  return ReglComputeModel;\n}();\n\nexport { ReglComputeModel as default };","map":{"version":3,"sources":["../../src/webgl/ReglComputeModel.ts"],"names":["textureId","debug","ReglComputeModel","entity","createEntity","texFBO","computeCommand","textureCache","outputTextureName","swapOutputTextureName","compiledPingpong","dynamicPingpong","reGl","context","uniforms","name","type","data","isReferer","storageClass","uniform","STORAGE_CLASS","width","isOutput","undefined","textureSize","console","Array","isTypedArray","textureWidth","texelCount","drawParams","attributes","a_Position","a_TexCoord","frag","vert","primitive","count","color","texture","framebuffer","pixels","originalDataLength","elementsPerTexel","typedArrayConstructor","Float32Array","formattedPixels","i","model","inputName","inputModel","bufferName","offset","buffer","paddingData","outputTextureUniformName","tmp","id","height","AST_TOKEN_TYPES","Math","paddingTexelCount"],"mappings":"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","sourcesContent":["import {\n  AST_TOKEN_TYPES,\n  createEntity,\n  DataType,\n  GLSLContext,\n  IComputeModel,\n  STORAGE_CLASS,\n} from '@antv/g-webgpu-core';\nimport regl from 'regl';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport quadVert from './shaders/quad.vert.glsl';\n\ninterface DataTextureDescriptor {\n  id: number;\n  data:\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | undefined;\n  textureWidth: number;\n  texture: regl.Texture2D;\n  texelCount: number;\n  originalDataLength: number;\n  elementsPerTexel: number;\n  typedArrayConstructor?: Function;\n  isOutput: boolean;\n}\n\nlet textureId = 0;\nconst debug = false;\n\n/**\n * adaptor for regl.DrawCommand\n */\nexport default class ReglComputeModel implements IComputeModel {\n  private entity = createEntity();\n  private texFBO: regl.Framebuffer2D;\n  private computeCommand: regl.DrawCommand;\n  private textureCache: {\n    [textureName: string]: DataTextureDescriptor;\n  } = {};\n  private outputTextureName: string;\n  private swapOutputTextureName: string;\n  private compiledPingpong: boolean;\n  private dynamicPingpong: boolean;\n\n  constructor(private reGl: regl.Regl, private context: GLSLContext) {\n    const uniforms: Record<string, any> = {};\n    this.context.uniforms.forEach((uniform) => {\n      const { name, type, data, isReferer, storageClass } = uniform;\n      // store data with a 2D texture\n      if (storageClass === STORAGE_CLASS.StorageBuffer) {\n        if (!isReferer) {\n          this.textureCache[name] = this.calcDataTexture(name, type, data!);\n          const { textureWidth: width, isOutput } = this.textureCache[name];\n          uniforms[`${name}Size`] = [width, width];\n\n          if (isOutput) {\n            this.outputTextureName = name;\n            if (this.context.needPingpong) {\n              this.outputTextureName = `${name}Output`;\n              this.textureCache[this.outputTextureName] = this.calcDataTexture(\n                name,\n                type,\n                data!,\n              );\n            }\n          }\n        } else {\n          // @ts-ignore\n          this.textureCache[name] = {\n            data: undefined,\n          };\n          // refer to another kernel's output,\n          // the referred kernel may not have been initialized, so we use dynamic way here\n          uniforms[`${name}Size`] = () =>\n            // @ts-ignore\n            data.compiledBundle.context.output.textureSize;\n        }\n\n        uniforms[name] = () => {\n          if (debug) {\n            console.log(\n              `[${this.entity}]: ${name} ${this.textureCache[name].id}`,\n            );\n          }\n          return this.textureCache[name].texture;\n        };\n      } else if (storageClass === STORAGE_CLASS.Uniform) {\n        if (\n          data &&\n          (Array.isArray(data) || isTypedArray(data)) &&\n          (data as ArrayLike<number>).length > 16\n        ) {\n          // up to mat4 which includes 16 elements\n          throw new Error(`invalid data type ${type}`);\n        }\n        // get uniform dynamically\n        uniforms[name] = () => uniform.data;\n      }\n    });\n\n    const { textureWidth, texelCount } = this.getOuputDataTexture();\n\n    // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出\n    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];\n    uniforms.u_OutputTexelCount = texelCount;\n\n    // 保存在 Kernel 的上下文中，供其他 Kernel 引用\n    this.context.output.textureSize = [textureWidth!, textureWidth!];\n\n    const drawParams: regl.DrawConfig = {\n      attributes: {\n        a_Position: [\n          [-1, 1, 0],\n          [-1, -1, 0],\n          [1, 1, 0],\n          [1, -1, 0],\n        ],\n        a_TexCoord: [\n          [0, 1],\n          [0, 0],\n          [1, 1],\n          [1, 0],\n        ],\n      },\n      frag: `#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n${this.context.shader}`,\n      uniforms,\n      vert: quadVert,\n      // TODO: use a fullscreen triangle instead.\n      primitive: 'triangle strip',\n      count: 4,\n    };\n\n    this.computeCommand = this.reGl(drawParams);\n  }\n\n  public run() {\n    if (this.context.maxIteration > 1 && this.context.needPingpong) {\n      this.compiledPingpong = true;\n    }\n    // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`\n    // this.needPingpong =\n    //   !!(this.context.maxIteration > 1 && this.context.needPingpong);\n\n    // if (this.relativeOutputTextureNames.length) {\n    //   const { id, texture } = this.getOuputDataTexture();\n    //   this.relativeOutputTextureNames.forEach((name) => {\n    //     this.textureCache[name].id = id;\n    //     this.textureCache[name].texture = texture;\n    //   });\n    //   this.swap();\n    // }\n\n    if (this.compiledPingpong || this.dynamicPingpong) {\n      this.swap();\n    }\n\n    this.texFBO = this.reGl.framebuffer({\n      color: this.getOuputDataTexture().texture,\n    });\n    this.texFBO.use(() => {\n      this.computeCommand();\n    });\n    if (debug) {\n      console.log(`[${this.entity}]: output ${this.getOuputDataTexture().id}`);\n    }\n  }\n\n  public async readData() {\n    let pixels: Uint8Array | Float32Array;\n    this.reGl({\n      framebuffer: this.texFBO,\n    })(() => {\n      pixels = this.reGl.read();\n    });\n\n    // @ts-ignore\n    if (pixels) {\n      const {\n        originalDataLength,\n        elementsPerTexel,\n        typedArrayConstructor = Float32Array,\n      } = this.getOuputDataTexture();\n\n      let formattedPixels = [];\n      if (elementsPerTexel !== 4) {\n        for (let i = 0; i < pixels.length; i += 4) {\n          if (elementsPerTexel === 1) {\n            formattedPixels.push(pixels[i]);\n          } else if (elementsPerTexel === 2) {\n            formattedPixels.push(pixels[i], pixels[i + 1]);\n          } else {\n            formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);\n          }\n        }\n      } else {\n        // @ts-ignore\n        formattedPixels = pixels;\n      }\n\n      // 截取多余的部分\n      // @ts-ignore\n      return new typedArrayConstructor(\n        formattedPixels.slice(0, originalDataLength),\n      );\n    }\n\n    return new Float32Array();\n  }\n\n  public confirmInput(model: IComputeModel, inputName: string) {\n    let inputModel: ReglComputeModel;\n    // refer to self, same as pingpong\n    if (this.entity === (model as ReglComputeModel).entity) {\n      this.dynamicPingpong = true;\n      inputModel = this;\n    } else {\n      inputModel = model as ReglComputeModel;\n    }\n\n    this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;\n    this.textureCache[\n      inputName\n    ].texture = inputModel.getOuputDataTexture().texture;\n\n    if (debug) {\n      console.log(\n        `[${this.entity}]: confirm input ${inputName} from model ${\n          inputModel.entity\n        }, ${(inputModel as ReglComputeModel).getOuputDataTexture().id}`,\n      );\n    }\n  }\n\n  public updateUniform() {\n    // already get uniform's data dynamically when created, do nothing here\n  }\n\n  public updateBuffer(\n    bufferName: string,\n    data:\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n    offset: number = 0,\n  ) {\n    // regenerate data texture\n    const buffer = this.context.uniforms.find(\n      ({ name }) => name === bufferName,\n    );\n    if (buffer) {\n      const { texture, data: paddingData } = this.calcDataTexture(\n        bufferName,\n        buffer.type,\n        data,\n      );\n\n      // TODO: destroy outdated texture\n      this.textureCache[bufferName].data = paddingData;\n      this.textureCache[bufferName].texture = texture;\n    }\n  }\n\n  public destroy() {\n    // regl will destroy all resources\n  }\n\n  private swap() {\n    if (!this.swapOutputTextureName) {\n      this.createSwapOutputDataTexture();\n    }\n\n    if (this.compiledPingpong) {\n      const outputTextureUniformName = this.context.output.name;\n      this.textureCache[\n        outputTextureUniformName\n      ].id = this.getOuputDataTexture().id;\n      this.textureCache[\n        outputTextureUniformName\n      ].texture = this.getOuputDataTexture().texture;\n    }\n\n    const tmp = this.outputTextureName;\n    this.outputTextureName = this.swapOutputTextureName;\n    this.swapOutputTextureName = tmp;\n\n    if (debug) {\n      console.log(\n        `[${this.entity}]: after swap, output ${this.getOuputDataTexture().id}`,\n      );\n    }\n  }\n\n  private getOuputDataTexture() {\n    return this.textureCache[this.outputTextureName];\n  }\n\n  private createSwapOutputDataTexture() {\n    const texture = this.cloneDataTexture(this.getOuputDataTexture());\n    this.swapOutputTextureName = `${this.entity}-swap`;\n    this.textureCache[this.swapOutputTextureName] = texture;\n  }\n\n  private cloneDataTexture(texture: DataTextureDescriptor) {\n    const { data, textureWidth } = texture;\n    return {\n      ...texture,\n      id: textureId++,\n      // @ts-ignore\n      texture: this.reGl.texture({\n        width: textureWidth,\n        height: textureWidth,\n        data,\n        type: 'float',\n      }),\n    };\n  }\n\n  private calcDataTexture(\n    name: string,\n    type: DataType,\n    data:\n      | number\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n  ) {\n    let elementsPerTexel = 1;\n    if (type === AST_TOKEN_TYPES.Vector4FloatArray) {\n      elementsPerTexel = 4;\n    }\n\n    // 用 0 补全不足 vec4 的部分\n    const paddingData: number[] = [];\n    for (let i = 0; i < (data as number[]).length; i += elementsPerTexel) {\n      if (elementsPerTexel === 1) {\n        paddingData.push((data as number[])[i], 0, 0, 0);\n      } else if (elementsPerTexel === 2) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          0,\n          0,\n        );\n      } else if (elementsPerTexel === 3) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          (data as number[])[i + 2],\n          0,\n        );\n      } else if (elementsPerTexel === 4) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          (data as number[])[i + 2],\n          (data as number[])[i + 3],\n        );\n      }\n    }\n\n    // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充\n    const originalDataLength = (data as ArrayLike<number>).length;\n    const texelCount = Math.ceil(originalDataLength / elementsPerTexel);\n    const width = Math.ceil(Math.sqrt(texelCount));\n    const paddingTexelCount = width * width;\n    if (texelCount < paddingTexelCount) {\n      paddingData.push(\n        ...new Array((paddingTexelCount - texelCount) * 4).fill(0),\n      );\n    }\n\n    const texture = this.reGl.texture({\n      width,\n      height: width,\n      data: paddingData,\n      type: 'float',\n    });\n\n    return {\n      id: textureId++,\n      data: paddingData,\n      originalDataLength,\n      typedArrayConstructor: isTypedArray(data) ? data!.constructor : undefined,\n      textureWidth: width,\n      texture,\n      texelCount,\n      elementsPerTexel,\n      isOutput: name === this.context.output.name,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}