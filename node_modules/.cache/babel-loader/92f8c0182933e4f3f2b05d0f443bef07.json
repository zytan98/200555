{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nimport { extractUniforms } from '../../utils/shader-module';\nimport { uniq } from '../../utils/uniq';\n/* babel-plugin-inline-import './shaders/webgl.picking.frag.glsl' */\n\nvar pickingFrag = \"varying vec4 v_PickingResult;\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\n\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color) {\\n  bool selected = bool(v_PickingResult.a);\\n\\n  if (selected) {\\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\\n\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(resultRGB, color.a);\\n  } else {\\n    return color;\\n  }\\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  return filterPickingColor(filterHighlightColor(color));\\n}\\n\";\n/* babel-plugin-inline-import './shaders/webgl.picking.vert.glsl' */\n\nvar pickingVert = \"attribute vec3 a_PickingColor;\\nvarying vec4 v_PickingResult;\\n\\nuniform vec3 u_PickingColor : [0, 0, 0];\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\nuniform float u_PickingThreshold : 1.0;\\nuniform float u_PickingBuffer: 0.0;\\n\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    abs(vertexColor.r - u_PickingColor.r) < u_PickingThreshold &&\\n    abs(vertexColor.g - u_PickingColor.g) < u_PickingThreshold &&\\n    abs(vertexColor.b - u_PickingColor.b) < u_PickingThreshold;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  // compares only in highlight stage\\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\\n\\n  // Stores the picking color so that the fragment shader can render it during picking\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\";\n/* babel-plugin-inline-import './shaders/webgl.sdf2d.frag.glsl' */\n\nvar sdf2dFrag = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\";\nvar precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nvar globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nvar includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\nvar ShaderModuleService = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function ShaderModuleService() {\n    _classCallCheck(this, ShaderModuleService);\n\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n\n  _createClass(ShaderModuleService, [{\n    key: \"registerBuiltinModules\",\n    value: function registerBuiltinModules() {\n      this.destroy();\n      this.registerModule('picking', {\n        vs: pickingVert,\n        fs: pickingFrag\n      });\n      this.registerModule('sdf2d', {\n        vs: '',\n        fs: sdf2dFrag\n      });\n    }\n  }, {\n    key: \"registerModule\",\n    value: function registerModule(moduleName, moduleParams) {\n      // prevent registering the same module multiple times\n      if (this.rawContentCache[moduleName]) {\n        return;\n      }\n\n      var _moduleParams$vs = moduleParams.vs,\n          vs = _moduleParams$vs === void 0 ? '' : _moduleParams$vs,\n          _moduleParams$fs = moduleParams.fs,\n          fs = _moduleParams$fs === void 0 ? '' : _moduleParams$fs,\n          declaredUniforms = moduleParams.uniforms;\n\n      var _extractUniforms = extractUniforms(vs),\n          extractedVS = _extractUniforms.content,\n          vsUniforms = _extractUniforms.uniforms;\n\n      var _extractUniforms2 = extractUniforms(fs),\n          extractedFS = _extractUniforms2.content,\n          fsUniforms = _extractUniforms2.uniforms;\n\n      this.rawContentCache[moduleName] = {\n        fs: extractedFS,\n        uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n        vs: extractedVS\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.moduleCache = {};\n      this.rawContentCache = {};\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(moduleName) {\n      var _this = this;\n\n      if (this.moduleCache[moduleName]) {\n        return this.moduleCache[moduleName];\n      }\n\n      var rawVS = this.rawContentCache[moduleName].vs || '';\n      var rawFS = this.rawContentCache[moduleName].fs || '';\n\n      var _this$processModule = this.processModule(rawVS, [], 'vs'),\n          vs = _this$processModule.content,\n          vsIncludeList = _this$processModule.includeList;\n\n      var _this$processModule2 = this.processModule(rawFS, [], 'fs'),\n          fs = _this$processModule2.content,\n          fsIncludeList = _this$processModule2.includeList;\n\n      var compiledFs = fs; // TODO: extract uniforms and their default values from GLSL\n\n      var uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {\n        return _objectSpread(_objectSpread({}, prev), _this.rawContentCache[cur].uniforms);\n      }, {});\n      /**\n       * set default precision for fragment shader\n       * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n       */\n\n      if (!precisionRegExp.test(fs)) {\n        compiledFs = globalDefaultprecision + fs;\n      }\n\n      this.moduleCache[moduleName] = {\n        fs: compiledFs.trim(),\n        uniforms: uniforms,\n        vs: vs.trim()\n      };\n      return this.moduleCache[moduleName];\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(rawContent, includeList, type) {\n      var _this2 = this;\n\n      var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {\n        var includeOpt = strMatch.split(' ');\n        var includeName = includeOpt[0].replace(/\"/g, '');\n\n        if (includeList.indexOf(includeName) > -1) {\n          return '';\n        }\n\n        var txt = _this2.rawContentCache[includeName][type];\n        includeList.push(includeName);\n\n        var _this2$processModule = _this2.processModule(txt || '', includeList, type),\n            content = _this2$processModule.content;\n\n        return content;\n      });\n      return {\n        content: compiled,\n        includeList: includeList\n      };\n    }\n  }]);\n\n  return ShaderModuleService;\n}(), _temp)) || _class);\nexport { ShaderModuleService as default };","map":{"version":3,"sources":["../../../src/services/shader-module/ShaderModuleService.ts"],"names":["precisionRegExp","globalDefaultprecision","includeRegExp","injectable","ShaderModuleService","moduleCache","rawContentCache","vs","fs","pickingFrag","sdf2dFrag","moduleName","moduleParams","declaredUniforms","extractedVS","vsUniforms","extractUniforms","extractedFS","fsUniforms","uniforms","rawVS","rawFS","vsIncludeList","fsIncludeList","compiledFs","rawContent","includeList","type","compiled","includeOpt","strMatch","includeName","txt","content"],"mappings":"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","sourcesContent":["import { injectable } from 'inversify';\nimport { extractUniforms } from '../../utils/shader-module';\nimport { uniq } from '../../utils/uniq';\nimport pickingFrag from './shaders/webgl.picking.frag.glsl';\nimport pickingVert from './shaders/webgl.picking.vert.glsl';\nimport sdf2dFrag from './shaders/webgl.sdf2d.frag.glsl';\n\nconst precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nconst globalDefaultprecision =\n  '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nconst includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\n\nimport { IUniform } from '../../components/renderer/IUniform';\n\n/**\n * 提供 ShaderModule 管理服务\n */\n\nexport interface IModuleParams {\n  vs?: string;\n  fs?: string;\n  uniforms?: {\n    [key: string]: IUniform;\n  };\n}\n\nexport interface IShaderModuleService {\n  registerModule(moduleName: string, moduleParams: IModuleParams): void;\n  getModule(moduleName: string): IModuleParams;\n\n  /**\n   * 注册内置 shader module\n   */\n  registerBuiltinModules(): void;\n  destroy(): void;\n}\n\n@injectable()\nexport default class ShaderModuleService implements IShaderModuleService {\n  private moduleCache: { [key: string]: IModuleParams } = {};\n  private rawContentCache: { [key: string]: IModuleParams } = {};\n\n  public registerBuiltinModules() {\n    this.destroy();\n    this.registerModule('picking', { vs: pickingVert, fs: pickingFrag });\n    this.registerModule('sdf2d', { vs: '', fs: sdf2dFrag });\n  }\n\n  public registerModule(moduleName: string, moduleParams: IModuleParams) {\n    // prevent registering the same module multiple times\n    if (this.rawContentCache[moduleName]) {\n      return;\n    }\n\n    const { vs = '', fs = '', uniforms: declaredUniforms } = moduleParams;\n    const { content: extractedVS, uniforms: vsUniforms } = extractUniforms(vs);\n    const { content: extractedFS, uniforms: fsUniforms } = extractUniforms(fs);\n\n    this.rawContentCache[moduleName] = {\n      fs: extractedFS,\n      uniforms: {\n        ...vsUniforms,\n        ...fsUniforms,\n        ...declaredUniforms,\n      },\n      vs: extractedVS,\n    };\n  }\n  public destroy() {\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n  public getModule(moduleName: string): IModuleParams {\n    if (this.moduleCache[moduleName]) {\n      return this.moduleCache[moduleName];\n    }\n\n    const rawVS = this.rawContentCache[moduleName].vs || '';\n    const rawFS = this.rawContentCache[moduleName].fs || '';\n\n    const { content: vs, includeList: vsIncludeList } = this.processModule(\n      rawVS,\n      [],\n      'vs',\n    );\n    const { content: fs, includeList: fsIncludeList } = this.processModule(\n      rawFS,\n      [],\n      'fs',\n    );\n    let compiledFs = fs;\n    // TODO: extract uniforms and their default values from GLSL\n    const uniforms: {\n      [key: string]: any;\n    } = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(\n      (prev, cur: string) => {\n        return {\n          ...prev,\n          ...this.rawContentCache[cur].uniforms,\n        };\n      },\n      {},\n    );\n\n    /**\n     * set default precision for fragment shader\n     * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n     */\n    if (!precisionRegExp.test(fs)) {\n      compiledFs = globalDefaultprecision + fs;\n    }\n\n    this.moduleCache[moduleName] = {\n      fs: compiledFs.trim(),\n      uniforms,\n      vs: vs.trim(),\n    };\n    return this.moduleCache[moduleName];\n  }\n\n  private processModule(\n    rawContent: string,\n    includeList: string[],\n    type: 'vs' | 'fs',\n  ): {\n    content: string;\n    includeList: string[];\n  } {\n    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {\n      const includeOpt = strMatch.split(' ');\n      const includeName = includeOpt[0].replace(/\"/g, '');\n\n      if (includeList.indexOf(includeName) > -1) {\n        return '';\n      }\n\n      const txt = this.rawContentCache[includeName][type];\n      includeList.push(includeName);\n\n      const { content } = this.processModule(txt || '', includeList, type);\n      return content;\n    });\n\n    return {\n      content: compiled,\n      includeList,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}