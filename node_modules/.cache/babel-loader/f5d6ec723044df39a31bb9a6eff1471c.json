{"ast":null,"code":"/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isNaN, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 网格布局\n */\n\nexport class GridLayout extends Base {\n  constructor(options) {\n    super();\n    /** 布局起始点 */\n\n    this.begin = [0, 0];\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    this.preventOverlap = true;\n    /** extra spacing around nodes when preventOverlap: true */\n\n    this.preventOverlapPadding = 10;\n    /** uses all available space on false, uses minimal space on true */\n\n    this.condense = false;\n    /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n\n    this.sortBy = \"degree\";\n    this.nodeSize = 30;\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    this.row = 0;\n    this.col = 0;\n    this.cellWidth = 0;\n    this.cellHeight = 0;\n    this.cellUsed = {};\n    this.id2manPos = {};\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      begin: [0, 0],\n      preventOverlap: true,\n      preventOverlapPadding: 10,\n      condense: false,\n      rows: undefined,\n      cols: undefined,\n      position: undefined,\n      sortBy: \"degree\",\n      nodeSize: 30\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n    const begin = self.begin;\n\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes,\n        edges\n      };\n    }\n\n    if (n === 1) {\n      nodes[0].x = begin[0];\n      nodes[0].y = begin[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes,\n        edges\n      };\n    }\n\n    const layoutNodes = [];\n    nodes.forEach(node => {\n      layoutNodes.push(node);\n    });\n    const nodeIdxMap = {};\n    layoutNodes.forEach((node, i) => {\n      nodeIdxMap[node.id] = i;\n    });\n\n    if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n\n      if (isNaN(nodes[0].degree)) {\n        const values = getDegree(layoutNodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach((node, i) => {\n          node.degree = values[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    const oRows = self.rows;\n    const oCols = self.cols != null ? self.cols : self.columns;\n    self.cells = n; // if rows or columns were set in self, use those values\n\n    if (oRows != null && oCols != null) {\n      self.rows = oRows;\n      self.cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      self.rows = oRows;\n      self.cols = Math.ceil(self.cells / self.rows);\n    } else if (oRows == null && oCols != null) {\n      self.cols = oCols;\n      self.rows = Math.ceil(self.cells / self.cols);\n    } else {\n      // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n      // width/height * splits^2 = cells where splits is number of times to split width\n      self.splits = Math.sqrt(self.cells * self.height / self.width);\n      self.rows = Math.round(self.splits);\n      self.cols = Math.round(self.width / self.height * self.splits);\n    }\n\n    if (self.cols * self.rows > self.cells) {\n      // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      const sm = self.small();\n      const lg = self.large(); // reducing the small side takes away the most cells, so try it first\n\n      if ((sm - 1) * lg >= self.cells) {\n        self.small(sm - 1);\n      } else if ((lg - 1) * sm >= self.cells) {\n        self.large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (self.cols * self.rows < self.cells) {\n        const sm = self.small();\n        const lg = self.large(); // try to add to larger side first (adds less in multiplication)\n\n        if ((lg + 1) * sm >= self.cells) {\n          self.large(lg + 1);\n        } else {\n          self.small(sm + 1);\n        }\n      }\n    }\n\n    self.cellWidth = self.width / self.cols;\n    self.cellHeight = self.height / self.rows;\n\n    if (self.condense) {\n      self.cellWidth = 0;\n      self.cellHeight = 0;\n    }\n\n    if (self.preventOverlap) {\n      layoutNodes.forEach(node => {\n        if (!node.x || !node.y) {\n          // for bb\n          node.x = 0;\n          node.y = 0;\n        }\n\n        let nodew;\n        let nodeh;\n\n        if (isArray(node.size)) {\n          nodew = node.size[0];\n          nodeh = node.size[1];\n        } else if (isNumber(node.size)) {\n          nodew = node.size;\n          nodeh = node.size;\n        } else if (isObject(node.size)) {\n          nodew = node.size.width;\n          nodeh = node.size.height;\n        }\n\n        if (nodew === undefined || nodeh === undefined) {\n          if (isArray(self.nodeSize)) {\n            nodew = self.nodeSize[0];\n            nodeh = self.nodeSize[1];\n          } else if (isNumber(self.nodeSize)) {\n            nodew = self.nodeSize;\n            nodeh = self.nodeSize;\n          } else {\n            nodew = 30;\n            nodeh = 30;\n          }\n        }\n\n        const p = self.preventOverlapPadding;\n        const w = nodew + p;\n        const h = nodeh + p;\n        self.cellWidth = Math.max(self.cellWidth, w);\n        self.cellHeight = Math.max(self.cellHeight, h);\n      });\n    }\n\n    self.cellUsed = {}; // e.g. 'c-0-2' => true\n    // to keep track of current cell position\n\n    self.row = 0;\n    self.col = 0; // get a cache of all the manual positions\n\n    self.id2manPos = {};\n\n    for (let i = 0; i < layoutNodes.length; i++) {\n      const node = layoutNodes[i];\n      let rcPos;\n\n      if (self.position) {\n        rcPos = self.position(node);\n      }\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        const pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (pos.col === undefined) {\n          // find unused col\n          pos.col = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.col++;\n          }\n        } else if (pos.row === undefined) {\n          // find unused row\n          pos.row = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.row++;\n          }\n        }\n\n        self.id2manPos[node.id] = pos;\n        self.use(pos.row, pos.col);\n      }\n\n      self.getPos(node);\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      edges,\n      nodes: layoutNodes\n    };\n  }\n\n  small(val) {\n    const self = this;\n    let res;\n    const rows = self.rows || 5;\n    const cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.min(rows, cols);\n    } else {\n      const min = Math.min(rows, cols);\n\n      if (min === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  }\n\n  large(val) {\n    const self = this;\n    let res;\n    const rows = self.rows || 5;\n    const cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.max(rows, cols);\n    } else {\n      const max = Math.max(rows, cols);\n\n      if (max === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  }\n\n  used(row, col) {\n    const self = this;\n    return self.cellUsed[`c-${row}-${col}`] || false;\n  }\n\n  use(row, col) {\n    const self = this;\n    self.cellUsed[`c-${row}-${col}`] = true;\n  }\n\n  moveToNextCell() {\n    const self = this;\n    const cols = self.cols || 5;\n    self.col++;\n\n    if (self.col >= cols) {\n      self.col = 0;\n      self.row++;\n    }\n  }\n\n  getPos(node) {\n    const self = this;\n    const begin = self.begin;\n    const cellWidth = self.cellWidth;\n    const cellHeight = self.cellHeight;\n    let x;\n    let y; // see if we have a manual position set\n\n    const rcPos = self.id2manPos[node.id];\n\n    if (rcPos) {\n      x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n      y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n    } else {\n      // otherwise set automatically\n      while (self.used(self.row, self.col)) {\n        self.moveToNextCell();\n      }\n\n      x = self.col * cellWidth + cellWidth / 2 + begin[0];\n      y = self.row * cellHeight + cellHeight / 2 + begin[1];\n      self.use(self.row, self.col);\n      self.moveToNextCell();\n    }\n\n    node.x = x;\n    node.y = y;\n  }\n\n  getType() {\n    return \"grid\";\n  }\n\n}","map":{"version":3,"sources":["../../src/layout/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isNaN, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 网格布局\n */\nexport class GridLayout extends Base {\n    constructor(options) {\n        super();\n        /** 布局起始点 */\n        this.begin = [0, 0];\n        /** prevents node overlap, may overflow boundingBox if not enough space */\n        this.preventOverlap = true;\n        /** extra spacing around nodes when preventOverlap: true */\n        this.preventOverlapPadding = 10;\n        /** uses all available space on false, uses minimal space on true */\n        this.condense = false;\n        /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n        this.sortBy = \"degree\";\n        this.nodeSize = 30;\n        this.nodes = [];\n        this.edges = [];\n        this.width = 300;\n        this.height = 300;\n        this.row = 0;\n        this.col = 0;\n        this.cellWidth = 0;\n        this.cellHeight = 0;\n        this.cellUsed = {};\n        this.id2manPos = {};\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            begin: [0, 0],\n            preventOverlap: true,\n            preventOverlapPadding: 10,\n            condense: false,\n            rows: undefined,\n            cols: undefined,\n            position: undefined,\n            sortBy: \"degree\",\n            nodeSize: 30\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        const n = nodes.length;\n        const begin = self.begin;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return {\n                nodes,\n                edges\n            };\n        }\n        if (n === 1) {\n            nodes[0].x = begin[0];\n            nodes[0].y = begin[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return {\n                nodes,\n                edges,\n            };\n        }\n        const layoutNodes = [];\n        nodes.forEach((node) => {\n            layoutNodes.push(node);\n        });\n        const nodeIdxMap = {};\n        layoutNodes.forEach((node, i) => {\n            nodeIdxMap[node.id] = i;\n        });\n        if (self.sortBy === \"degree\" ||\n            !isString(self.sortBy) ||\n            layoutNodes[0][self.sortBy] === undefined) {\n            self.sortBy = \"degree\";\n            if (isNaN(nodes[0].degree)) {\n                const values = getDegree(layoutNodes.length, nodeIdxMap, edges);\n                layoutNodes.forEach((node, i) => {\n                    node.degree = values[i];\n                });\n            }\n        }\n        // sort nodes by value\n        layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        const oRows = self.rows;\n        const oCols = self.cols != null ? self.cols : self.columns;\n        self.cells = n;\n        // if rows or columns were set in self, use those values\n        if (oRows != null && oCols != null) {\n            self.rows = oRows;\n            self.cols = oCols;\n        }\n        else if (oRows != null && oCols == null) {\n            self.rows = oRows;\n            self.cols = Math.ceil(self.cells / self.rows);\n        }\n        else if (oRows == null && oCols != null) {\n            self.cols = oCols;\n            self.rows = Math.ceil(self.cells / self.cols);\n        }\n        else {\n            // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n            // width/height * splits^2 = cells where splits is number of times to split width\n            self.splits = Math.sqrt((self.cells * self.height) / self.width);\n            self.rows = Math.round(self.splits);\n            self.cols = Math.round((self.width / self.height) * self.splits);\n        }\n        if (self.cols * self.rows > self.cells) {\n            // otherwise use the automatic values and adjust accordingly\n            // if rounding was up, see if we can reduce rows or columns\n            const sm = self.small();\n            const lg = self.large();\n            // reducing the small side takes away the most cells, so try it first\n            if ((sm - 1) * lg >= self.cells) {\n                self.small(sm - 1);\n            }\n            else if ((lg - 1) * sm >= self.cells) {\n                self.large(lg - 1);\n            }\n        }\n        else {\n            // if rounding was too low, add rows or columns\n            while (self.cols * self.rows < self.cells) {\n                const sm = self.small();\n                const lg = self.large();\n                // try to add to larger side first (adds less in multiplication)\n                if ((lg + 1) * sm >= self.cells) {\n                    self.large(lg + 1);\n                }\n                else {\n                    self.small(sm + 1);\n                }\n            }\n        }\n        self.cellWidth = self.width / self.cols;\n        self.cellHeight = self.height / self.rows;\n        if (self.condense) {\n            self.cellWidth = 0;\n            self.cellHeight = 0;\n        }\n        if (self.preventOverlap) {\n            layoutNodes.forEach((node) => {\n                if (!node.x || !node.y) {\n                    // for bb\n                    node.x = 0;\n                    node.y = 0;\n                }\n                let nodew;\n                let nodeh;\n                if (isArray(node.size)) {\n                    nodew = node.size[0];\n                    nodeh = node.size[1];\n                }\n                else if (isNumber(node.size)) {\n                    nodew = node.size;\n                    nodeh = node.size;\n                }\n                else if (isObject(node.size)) {\n                    nodew = node.size.width;\n                    nodeh = node.size.height;\n                }\n                if (nodew === undefined || nodeh === undefined) {\n                    if (isArray(self.nodeSize)) {\n                        nodew = self.nodeSize[0];\n                        nodeh = self.nodeSize[1];\n                    }\n                    else if (isNumber(self.nodeSize)) {\n                        nodew = self.nodeSize;\n                        nodeh = self.nodeSize;\n                    }\n                    else {\n                        nodew = 30;\n                        nodeh = 30;\n                    }\n                }\n                const p = self.preventOverlapPadding;\n                const w = nodew + p;\n                const h = nodeh + p;\n                self.cellWidth = Math.max(self.cellWidth, w);\n                self.cellHeight = Math.max(self.cellHeight, h);\n            });\n        }\n        self.cellUsed = {}; // e.g. 'c-0-2' => true\n        // to keep track of current cell position\n        self.row = 0;\n        self.col = 0;\n        // get a cache of all the manual positions\n        self.id2manPos = {};\n        for (let i = 0; i < layoutNodes.length; i++) {\n            const node = layoutNodes[i];\n            let rcPos;\n            if (self.position) {\n                rcPos = self.position(node);\n            }\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                // must have at least row or col def'd\n                const pos = {\n                    row: rcPos.row,\n                    col: rcPos.col\n                };\n                if (pos.col === undefined) {\n                    // find unused col\n                    pos.col = 0;\n                    while (self.used(pos.row, pos.col)) {\n                        pos.col++;\n                    }\n                }\n                else if (pos.row === undefined) {\n                    // find unused row\n                    pos.row = 0;\n                    while (self.used(pos.row, pos.col)) {\n                        pos.row++;\n                    }\n                }\n                self.id2manPos[node.id] = pos;\n                self.use(pos.row, pos.col);\n            }\n            self.getPos(node);\n        }\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            edges,\n            nodes: layoutNodes\n        };\n    }\n    small(val) {\n        const self = this;\n        let res;\n        const rows = self.rows || 5;\n        const cols = self.cols || 5;\n        if (val == null) {\n            res = Math.min(rows, cols);\n        }\n        else {\n            const min = Math.min(rows, cols);\n            if (min === self.rows) {\n                self.rows = val;\n            }\n            else {\n                self.cols = val;\n            }\n        }\n        return res;\n    }\n    large(val) {\n        const self = this;\n        let res;\n        const rows = self.rows || 5;\n        const cols = self.cols || 5;\n        if (val == null) {\n            res = Math.max(rows, cols);\n        }\n        else {\n            const max = Math.max(rows, cols);\n            if (max === self.rows) {\n                self.rows = val;\n            }\n            else {\n                self.cols = val;\n            }\n        }\n        return res;\n    }\n    used(row, col) {\n        const self = this;\n        return self.cellUsed[`c-${row}-${col}`] || false;\n    }\n    use(row, col) {\n        const self = this;\n        self.cellUsed[`c-${row}-${col}`] = true;\n    }\n    moveToNextCell() {\n        const self = this;\n        const cols = self.cols || 5;\n        self.col++;\n        if (self.col >= cols) {\n            self.col = 0;\n            self.row++;\n        }\n    }\n    getPos(node) {\n        const self = this;\n        const begin = self.begin;\n        const cellWidth = self.cellWidth;\n        const cellHeight = self.cellHeight;\n        let x;\n        let y;\n        // see if we have a manual position set\n        const rcPos = self.id2manPos[node.id];\n        if (rcPos) {\n            x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n            y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n        }\n        else {\n            // otherwise set automatically\n            while (self.used(self.row, self.col)) {\n                self.moveToNextCell();\n            }\n            x = self.col * cellWidth + cellWidth / 2 + begin[0];\n            y = self.row * cellHeight + cellHeight / 2 + begin[1];\n            self.use(self.row, self.col);\n            self.moveToNextCell();\n        }\n        node.x = x;\n        node.y = y;\n    }\n    getType() {\n        return \"grid\";\n    }\n}\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}