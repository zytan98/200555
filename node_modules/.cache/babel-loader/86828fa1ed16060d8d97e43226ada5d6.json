{"ast":null,"code":"import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default labelPropagation;","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/algorithm/es/label-propagation.js"],"names":["getAdjMatrix","uniqueId","labelPropagation","graphData","directed","weightPropertyName","maxIteration","_a","nodes","_b","edges","clusters","nodeMap","forEach","node","i","cid","clusterId","id","idx","adjMatrix","ks","neighbors","row","k","iid","entry","j","jid","push","iter","_loop_1","changed","neighborClusters","Object","keys","neighborId","neighborWeight","neighborNode","neighborClusterId","maxWeight","Infinity","bestClusterIds","length","selfClusterIdx","indexOf","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","Math","floor","random","bestCluster","state_1","cluster","clusterEdges","clusterEdgeMap","edge","source","target","weight","sourceClusterId","targetClusterId","newEdgeId","count","newEdge","clustersArray"],"mappings":"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","sourcesContent":["import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default labelPropagation;"]},"metadata":{},"sourceType":"module"}