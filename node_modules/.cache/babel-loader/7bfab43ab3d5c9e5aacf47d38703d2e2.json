{"ast":null,"code":"/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getEdgeTerminal } from \"../util\";\n/**\n * force layout for graph with combos\n */\n\nexport class ComboForceLayout extends Base {\n  constructor(options) {\n    super();\n    /** 布局中心 */\n\n    this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    this.maxIteration = 100;\n    /** 重力大小，影响图的紧凑程度 */\n\n    this.gravity = 10;\n    /** 群组中心力大小 */\n\n    this.comboGravity = 10;\n    /** 默认边长度 */\n\n    this.linkDistance = 10;\n    /** 每次迭代位移的衰减相关参数 */\n\n    this.alpha = 1;\n    this.alphaMin = 0.001;\n    this.alphaDecay = 1 - Math.pow(this.alphaMin, 1 / 300);\n    this.alphaTarget = 0;\n    /** 节点运动速度衰减参数 */\n\n    this.velocityDecay = 0.6;\n    /** 边引力大小 */\n\n    this.edgeStrength = 0.6;\n    /** 节点引力大小 */\n\n    this.nodeStrength = 30;\n    /** 是否开启防止重叠 */\n\n    this.preventOverlap = false;\n    /** 是否开启节点之间的防止重叠 */\n\n    this.preventNodeOverlap = false;\n    /** 是否开启 Combo 之间的防止重叠 */\n\n    this.preventComboOverlap = false;\n    /** 防止重叠的碰撞力大小 */\n\n    this.collideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    this.nodeCollideStrength = 0.5;\n    /** 防止重叠的碰撞力大小 */\n\n    this.comboCollideStrength = 0.5;\n    /** Combo 最小间距，防止重叠时的间隙 */\n\n    this.comboSpacing = 20;\n    /** Combo 内部的 padding */\n\n    this.comboPadding = 10;\n    /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n\n    this.optimizeRangeFactor = 1;\n    /** 每次迭代的回调函数 */\n\n    this.onTick = () => {};\n    /** 迭代结束的回调函数 */\n\n\n    this.onLayoutEnd = () => {};\n    /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n\n\n    this.depthAttractiveForceScale = 1;\n    /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n\n    this.depthRepulsiveForceScale = 2;\n    /** 内部计算参数 */\n\n    this.nodes = [];\n    this.edges = [];\n    this.combos = [];\n    this.comboTrees = [];\n    this.width = 300;\n    this.height = 300;\n    this.bias = [];\n    this.nodeMap = {};\n    this.oriComboMap = {};\n    this.indexMap = {};\n    this.comboMap = {};\n    this.previousLayouted = false;\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      maxIteration: 100,\n      center: [0, 0],\n      gravity: 10,\n      speed: 1,\n      comboGravity: 30,\n      preventOverlap: false,\n      preventComboOverlap: true,\n      preventNodeOverlap: true,\n      nodeSpacing: undefined,\n      collideStrength: undefined,\n      nodeCollideStrength: 0.5,\n      comboCollideStrength: 0.5,\n      comboSpacing: 20,\n      comboPadding: 10,\n      edgeStrength: 0.6,\n      nodeStrength: 30,\n      linkDistance: 10\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n    self.comboTree = {\n      id: \"comboTreeRoot\",\n      depth: -1,\n      children: self.comboTrees\n    };\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    self.initVals(); // layout\n\n    self.run();\n    if (self.onLayoutEnd) self.onLayoutEnd();\n  }\n\n  run() {\n    const self = this;\n    const nodes = self.nodes;\n    const maxIteration = self.previousLayouted ? self.maxIteration / 5 : self.maxIteration;\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    const center = self.center;\n    const velocityDecay = self.velocityDecay; // init the positions to make the nodes with same combo gather around the combo\n\n    const comboMap = self.comboMap;\n    if (!self.previousLayouted) self.initPos(comboMap); // iterate\n\n    for (let i = 0; i < maxIteration; i++) {\n      const displacements = [];\n      nodes.forEach((_, j) => {\n        displacements[j] = {\n          x: 0,\n          y: 0\n        };\n      });\n      self.applyCalculate(displacements); // gravity for combos\n\n      self.applyComboCenterForce(displacements); // move\n\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        n.x += displacements[j].x * velocityDecay;\n        n.y += displacements[j].y * velocityDecay;\n      });\n      self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n      self.onTick();\n    } // move to center\n\n\n    const meanCenter = [0, 0];\n    nodes.forEach(n => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      meanCenter[0] += n.x;\n      meanCenter[1] += n.y;\n    });\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n    const centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n    nodes.forEach((n, j) => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      n.x += centerOffset[0];\n      n.y += centerOffset[1];\n    }); // arrange the empty combo\n\n    self.combos.forEach(combo => {\n      const mapped = comboMap[combo.id];\n\n      if (mapped && mapped.empty) {\n        combo.x = mapped.cx || combo.x;\n        combo.y = mapped.cy || combo.y;\n      }\n    });\n    self.previousLayouted = true;\n  }\n\n  initVals() {\n    const self = this;\n    const edges = self.edges;\n    const nodes = self.nodes;\n    const combos = self.combos;\n    const count = {};\n    const nodeMap = {};\n    const indexMap = {};\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.indexMap = indexMap;\n    const oriComboMap = {};\n    combos.forEach(combo => {\n      oriComboMap[combo.id] = combo;\n    });\n    self.oriComboMap = oriComboMap;\n    self.comboMap = self.getComboMap();\n    const preventOverlap = self.preventOverlap;\n    self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n    self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n    const collideStrength = self.collideStrength;\n\n    if (collideStrength) {\n      self.comboCollideStrength = collideStrength;\n      self.nodeCollideStrength = collideStrength;\n    }\n\n    self.comboCollideStrength = self.comboCollideStrength ? self.comboCollideStrength : 0;\n    self.nodeCollideStrength = self.nodeCollideStrength ? self.nodeCollideStrength : 0; // get edge bias\n\n    for (let i = 0; i < edges.length; ++i) {\n      const source = getEdgeTerminal(edges[i], 'source');\n      const target = getEdgeTerminal(edges[i], 'target');\n      if (count[source]) count[source]++;else count[source] = 1;\n      if (count[target]) count[target]++;else count[target] = 1;\n    }\n\n    const bias = [];\n\n    for (let i = 0; i < edges.length; ++i) {\n      const source = getEdgeTerminal(edges[i], 'source');\n      const target = getEdgeTerminal(edges[i], 'target');\n      bias[i] = count[source] / (count[source] + count[target]);\n    }\n\n    this.bias = bias;\n    const nodeSize = self.nodeSize;\n    const nodeSpacing = self.nodeSpacing;\n    let nodeSizeFunc;\n    let nodeSpacingFunc; // nodeSpacing to function\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = () => nodeSpacing;\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = () => 0;\n    }\n\n    this.nodeSpacing = nodeSpacingFunc; // nodeSize to function\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2;\n          }\n\n          if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2;\n          }\n\n          return d.size / 2;\n        }\n\n        return 10;\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = d => {\n        return nodeSize(d);\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n\n      nodeSizeFunc = d => radius;\n    } else {\n      // number type\n      const radius = nodeSize / 2;\n\n      nodeSizeFunc = d => radius;\n    }\n\n    this.nodeSize = nodeSizeFunc; // comboSpacing to function\n\n    const comboSpacing = self.comboSpacing;\n    let comboSpacingFunc;\n\n    if (isNumber(comboSpacing)) {\n      comboSpacingFunc = () => comboSpacing;\n    } else if (isFunction(comboSpacing)) {\n      comboSpacingFunc = comboSpacing;\n    } else {\n      // null type\n      comboSpacingFunc = () => 0;\n    }\n\n    this.comboSpacing = comboSpacingFunc; // comboPadding to function\n\n    const comboPadding = self.comboPadding;\n    let comboPaddingFunc;\n\n    if (isNumber(comboPadding)) {\n      comboPaddingFunc = () => comboPadding;\n    } else if (isArray(comboPadding)) {\n      comboPaddingFunc = () => Math.max.apply(null, comboPadding);\n    } else if (isFunction(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = () => 0;\n    }\n\n    this.comboPadding = comboPaddingFunc; // linkDistance to function\n\n    let linkDistance = this.linkDistance;\n    let linkDistanceFunc;\n\n    if (!linkDistance) {\n      linkDistance = 10;\n    }\n\n    if (isNumber(linkDistance)) {\n      linkDistanceFunc = d => {\n        return linkDistance;\n      };\n    } else {\n      linkDistanceFunc = linkDistance;\n    }\n\n    this.linkDistance = linkDistanceFunc; // linkStrength to function\n\n    let edgeStrength = this.edgeStrength;\n    let edgeStrengthFunc;\n\n    if (!edgeStrength) {\n      edgeStrength = 1;\n    }\n\n    if (isNumber(edgeStrength)) {\n      edgeStrengthFunc = d => {\n        return edgeStrength;\n      };\n    } else {\n      edgeStrengthFunc = edgeStrength;\n    }\n\n    this.edgeStrength = edgeStrengthFunc; // nodeStrength to function\n\n    let nodeStrength = this.nodeStrength;\n    let nodeStrengthFunc;\n\n    if (!nodeStrength) {\n      nodeStrength = 30;\n    }\n\n    if (isNumber(nodeStrength)) {\n      nodeStrengthFunc = d => {\n        return nodeStrength;\n      };\n    } else {\n      nodeStrengthFunc = nodeStrength;\n    }\n\n    this.nodeStrength = nodeStrengthFunc;\n  }\n\n  initPos(comboMap) {\n    const self = this;\n    const nodes = self.nodes;\n    nodes.forEach((node, i) => {\n      const comboId = node.comboId;\n      const combo = comboMap[comboId];\n\n      if (comboId && combo) {\n        node.x = combo.cx + 100 / (i + 1);\n        node.y = combo.cy + 100 / (i + 1);\n      } else {\n        node.x = 100 / (i + 1);\n        node.y = 100 / (i + 1);\n      }\n    });\n  }\n\n  getComboMap() {\n    const self = this;\n    const nodeMap = self.nodeMap;\n    const indexMap = self.indexMap;\n    const comboTrees = self.comboTrees;\n    const oriComboMap = self.oriComboMap;\n    const comboMap = {};\n    (comboTrees || []).forEach(ctree => {\n      const treeChildren = [];\n      traverseTreeUp(ctree, treeNode => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n\n        if (comboMap[treeNode.id] === undefined) {\n          const combo = {\n            id: treeNode.id,\n            name: treeNode.id,\n            cx: 0,\n            cy: 0,\n            count: 0,\n            depth: self.oriComboMap[treeNode.id].depth || 0,\n            children: []\n          };\n          comboMap[treeNode.id] = combo;\n        }\n\n        const children = treeNode.children;\n\n        if (children) {\n          children.forEach(child => {\n            if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n\n            treeChildren.push(child);\n          });\n        }\n\n        const c = comboMap[treeNode.id];\n        c.cx = 0;\n        c.cy = 0; // In order to layout the empty combo, add a virtual node to it\n\n        if (treeChildren.length === 0) {\n          c.empty = true;\n          const oriCombo = oriComboMap[treeNode.id];\n          const idx = Object.keys(nodeMap).length;\n          const virtualNodeId = `${treeNode.id}-visual-child-${idx}`;\n          const vnode = {\n            id: virtualNodeId,\n            x: oriCombo.x,\n            y: oriCombo.y,\n            depth: c.depth + 1,\n            itemType: \"node\"\n          };\n          self.nodes.push(vnode);\n          nodeMap[virtualNodeId] = vnode;\n          indexMap[virtualNodeId] = idx;\n          c.cx = oriCombo.x;\n          c.cy = oriCombo.y;\n          treeChildren.push(vnode);\n        }\n\n        treeChildren.forEach(child => {\n          c.count++;\n\n          if (child.itemType !== \"node\") {\n            const childCombo = comboMap[child.id];\n            if (isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          const node = nodeMap[child.id]; // means the node is hidden, skip it\n\n          if (!node) return;\n\n          if (isNumber(node.x)) {\n            c.cx += node.x;\n          }\n\n          if (isNumber(node.y)) {\n            c.cy += node.y;\n          }\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        c.children = treeChildren;\n        return true;\n      });\n    });\n    return comboMap;\n  }\n\n  applyComboCenterForce(displacements) {\n    const self = this;\n    const gravity = self.gravity;\n    const comboGravity = self.comboGravity || gravity;\n    const alpha = this.alpha;\n    const comboTrees = self.comboTrees;\n    const indexMap = self.indexMap;\n    const nodeMap = self.nodeMap;\n    const comboMap = self.comboMap;\n    (comboTrees || []).forEach(ctree => {\n      traverseTreeUp(ctree, treeNode => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        const combo = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!combo) return true;\n        const c = comboMap[treeNode.id]; // higher depth the combo, larger the gravity\n\n        const gravityScale = (c.depth + 1) / 10 * 0.5; // apply combo center force for all the descend nodes in this combo\n        // and update the center position and count for this combo\n\n        const comboX = c.cx;\n        const comboY = c.cy;\n        c.cx = 0;\n        c.cy = 0;\n        c.children.forEach(child => {\n          if (child.itemType !== \"node\") {\n            const childCombo = comboMap[child.id];\n            if (childCombo && isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (childCombo && isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          const node = nodeMap[child.id];\n          const vecX = node.x - comboX || 0.005;\n          const vecY = node.y - comboY || 0.005;\n          const l = Math.sqrt(vecX * vecX + vecY * vecY);\n          const childIdx = indexMap[node.id];\n          const params = comboGravity * alpha / l * gravityScale;\n          displacements[childIdx].x -= vecX * params;\n          displacements[childIdx].y -= vecY * params;\n          if (isNumber(node.x)) c.cx += node.x;\n          if (isNumber(node.y)) c.cy += node.y;\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        return true;\n      });\n    });\n  }\n\n  applyCalculate(displacements) {\n    const self = this;\n    const comboMap = self.comboMap;\n    const nodes = self.nodes; // store the vx, vy, and distance to reduce dulplicate calculation\n\n    const vecMap = {};\n    nodes.forEach((v, i) => {\n      nodes.forEach((u, j) => {\n        if (i < j) return;\n        const vx = v.x - u.x || 0.005;\n        const vy = v.y - u.y || 0.005;\n        let vl2 = vx * vx + vy * vy;\n        const vl = Math.sqrt(vl2);\n        if (vl2 < 1) vl2 = vl;\n        vecMap[`${v.id}-${u.id}`] = {\n          vx,\n          vy,\n          vl2,\n          vl\n        };\n        vecMap[`${u.id}-${v.id}`] = {\n          vl2,\n          vl,\n          vx: -vx,\n          vy: -vy\n        };\n      });\n    }); // get the sizes of the combos\n\n    self.updateComboSizes(comboMap);\n    self.calRepulsive(displacements, vecMap);\n    self.calAttractive(displacements, vecMap);\n    const preventComboOverlap = self.preventComboOverlap;\n    if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n  }\n  /**\n   * Update the sizes of the combos according to their children\n   * Used for combos nonoverlap, but not re-render the combo shapes\n   */\n\n\n  updateComboSizes(comboMap) {\n    const self = this;\n    const comboTrees = self.comboTrees;\n    const nodeMap = self.nodeMap;\n    const nodeSize = self.nodeSize;\n    const comboSpacing = self.comboSpacing;\n    const comboPadding = self.comboPadding;\n    (comboTrees || []).forEach(ctree => {\n      const treeChildren = [];\n      traverseTreeUp(ctree, treeNode => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n\n        const c = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!c) return false;\n        const children = treeNode.children;\n\n        if (children) {\n          children.forEach(child => {\n            // means the combo is hidden.\n            if (!comboMap[child.id] && !nodeMap[child.id]) return;\n            treeChildren.push(child);\n          });\n        }\n\n        c.minX = Infinity;\n        c.minY = Infinity;\n        c.maxX = -Infinity;\n        c.maxY = -Infinity;\n        treeChildren.forEach(child => {\n          if (child.itemType !== \"node\") return true; // skip it\n\n          const node = nodeMap[child.id];\n          if (!node) return true; // means it is hidden\n\n          const r = nodeSize(node);\n          const nodeMinX = node.x - r;\n          const nodeMinY = node.y - r;\n          const nodeMaxX = node.x + r;\n          const nodeMaxY = node.y + r;\n          if (c.minX > nodeMinX) c.minX = nodeMinX;\n          if (c.minY > nodeMinY) c.minY = nodeMinY;\n          if (c.maxX < nodeMaxX) c.maxX = nodeMaxX;\n          if (c.maxY < nodeMaxY) c.maxY = nodeMaxY;\n        });\n        let minSize = self.oriComboMap[treeNode.id].size || 10;\n        if (isArray(minSize)) minSize = minSize[0];\n        const maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n        c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n        return true;\n      });\n    });\n  }\n  /**\n   * prevent the overlappings among combos\n   */\n\n\n  comboNonOverlapping(displacements, comboMap) {\n    const self = this;\n    const comboTree = self.comboTree;\n    const comboCollideStrength = self.comboCollideStrength;\n    const indexMap = self.indexMap;\n    const nodeMap = self.nodeMap;\n    traverseTreeUp(comboTree, treeNode => {\n      if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== \"comboTreeRoot\") {\n        return false;\n      } // means it is hidden\n\n\n      const children = treeNode.children; // 同个子树下的子 combo 间两两对比\n\n      if (children && children.length > 1) {\n        children.forEach((v, i) => {\n          if (v.itemType === \"node\") return false; // skip it\n\n          const cv = comboMap[v.id];\n          if (!cv) return; // means it is hidden, skip it\n\n          children.forEach((u, j) => {\n            if (i <= j) return false;\n            if (u.itemType === \"node\") return false; // skip it\n\n            const cu = comboMap[u.id];\n            if (!cu) return false; // means it is hidden, skip it\n\n            const vx = cv.cx - cu.cx || 0.005;\n            const vy = cv.cy - cu.cy || 0.005;\n            const l = vx * vx + vy * vy;\n            const rv = cv.r || 1;\n            const ru = cu.r || 1;\n            const r = rv + ru;\n            const ru2 = ru * ru;\n            const rv2 = rv * rv; // overlapping\n\n            if (l < r * r) {\n              const vnodes = v.children;\n              if (!vnodes || vnodes.length === 0) return false; // skip it\n\n              const unodes = u.children;\n              if (!unodes || unodes.length === 0) return false; // skip it\n\n              const sqrtl = Math.sqrt(l);\n              const ll = (r - sqrtl) / sqrtl * comboCollideStrength;\n              const xl = vx * ll;\n              const yl = vy * ll;\n              const rratio = ru2 / (rv2 + ru2);\n              const irratio = 1 - rratio; // 两兄弟 combo 的子节点上施加斥力\n\n              vnodes.forEach(vn => {\n                if (vn.itemType !== \"node\") return false; // skip it\n\n                if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n\n                const vindex = indexMap[vn.id];\n                unodes.forEach(un => {\n                  if (un.itemType !== \"node\") return false;\n                  if (!nodeMap[un.id]) return false; // means it is hidden, skip it\n\n                  const uindex = indexMap[un.id];\n                  displacements[vindex].x += xl * rratio;\n                  displacements[vindex].y += yl * rratio;\n                  displacements[uindex].x -= xl * irratio;\n                  displacements[uindex].y -= yl * irratio;\n                });\n              });\n            }\n          });\n        });\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Calculate the repulsive force between each node pair\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  calRepulsive(displacements, vecMap) {\n    const self = this;\n    const nodes = self.nodes;\n    const max = self.width * self.optimizeRangeFactor;\n    const nodeStrength = self.nodeStrength;\n    const alpha = self.alpha;\n    const nodeCollideStrength = self.nodeCollideStrength;\n    const preventNodeOverlap = self.preventNodeOverlap;\n    const nodeSizeFunc = self.nodeSize;\n    const nodeSpacingFunc = self.nodeSpacing;\n    const scale = self.depthRepulsiveForceScale;\n    const center = self.center;\n    nodes.forEach((v, i) => {\n      if (!v.x || !v.y) return; // center gravity\n\n      if (center) {\n        const gravity = self.gravity;\n        const vecX = v.x - center[0] || 0.005;\n        const vecY = v.y - center[1] || 0.005;\n        const l = Math.sqrt(vecX * vecX + vecY * vecY);\n        displacements[i].x -= vecX * gravity * alpha / l;\n        displacements[i].y -= vecY * gravity * alpha / l;\n      }\n\n      nodes.forEach((u, j) => {\n        if (i === j) {\n          return;\n        }\n\n        if (!u.x || !u.y) return;\n        const {\n          vl2,\n          vl\n        } = vecMap[`${v.id}-${u.id}`];\n        if (vl > max) return;\n        const {\n          vx,\n          vy\n        } = vecMap[`${v.id}-${u.id}`];\n        let depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n        depthDiff = depthDiff < 1 ? 1 : depthDiff;\n        if (u.comboId !== v.comboId) depthDiff += 1;\n        const depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n        const params = nodeStrength(u) * alpha / vl2 * depthParam;\n        displacements[i].x += vx * params;\n        displacements[i].y += vy * params; // prevent node overlappings\n\n        if (i < j && preventNodeOverlap) {\n          const ri = nodeSizeFunc(v) + nodeSpacingFunc(v) || 1;\n          const rj = nodeSizeFunc(u) + nodeSpacingFunc(u) || 1;\n          const r = ri + rj;\n\n          if (vl2 < r * r) {\n            const ll = (r - vl) / vl * nodeCollideStrength;\n            const rj2 = rj * rj;\n            let rratio = rj2 / (ri * ri + rj2);\n            const xl = vx * ll;\n            const yl = vy * ll;\n            displacements[i].x += xl * rratio;\n            displacements[i].y += yl * rratio;\n            rratio = 1 - rratio;\n            displacements[j].x -= xl * rratio;\n            displacements[j].y -= yl * rratio;\n          }\n        }\n      });\n    });\n  }\n  /**\n   * Calculate the attractive force between the node pair with edge\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  calAttractive(displacements, vecMap) {\n    const self = this;\n    const edges = self.edges;\n    const linkDistance = self.linkDistance;\n    const alpha = self.alpha;\n    const edgeStrength = self.edgeStrength;\n    const bias = self.bias;\n    const scale = self.depthAttractiveForceScale;\n    edges.forEach((e, i) => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      if (!source || !target || source === target) return;\n      const uIndex = self.indexMap[source];\n      const vIndex = self.indexMap[target];\n      const u = self.nodeMap[source];\n      const v = self.nodeMap[target];\n      if (!u || !v) return;\n      let depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n\n      if (u.comboId === v.comboId) {\n        depthDiff = depthDiff / 2;\n      }\n\n      let depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n\n      if (u.comboId !== v.comboId && depthParam === 1) {\n        depthParam = scale / 2;\n      } else if (u.comboId === v.comboId) {\n        depthParam = 2;\n      }\n\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n        return;\n      }\n\n      const {\n        vl,\n        vx,\n        vy\n      } = vecMap[`${target}-${source}`];\n      const l = (vl - linkDistance(e)) / vl * alpha * edgeStrength(e) * depthParam;\n      const vecX = vx * l;\n      const vecY = vy * l;\n      const b = bias[i];\n      displacements[vIndex].x -= vecX * b;\n      displacements[vIndex].y -= vecY * b;\n      displacements[uIndex].x += vecX * (1 - b);\n      displacements[uIndex].y += vecY * (1 - b);\n    });\n  }\n\n  getType() {\n    return \"comboForce\";\n  }\n\n}","map":{"version":3,"sources":["../../src/layout/comboForce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getEdgeTerminal } from \"../util\";\n/**\n * force layout for graph with combos\n */\nexport class ComboForceLayout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 停止迭代的最大迭代数 */\n        this.maxIteration = 100;\n        /** 重力大小，影响图的紧凑程度 */\n        this.gravity = 10;\n        /** 群组中心力大小 */\n        this.comboGravity = 10;\n        /** 默认边长度 */\n        this.linkDistance = 10;\n        /** 每次迭代位移的衰减相关参数 */\n        this.alpha = 1;\n        this.alphaMin = 0.001;\n        this.alphaDecay = 1 - Math.pow(this.alphaMin, (1 / 300));\n        this.alphaTarget = 0;\n        /** 节点运动速度衰减参数 */\n        this.velocityDecay = 0.6;\n        /** 边引力大小 */\n        this.edgeStrength = 0.6;\n        /** 节点引力大小 */\n        this.nodeStrength = 30;\n        /** 是否开启防止重叠 */\n        this.preventOverlap = false;\n        /** 是否开启节点之间的防止重叠 */\n        this.preventNodeOverlap = false;\n        /** 是否开启 Combo 之间的防止重叠 */\n        this.preventComboOverlap = false;\n        /** 防止重叠的碰撞力大小 */\n        this.collideStrength = undefined;\n        /** 防止重叠的碰撞力大小 */\n        this.nodeCollideStrength = 0.5;\n        /** 防止重叠的碰撞力大小 */\n        this.comboCollideStrength = 0.5;\n        /** Combo 最小间距，防止重叠时的间隙 */\n        this.comboSpacing = 20;\n        /** Combo 内部的 padding */\n        this.comboPadding = 10;\n        /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n        this.optimizeRangeFactor = 1;\n        /** 每次迭代的回调函数 */\n        this.onTick = () => { };\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n        this.depthAttractiveForceScale = 1;\n        /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n        this.depthRepulsiveForceScale = 2;\n        /** 内部计算参数 */\n        this.nodes = [];\n        this.edges = [];\n        this.combos = [];\n        this.comboTrees = [];\n        this.width = 300;\n        this.height = 300;\n        this.bias = [];\n        this.nodeMap = {};\n        this.oriComboMap = {};\n        this.indexMap = {};\n        this.comboMap = {};\n        this.previousLayouted = false;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            maxIteration: 100,\n            center: [0, 0],\n            gravity: 10,\n            speed: 1,\n            comboGravity: 30,\n            preventOverlap: false,\n            preventComboOverlap: true,\n            preventNodeOverlap: true,\n            nodeSpacing: undefined,\n            collideStrength: undefined,\n            nodeCollideStrength: 0.5,\n            comboCollideStrength: 0.5,\n            comboSpacing: 20,\n            comboPadding: 10,\n            edgeStrength: 0.6,\n            nodeStrength: 30,\n            linkDistance: 10\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        const center = self.center;\n        self.comboTree = {\n            id: \"comboTreeRoot\",\n            depth: -1,\n            children: self.comboTrees\n        };\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        self.initVals();\n        // layout\n        self.run();\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n    }\n    run() {\n        const self = this;\n        const nodes = self.nodes;\n        const maxIteration = self.previousLayouted\n            ? self.maxIteration / 5\n            : self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        const center = self.center;\n        const velocityDecay = self.velocityDecay;\n        // init the positions to make the nodes with same combo gather around the combo\n        const comboMap = self.comboMap;\n        if (!self.previousLayouted)\n            self.initPos(comboMap);\n        // iterate\n        for (let i = 0; i < maxIteration; i++) {\n            const displacements = [];\n            nodes.forEach((_, j) => {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(displacements);\n            // gravity for combos\n            self.applyComboCenterForce(displacements);\n            // move\n            nodes.forEach((n, j) => {\n                if (!isNumber(n.x) || !isNumber(n.y))\n                    return;\n                n.x += displacements[j].x * velocityDecay;\n                n.y += displacements[j].y * velocityDecay;\n            });\n            self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n            self.onTick();\n        }\n        // move to center\n        const meanCenter = [0, 0];\n        nodes.forEach((n) => {\n            if (!isNumber(n.x) || !isNumber(n.y))\n                return;\n            meanCenter[0] += n.x;\n            meanCenter[1] += n.y;\n        });\n        meanCenter[0] /= nodes.length;\n        meanCenter[1] /= nodes.length;\n        const centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n        nodes.forEach((n, j) => {\n            if (!isNumber(n.x) || !isNumber(n.y))\n                return;\n            n.x += centerOffset[0];\n            n.y += centerOffset[1];\n        });\n        // arrange the empty combo\n        self.combos.forEach((combo) => {\n            const mapped = comboMap[combo.id];\n            if (mapped && mapped.empty) {\n                combo.x = mapped.cx || combo.x;\n                combo.y = mapped.cy || combo.y;\n            }\n        });\n        self.previousLayouted = true;\n    }\n    initVals() {\n        const self = this;\n        const edges = self.edges;\n        const nodes = self.nodes;\n        const combos = self.combos;\n        const count = {};\n        const nodeMap = {};\n        const indexMap = {};\n        nodes.forEach((node, i) => {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.indexMap = indexMap;\n        const oriComboMap = {};\n        combos.forEach((combo) => {\n            oriComboMap[combo.id] = combo;\n        });\n        self.oriComboMap = oriComboMap;\n        self.comboMap = self.getComboMap();\n        const preventOverlap = self.preventOverlap;\n        self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n        self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n        const collideStrength = self.collideStrength;\n        if (collideStrength) {\n            self.comboCollideStrength = collideStrength;\n            self.nodeCollideStrength = collideStrength;\n        }\n        self.comboCollideStrength = self.comboCollideStrength\n            ? self.comboCollideStrength\n            : 0;\n        self.nodeCollideStrength = self.nodeCollideStrength\n            ? self.nodeCollideStrength\n            : 0;\n        // get edge bias\n        for (let i = 0; i < edges.length; ++i) {\n            const source = getEdgeTerminal(edges[i], 'source');\n            const target = getEdgeTerminal(edges[i], 'target');\n            if (count[source])\n                count[source]++;\n            else\n                count[source] = 1;\n            if (count[target])\n                count[target]++;\n            else\n                count[target] = 1;\n        }\n        const bias = [];\n        for (let i = 0; i < edges.length; ++i) {\n            const source = getEdgeTerminal(edges[i], 'source');\n            const target = getEdgeTerminal(edges[i], 'target');\n            bias[i] = count[source] / (count[source] + count[target]);\n        }\n        this.bias = bias;\n        const nodeSize = self.nodeSize;\n        const nodeSpacing = self.nodeSpacing;\n        let nodeSizeFunc;\n        let nodeSpacingFunc;\n        // nodeSpacing to function\n        if (isNumber(nodeSpacing)) {\n            nodeSpacingFunc = () => nodeSpacing;\n        }\n        else if (isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = () => 0;\n        }\n        this.nodeSpacing = nodeSpacingFunc;\n        // nodeSize to function\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2;\n                    }\n                    if (isObject(d.size)) {\n                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return res / 2;\n                    }\n                    return d.size / 2;\n                }\n                return 10;\n            };\n        }\n        else if (isFunction(nodeSize)) {\n            nodeSizeFunc = (d) => {\n                return nodeSize(d);\n            };\n        }\n        else if (isArray(nodeSize)) {\n            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            const radius = larger / 2;\n            nodeSizeFunc = (d) => radius;\n        }\n        else {\n            // number type\n            const radius = nodeSize / 2;\n            nodeSizeFunc = (d) => radius;\n        }\n        this.nodeSize = nodeSizeFunc;\n        // comboSpacing to function\n        const comboSpacing = self.comboSpacing;\n        let comboSpacingFunc;\n        if (isNumber(comboSpacing)) {\n            comboSpacingFunc = () => comboSpacing;\n        }\n        else if (isFunction(comboSpacing)) {\n            comboSpacingFunc = comboSpacing;\n        }\n        else {\n            // null type\n            comboSpacingFunc = () => 0;\n        }\n        this.comboSpacing = comboSpacingFunc;\n        // comboPadding to function\n        const comboPadding = self.comboPadding;\n        let comboPaddingFunc;\n        if (isNumber(comboPadding)) {\n            comboPaddingFunc = () => comboPadding;\n        }\n        else if (isArray(comboPadding)) {\n            comboPaddingFunc = () => Math.max.apply(null, comboPadding);\n        }\n        else if (isFunction(comboPadding)) {\n            comboPaddingFunc = comboPadding;\n        }\n        else {\n            // null type\n            comboPaddingFunc = () => 0;\n        }\n        this.comboPadding = comboPaddingFunc;\n        // linkDistance to function\n        let linkDistance = this.linkDistance;\n        let linkDistanceFunc;\n        if (!linkDistance) {\n            linkDistance = 10;\n        }\n        if (isNumber(linkDistance)) {\n            linkDistanceFunc = (d) => {\n                return linkDistance;\n            };\n        }\n        else {\n            linkDistanceFunc = linkDistance;\n        }\n        this.linkDistance = linkDistanceFunc;\n        // linkStrength to function\n        let edgeStrength = this.edgeStrength;\n        let edgeStrengthFunc;\n        if (!edgeStrength) {\n            edgeStrength = 1;\n        }\n        if (isNumber(edgeStrength)) {\n            edgeStrengthFunc = (d) => {\n                return edgeStrength;\n            };\n        }\n        else {\n            edgeStrengthFunc = edgeStrength;\n        }\n        this.edgeStrength = edgeStrengthFunc;\n        // nodeStrength to function\n        let nodeStrength = this.nodeStrength;\n        let nodeStrengthFunc;\n        if (!nodeStrength) {\n            nodeStrength = 30;\n        }\n        if (isNumber(nodeStrength)) {\n            nodeStrengthFunc = (d) => {\n                return nodeStrength;\n            };\n        }\n        else {\n            nodeStrengthFunc = nodeStrength;\n        }\n        this.nodeStrength = nodeStrengthFunc;\n    }\n    initPos(comboMap) {\n        const self = this;\n        const nodes = self.nodes;\n        nodes.forEach((node, i) => {\n            const comboId = node.comboId;\n            const combo = comboMap[comboId];\n            if (comboId && combo) {\n                node.x = combo.cx + 100 / (i + 1);\n                node.y = combo.cy + 100 / (i + 1);\n            }\n            else {\n                node.x = 100 / (i + 1);\n                node.y = 100 / (i + 1);\n            }\n        });\n    }\n    getComboMap() {\n        const self = this;\n        const nodeMap = self.nodeMap;\n        const indexMap = self.indexMap;\n        const comboTrees = self.comboTrees;\n        const oriComboMap = self.oriComboMap;\n        const comboMap = {};\n        (comboTrees || []).forEach((ctree) => {\n            const treeChildren = [];\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                if (!oriComboMap[treeNode.id])\n                    return true; // means it is hidden, skip it\n                if (comboMap[treeNode.id] === undefined) {\n                    const combo = {\n                        id: treeNode.id,\n                        name: treeNode.id,\n                        cx: 0,\n                        cy: 0,\n                        count: 0,\n                        depth: self.oriComboMap[treeNode.id].depth || 0,\n                        children: []\n                    };\n                    comboMap[treeNode.id] = combo;\n                }\n                const children = treeNode.children;\n                if (children) {\n                    children.forEach((child) => {\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return true; // means it is hidden\n                        treeChildren.push(child);\n                    });\n                }\n                const c = comboMap[treeNode.id];\n                c.cx = 0;\n                c.cy = 0;\n                // In order to layout the empty combo, add a virtual node to it\n                if (treeChildren.length === 0) {\n                    c.empty = true;\n                    const oriCombo = oriComboMap[treeNode.id];\n                    const idx = Object.keys(nodeMap).length;\n                    const virtualNodeId = `${treeNode.id}-visual-child-${idx}`;\n                    const vnode = {\n                        id: virtualNodeId,\n                        x: oriCombo.x,\n                        y: oriCombo.y,\n                        depth: c.depth + 1,\n                        itemType: \"node\"\n                    };\n                    self.nodes.push(vnode);\n                    nodeMap[virtualNodeId] = vnode;\n                    indexMap[virtualNodeId] = idx;\n                    c.cx = oriCombo.x;\n                    c.cy = oriCombo.y;\n                    treeChildren.push(vnode);\n                }\n                treeChildren.forEach((child) => {\n                    c.count++;\n                    if (child.itemType !== \"node\") {\n                        const childCombo = comboMap[child.id];\n                        if (isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    const node = nodeMap[child.id];\n                    // means the node is hidden, skip it\n                    if (!node)\n                        return;\n                    if (isNumber(node.x)) {\n                        c.cx += node.x;\n                    }\n                    if (isNumber(node.y)) {\n                        c.cy += node.y;\n                    }\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                c.children = treeChildren;\n                return true;\n            });\n        });\n        return comboMap;\n    }\n    applyComboCenterForce(displacements) {\n        const self = this;\n        const gravity = self.gravity;\n        const comboGravity = self.comboGravity || gravity;\n        const alpha = this.alpha;\n        const comboTrees = self.comboTrees;\n        const indexMap = self.indexMap;\n        const nodeMap = self.nodeMap;\n        const comboMap = self.comboMap;\n        (comboTrees || []).forEach((ctree) => {\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                const combo = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!combo)\n                    return true;\n                const c = comboMap[treeNode.id];\n                // higher depth the combo, larger the gravity\n                const gravityScale = ((c.depth + 1) / 10) * 0.5;\n                // apply combo center force for all the descend nodes in this combo\n                // and update the center position and count for this combo\n                const comboX = c.cx;\n                const comboY = c.cy;\n                c.cx = 0;\n                c.cy = 0;\n                c.children.forEach((child) => {\n                    if (child.itemType !== \"node\") {\n                        const childCombo = comboMap[child.id];\n                        if (childCombo && isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (childCombo && isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    const node = nodeMap[child.id];\n                    const vecX = (node.x - comboX) || 0.005;\n                    const vecY = (node.y - comboY) || 0.005;\n                    const l = Math.sqrt(vecX * vecX + vecY * vecY);\n                    const childIdx = indexMap[node.id];\n                    const params = ((comboGravity * alpha) / l) * gravityScale;\n                    displacements[childIdx].x -= vecX * params;\n                    displacements[childIdx].y -= vecY * params;\n                    if (isNumber(node.x))\n                        c.cx += node.x;\n                    if (isNumber(node.y))\n                        c.cy += node.y;\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                return true;\n            });\n        });\n    }\n    applyCalculate(displacements) {\n        const self = this;\n        const comboMap = self.comboMap;\n        const nodes = self.nodes;\n        // store the vx, vy, and distance to reduce dulplicate calculation\n        const vecMap = {};\n        nodes.forEach((v, i) => {\n            nodes.forEach((u, j) => {\n                if (i < j)\n                    return;\n                const vx = (v.x - u.x) || 0.005;\n                const vy = (v.y - u.y) || 0.005;\n                let vl2 = vx * vx + vy * vy;\n                const vl = Math.sqrt(vl2);\n                if (vl2 < 1)\n                    vl2 = vl;\n                vecMap[`${v.id}-${u.id}`] = { vx, vy, vl2, vl };\n                vecMap[`${u.id}-${v.id}`] = { vl2, vl, vx: -vx, vy: -vy };\n            });\n        });\n        // get the sizes of the combos\n        self.updateComboSizes(comboMap);\n        self.calRepulsive(displacements, vecMap);\n        self.calAttractive(displacements, vecMap);\n        const preventComboOverlap = self.preventComboOverlap;\n        if (preventComboOverlap)\n            self.comboNonOverlapping(displacements, comboMap);\n    }\n    /**\n     * Update the sizes of the combos according to their children\n     * Used for combos nonoverlap, but not re-render the combo shapes\n     */\n    updateComboSizes(comboMap) {\n        const self = this;\n        const comboTrees = self.comboTrees;\n        const nodeMap = self.nodeMap;\n        const nodeSize = self.nodeSize;\n        const comboSpacing = self.comboSpacing;\n        const comboPadding = self.comboPadding;\n        (comboTrees || []).forEach((ctree) => {\n            const treeChildren = [];\n            traverseTreeUp(ctree, (treeNode) => {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                const c = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!c)\n                    return false;\n                const children = treeNode.children;\n                if (children) {\n                    children.forEach((child) => {\n                        // means the combo is hidden.\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return;\n                        treeChildren.push(child);\n                    });\n                }\n                c.minX = Infinity;\n                c.minY = Infinity;\n                c.maxX = -Infinity;\n                c.maxY = -Infinity;\n                treeChildren.forEach((child) => {\n                    if (child.itemType !== \"node\")\n                        return true; // skip it\n                    const node = nodeMap[child.id];\n                    if (!node)\n                        return true; // means it is hidden\n                    const r = nodeSize(node);\n                    const nodeMinX = node.x - r;\n                    const nodeMinY = node.y - r;\n                    const nodeMaxX = node.x + r;\n                    const nodeMaxY = node.y + r;\n                    if (c.minX > nodeMinX)\n                        c.minX = nodeMinX;\n                    if (c.minY > nodeMinY)\n                        c.minY = nodeMinY;\n                    if (c.maxX < nodeMaxX)\n                        c.maxX = nodeMaxX;\n                    if (c.maxY < nodeMaxY)\n                        c.maxY = nodeMaxY;\n                });\n                let minSize = self.oriComboMap[treeNode.id].size || 10;\n                if (isArray(minSize))\n                    minSize = minSize[0];\n                const maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n                c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n                return true;\n            });\n        });\n    }\n    /**\n     * prevent the overlappings among combos\n     */\n    comboNonOverlapping(displacements, comboMap) {\n        const self = this;\n        const comboTree = self.comboTree;\n        const comboCollideStrength = self.comboCollideStrength;\n        const indexMap = self.indexMap;\n        const nodeMap = self.nodeMap;\n        traverseTreeUp(comboTree, (treeNode) => {\n            if (!comboMap[treeNode.id] &&\n                !nodeMap[treeNode.id] &&\n                treeNode.id !== \"comboTreeRoot\") {\n                return false;\n            } // means it is hidden\n            const children = treeNode.children;\n            // 同个子树下的子 combo 间两两对比\n            if (children && children.length > 1) {\n                children.forEach((v, i) => {\n                    if (v.itemType === \"node\")\n                        return false; // skip it\n                    const cv = comboMap[v.id];\n                    if (!cv)\n                        return; // means it is hidden, skip it\n                    children.forEach((u, j) => {\n                        if (i <= j)\n                            return false;\n                        if (u.itemType === \"node\")\n                            return false; // skip it\n                        const cu = comboMap[u.id];\n                        if (!cu)\n                            return false; // means it is hidden, skip it\n                        const vx = (cv.cx - cu.cx) || 0.005;\n                        const vy = (cv.cy - cu.cy) || 0.005;\n                        const l = vx * vx + vy * vy;\n                        const rv = cv.r || 1;\n                        const ru = cu.r || 1;\n                        const r = rv + ru;\n                        const ru2 = ru * ru;\n                        const rv2 = rv * rv;\n                        // overlapping\n                        if (l < r * r) {\n                            const vnodes = v.children;\n                            if (!vnodes || vnodes.length === 0)\n                                return false; // skip it\n                            const unodes = u.children;\n                            if (!unodes || unodes.length === 0)\n                                return false; // skip it\n                            const sqrtl = Math.sqrt(l);\n                            const ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;\n                            const xl = vx * ll;\n                            const yl = vy * ll;\n                            const rratio = ru2 / (rv2 + ru2);\n                            const irratio = 1 - rratio;\n                            // 两兄弟 combo 的子节点上施加斥力\n                            vnodes.forEach((vn) => {\n                                if (vn.itemType !== \"node\")\n                                    return false; // skip it\n                                if (!nodeMap[vn.id])\n                                    return; // means it is hidden, skip it\n                                const vindex = indexMap[vn.id];\n                                unodes.forEach((un) => {\n                                    if (un.itemType !== \"node\")\n                                        return false;\n                                    if (!nodeMap[un.id])\n                                        return false; // means it is hidden, skip it\n                                    const uindex = indexMap[un.id];\n                                    displacements[vindex].x += xl * rratio;\n                                    displacements[vindex].y += yl * rratio;\n                                    displacements[uindex].x -= xl * irratio;\n                                    displacements[uindex].y -= yl * irratio;\n                                });\n                            });\n                        }\n                    });\n                });\n            }\n            return true;\n        });\n    }\n    /**\n     * Calculate the repulsive force between each node pair\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    calRepulsive(displacements, vecMap) {\n        const self = this;\n        const nodes = self.nodes;\n        const max = self.width * self.optimizeRangeFactor;\n        const nodeStrength = self.nodeStrength;\n        const alpha = self.alpha;\n        const nodeCollideStrength = self.nodeCollideStrength;\n        const preventNodeOverlap = self.preventNodeOverlap;\n        const nodeSizeFunc = self.nodeSize;\n        const nodeSpacingFunc = self.nodeSpacing;\n        const scale = self.depthRepulsiveForceScale;\n        const center = self.center;\n        nodes.forEach((v, i) => {\n            if (!v.x || !v.y)\n                return;\n            // center gravity\n            if (center) {\n                const gravity = self.gravity;\n                const vecX = (v.x - center[0]) || 0.005;\n                const vecY = (v.y - center[1]) || 0.005;\n                const l = Math.sqrt(vecX * vecX + vecY * vecY);\n                displacements[i].x -= (vecX * gravity * alpha) / l;\n                displacements[i].y -= (vecY * gravity * alpha) / l;\n            }\n            nodes.forEach((u, j) => {\n                if (i === j) {\n                    return;\n                }\n                if (!u.x || !u.y)\n                    return;\n                const { vl2, vl } = vecMap[`${v.id}-${u.id}`];\n                if (vl > max)\n                    return;\n                const { vx, vy } = vecMap[`${v.id}-${u.id}`];\n                let depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n                depthDiff = depthDiff < 1 ? 1 : depthDiff;\n                if (u.comboId !== v.comboId)\n                    depthDiff += 1;\n                const depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n                const params = ((nodeStrength(u) * alpha) / vl2) * depthParam;\n                displacements[i].x += vx * params;\n                displacements[i].y += vy * params;\n                // prevent node overlappings\n                if (i < j && preventNodeOverlap) {\n                    const ri = (nodeSizeFunc(v) + nodeSpacingFunc(v)) || 1;\n                    const rj = (nodeSizeFunc(u) + nodeSpacingFunc(u)) || 1;\n                    const r = ri + rj;\n                    if (vl2 < r * r) {\n                        const ll = ((r - vl) / vl) * nodeCollideStrength;\n                        const rj2 = rj * rj;\n                        let rratio = rj2 / (ri * ri + rj2);\n                        const xl = vx * ll;\n                        const yl = vy * ll;\n                        displacements[i].x += xl * rratio;\n                        displacements[i].y += yl * rratio;\n                        rratio = 1 - rratio;\n                        displacements[j].x -= xl * rratio;\n                        displacements[j].y -= yl * rratio;\n                    }\n                }\n            });\n        });\n    }\n    /**\n     * Calculate the attractive force between the node pair with edge\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    calAttractive(displacements, vecMap) {\n        const self = this;\n        const edges = self.edges;\n        const linkDistance = self.linkDistance;\n        const alpha = self.alpha;\n        const edgeStrength = self.edgeStrength;\n        const bias = self.bias;\n        const scale = self.depthAttractiveForceScale;\n        edges.forEach((e, i) => {\n            const source = getEdgeTerminal(e, 'source');\n            const target = getEdgeTerminal(e, 'target');\n            if (!source || !target || source === target)\n                return;\n            const uIndex = self.indexMap[source];\n            const vIndex = self.indexMap[target];\n            const u = self.nodeMap[source];\n            const v = self.nodeMap[target];\n            if (!u || !v)\n                return;\n            let depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n            if (u.comboId === v.comboId) {\n                depthDiff = depthDiff / 2;\n            }\n            let depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n            if (u.comboId !== v.comboId && depthParam === 1) {\n                depthParam = scale / 2;\n            }\n            else if (u.comboId === v.comboId) {\n                depthParam = 2;\n            }\n            if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n                return;\n            }\n            const { vl, vx, vy } = vecMap[`${target}-${source}`];\n            const l = ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;\n            const vecX = vx * l;\n            const vecY = vy * l;\n            const b = bias[i];\n            displacements[vIndex].x -= vecX * b;\n            displacements[vIndex].y -= vecY * b;\n            displacements[uIndex].x += vecX * (1 - b);\n            displacements[uIndex].y += vecY * (1 - b);\n        });\n    }\n    getType() {\n        return \"comboForce\";\n    }\n}\n//# sourceMappingURL=comboForce.js.map"]},"metadata":{},"sourceType":"module"}