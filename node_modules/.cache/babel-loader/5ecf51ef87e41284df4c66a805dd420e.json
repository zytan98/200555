{"ast":null,"code":"import { isObject } from './is-object';\nimport { isTypedArray } from './is-typedarray';\n/**\n * 考虑结构体命名, eg:\n * a: { b: 1 }  ->  'a.b'\n * a: [ { b: 1 } ] -> 'a[0].b'\n */\n\nexport function extractUniforms(uniforms) {\n  var extractedUniforms = {};\n  Object.keys(uniforms).forEach(function (uniformName) {\n    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');\n  });\n  return extractedUniforms;\n}\n\nfunction extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {\n  if (uniformValue === null || typeof uniformValue === 'number' || // u_A: 1\n  typeof uniformValue === 'boolean' || // u_A: false\n  Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' || // u_A: [1, 2, 3]\n  isTypedArray(uniformValue) || // u_A: Float32Array\n  // @ts-ignore\n  uniformValue === '' || // @ts-ignore\n  uniformValue.resize !== undefined) {\n    uniforms[\"\".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;\n    return;\n  } // u_Struct.a.b.c\n\n\n  if (isObject(uniformValue)) {\n    Object.keys(uniformValue).forEach(function (childName) {\n      extractUniformsRecursively(childName, // @ts-ignore\n      uniformValue[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName));\n    });\n  } // u_Struct[0].a\n\n\n  if (Array.isArray(uniformValue)) {\n    // @ts-ignore\n    uniformValue.forEach(function (child, idx) {\n      Object.keys(child).forEach(function (childName) {\n        extractUniformsRecursively(childName, // @ts-ignore\n        child[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName, \"[\").concat(idx, \"]\"));\n      });\n    });\n  }\n}","map":{"version":3,"sources":["../../src/utils/uniform.ts"],"names":["extractedUniforms","Object","extractUniformsRecursively","uniforms","uniformValue","Array","isTypedArray","prefix","isObject","child"],"mappings":"AACA,SAAA,QAAA,QAAA,aAAA;AACA,SAAA,YAAA,QAAA,iBAAA;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,eAAA,CAAA,QAAA,EAIL;AACA,MAAMA,iBAAiB,GAAvB,EAAA;AACAC,EAAAA,MAAM,CAANA,IAAAA,CAAAA,QAAAA,EAAAA,OAAAA,CAA8B,UAAA,WAAA,EAAiB;AAC7CC,IAAAA,0BAA0B,CAAA,WAAA,EAExBC,QAAQ,CAFgB,WAEhB,CAFgB,EAAA,iBAAA,EAA1BD,EAA0B,CAA1BA;AADFD,GAAAA;AASA,SAAA,iBAAA;AACD;;AAED,SAAA,0BAAA,CAAA,WAAA,EAAA,YAAA,EAAA,QAAA,EAAA,MAAA,EAOE;AACA,MACEG,YAAY,KAAZA,IAAAA,IACA,OAAA,YAAA,KADAA,QAAAA,IACoC;AACpC,SAAA,YAAA,KAFAA,SAAAA,IAEqC;AACpCC,EAAAA,KAAK,CAALA,OAAAA,CAAAA,YAAAA,KAA+B,OAAOD,YAAY,CAAnB,CAAmB,CAAnB,KAHhCA,QAAAA,IAGwE;AACxEE,EAAAA,YAAY,CAJZF,YAIY,CAJZA,IAI8B;AAC9B;AACAA,EAAAA,YAAY,KANZA,EAAAA,IAOA;AACAA,EAAAA,YAAY,CAAZA,MAAAA,KATF,SAAA,EAUE;AACAD,IAAAA,QAAQ,CAAA,GAAA,MAAA,CAAII,MAAM,IAAIA,MAAM,GAApB,GAAA,EAAA,MAAA,CAARJ,WAAQ,CAAA,CAARA,GAAAA,YAAAA;AACA;AAbF,GAAA,CAgBA;;;AACA,MAAIK,QAAQ,CAAZ,YAAY,CAAZ,EAA4B;AAC1BP,IAAAA,MAAM,CAANA,IAAAA,CAAAA,YAAAA,EAAAA,OAAAA,CAAkC,UAAA,SAAA,EAAe;AAC/CC,MAAAA,0BAA0B,CAAA,SAAA,EAExB;AACAE,MAAAA,YAAY,CAHY,SAGZ,CAHY,EAAA,QAAA,EAAA,GAAA,MAAA,CAKrBG,MAAM,IAAIA,MAAM,GALK,GAAA,EAAA,MAAA,CAA1BL,WAA0B,CAAA,CAA1BA;AADFD,KAAAA;AAlBF,GAAA,CA6BA;;;AACA,MAAII,KAAK,CAALA,OAAAA,CAAJ,YAAIA,CAAJ,EAAiC;AAC/B;AACAD,IAAAA,YAAY,CAAZA,OAAAA,CAAqB,UAAA,KAAA,EAAA,GAAA,EAAgB;AACnCH,MAAAA,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAAAA,OAAAA,CAA2B,UAAA,SAAA,EAAe;AACxCC,QAAAA,0BAA0B,CAAA,SAAA,EAExB;AACAO,QAAAA,KAAK,CAHmB,SAGnB,CAHmB,EAAA,QAAA,EAAA,GAAA,MAAA,CAKrBF,MAAM,IAAIA,MAAM,GALK,GAAA,EAAA,MAAA,CAAA,WAAA,EAAA,GAAA,EAAA,MAAA,CAAA,GAAA,EAA1BL,GAA0B,CAAA,CAA1BA;AADFD,OAAAA;AADFG,KAAAA;AAWD;AACF","sourcesContent":["import { IUniform } from '@antv/g-webgpu-core';\nimport { isObject } from './is-object';\nimport { isTypedArray } from './is-typedarray';\n\n/**\n * 考虑结构体命名, eg:\n * a: { b: 1 }  ->  'a.b'\n * a: [ { b: 1 } ] -> 'a[0].b'\n */\nexport function extractUniforms(uniforms: {\n  [key: string]: IUniform;\n}): {\n  [key: string]: IUniform;\n} {\n  const extractedUniforms = {};\n  Object.keys(uniforms).forEach((uniformName) => {\n    extractUniformsRecursively(\n      uniformName,\n      uniforms[uniformName],\n      extractedUniforms,\n      '',\n    );\n  });\n\n  return extractedUniforms;\n}\n\nfunction extractUniformsRecursively(\n  uniformName: string,\n  uniformValue: IUniform,\n  uniforms: {\n    [key: string]: IUniform;\n  },\n  prefix: string,\n) {\n  if (\n    uniformValue === null ||\n    typeof uniformValue === 'number' || // u_A: 1\n    typeof uniformValue === 'boolean' || // u_A: false\n    (Array.isArray(uniformValue) && typeof uniformValue[0] === 'number') || // u_A: [1, 2, 3]\n    isTypedArray(uniformValue) || // u_A: Float32Array\n    // @ts-ignore\n    uniformValue === '' ||\n    // @ts-ignore\n    uniformValue.resize !== undefined\n  ) {\n    uniforms[`${prefix && prefix + '.'}${uniformName}`] = uniformValue;\n    return;\n  }\n\n  // u_Struct.a.b.c\n  if (isObject(uniformValue)) {\n    Object.keys(uniformValue).forEach((childName) => {\n      extractUniformsRecursively(\n        childName,\n        // @ts-ignore\n        uniformValue[childName],\n        uniforms,\n        `${prefix && prefix + '.'}${uniformName}`,\n      );\n    });\n  }\n\n  // u_Struct[0].a\n  if (Array.isArray(uniformValue)) {\n    // @ts-ignore\n    uniformValue.forEach((child, idx) => {\n      Object.keys(child).forEach((childName) => {\n        extractUniformsRecursively(\n          childName,\n          // @ts-ignore\n          child[childName],\n          uniforms,\n          `${prefix && prefix + '.'}${uniformName}[${idx}]`,\n        );\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}