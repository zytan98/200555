{"ast":null,"code":"import { nelderMead } from 'fmin';\nimport { intersectionArea, distance, getCenter } from './circleintersection';\n\nfunction circleMargin(current, interior, exterior) {\n  var margin = interior[0].radius - distance(interior[0], current),\n      i,\n      m;\n\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  return margin;\n} // compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\n\n\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  var points = [];\n  var i;\n\n  for (i = 0; i < interior.length; ++i) {\n    var c = interior[i];\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n\n  var initial = points[0],\n      margin = circleMargin(points[0], interior, exterior);\n\n  for (i = 1; i < points.length; ++i) {\n    var m = circleMargin(points[i], interior, exterior);\n\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  } // maximize the margin numerically\n\n\n  var solution = nelderMead(function (p) {\n    return -1 * circleMargin({\n      x: p[0],\n      y: p[1]\n    }, interior, exterior);\n  }, [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  var ret = {\n    x: solution[0],\n    y: solution[1]\n  }; // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n\n  var valid = true;\n\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = {\n        x: interior[0].x,\n        y: interior[0].y\n      };\n    } else {\n      var areaStats = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = {\n          x: 0,\n          y: -1000,\n          disjoint: true\n        };\n      } else if (areaStats.arcs.length == 1) {\n        ret = {\n          x: areaStats.arcs[0].circle.x,\n          y: areaStats.arcs[0].circle.y\n        };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(areaStats.arcs.map(function (a) {\n          return a.p1;\n        }));\n      }\n    }\n  }\n\n  return ret;\n} // given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\n\nfunction getOverlappingCircles(circles) {\n  var ret = {},\n      circleids = [];\n\n  for (var circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n\n  for (var i = 0; i < circleids.length; i++) {\n    var a = circles[circleids[i]];\n\n    for (var j = i + 1; j < circleids.length; ++j) {\n      var b = circles[circleids[j]],\n          d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n\n  return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n  var ret = {},\n      overlapped = getOverlappingCircles(circles);\n\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i].sets,\n        areaids = {},\n        exclude = {};\n\n    for (var j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      var overlaps = overlapped[area[j]]; // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n\n      for (var k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    var interior = [],\n        exterior = [];\n\n    for (var setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n\n    var centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n\n  return ret;\n}\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\n\nexport function circlePath(x, y, r) {\n  var ret = []; // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n\n  var x0 = x - r;\n  var y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n  return ret.join(' ');\n} // inverse of the circlePath function, returns a circle object from an svg path\n\nexport function circleFromPath(path) {\n  var tokens = path.split(' ');\n  return {\n    x: parseFloat(tokens[1]),\n    y: parseFloat(tokens[2]),\n    radius: -parseFloat(tokens[4])\n  };\n}\n/** returns a svg path of the intersection area of a bunch of circles */\n\nexport function intersectionAreaPath(circles) {\n  var stats = {};\n  intersectionArea(circles, stats);\n  var arcs = stats.arcs;\n\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    var circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    var ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n\n    for (var i = 0; i < arcs.length; ++i) {\n      var arc = arcs[i],\n          r = arc.circle.radius,\n          wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n\n    return ret.join(' ');\n  }\n}","map":{"version":3,"sources":["../../../../src/plots/venn/layout/diagram.ts"],"names":[],"mappings":"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","sourcesContent":["import { nelderMead } from 'fmin';\nimport { intersectionArea, distance, getCenter } from './circleintersection';\n\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current),\n    i,\n    m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  const points = [];\n  let i;\n  for (i = 0; i < interior.length; ++i) {\n    const c = interior[i];\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n  let initial = points[0],\n    margin = circleMargin(points[0], interior, exterior);\n  for (i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    function (p) {\n      return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);\n    },\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n  let ret: any = { x: solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = { x: interior[0].x, y: interior[0].y };\n    } else {\n      const areaStats: any = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = { x: 0, y: -1000, disjoint: true };\n      } else if (areaStats.arcs.length == 1) {\n        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(\n          areaStats.arcs.map(function (a) {\n            return a.p1;\n          })\n        );\n      }\n    }\n  }\n\n  return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {},\n    circleids = [];\n  for (const circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const a = circles[circleids[i]];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const b = circles[circleids[j]],\n        d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n  return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n  const ret = {},\n    overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets,\n      areaids = {},\n      exclude = {};\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [],\n      exterior = [];\n    for (const setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\nexport function circlePath(x, y, r) {\n  const ret = [];\n  // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  const x0 = x - r;\n  const y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n\n  return ret.join(' ');\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: parseFloat(tokens[1]), y: parseFloat(tokens[2]), radius: -parseFloat(tokens[4]) };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n  const stats: any = {};\n  intersectionArea(circles, stats);\n  const arcs = stats.arcs;\n\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    const ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n    for (let i = 0; i < arcs.length; ++i) {\n      const arc = arcs[i],\n        r = arc.circle.radius,\n        wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n    return ret.join(' ');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}