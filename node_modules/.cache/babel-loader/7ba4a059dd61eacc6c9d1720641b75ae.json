{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"dagre\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\n\nexport class DagreLayout extends Base {\n  constructor(options) {\n    super();\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n    this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n\n    this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n\n    this.sortByCombo = false;\n    this.nodes = [];\n    this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    this.onLayoutEnd = () => {};\n\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {\n      rankdir: \"TB\",\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false // 是否保留布局连线的控制点\n\n    };\n  }\n  /**\n   * 执行布局\n   */\n\n\n  execute() {\n    const self = this;\n    const {\n      nodes,\n      nodeSize,\n      rankdir,\n      combos\n    } = self;\n    if (!nodes) return;\n    const edges = self.edges || [];\n    const g = new dagre.graphlib.Graph({\n      multigraph: true,\n      compound: true\n    });\n    let nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = d => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }\n\n          if (isObject(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = () => nodeSize;\n    } else {\n      nodeSizeFunc = () => [nodeSize, nodeSize];\n    }\n\n    let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n      vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    }\n\n    g.setDefaultEdgeLabel(() => ({}));\n    g.setGraph(self);\n    const comboMap = {};\n    nodes.filter(node => node.layout !== false).forEach(node => {\n      const size = nodeSizeFunc(node);\n      const verti = vertisep(node);\n      const hori = horisep(node);\n      const width = size[0] + 2 * hori;\n      const height = size[1] + 2 * verti;\n      g.setNode(node.id, {\n        width,\n        height\n      });\n\n      if (this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = true;\n          g.setNode(node.comboId, {});\n        }\n\n        g.setParent(node.id, node.comboId);\n      }\n    });\n\n    if (this.sortByCombo && combos) {\n      combos.forEach(combo => {\n        if (!combo.parentId) return;\n\n        if (!comboMap[combo.parentId]) {\n          comboMap[combo.parentId] = true;\n          g.setNode(combo.parentId, {});\n        }\n\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n\n    edges.forEach(edge => {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      g.setEdge(source, target, {\n        weight: edge.weight || 1\n      });\n    });\n    dagre.layout(g);\n    let coord;\n    g.nodes().forEach(node => {\n      coord = g.node(node);\n      const i = nodes.findIndex(it => it.id === node);\n      if (!nodes[i]) return;\n      nodes[i].x = coord.x;\n      nodes[i].y = coord.y;\n    });\n    g.edges().forEach(edge => {\n      coord = g.edge(edge);\n      const i = edges.findIndex(it => {\n        const source = getEdgeTerminal(it, 'source');\n        const target = getEdgeTerminal(it, 'target');\n        return source === edge.v && target === edge.w;\n      });\n\n      if (self.controlPoints && edges[i].type !== \"loop\") {\n        edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n      }\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  getType() {\n    return \"dagre\";\n  }\n\n}\n\nfunction getFunc(func, value, defaultValue) {\n  let resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = () => value;\n  } else {\n    resultFunc = () => defaultValue;\n  }\n\n  return resultFunc;\n}","map":{"version":3,"sources":["../../src/layout/dagre.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"dagre\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\nexport class DagreLayout extends Base {\n    constructor(options) {\n        super();\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        this.rankdir = \"TB\";\n        /** 节点水平间距(px) */\n        this.nodesep = 50;\n        /** 每一层节点之间间距 */\n        this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        this.controlPoints = false;\n        /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n        this.sortByCombo = false;\n        this.nodes = [];\n        this.edges = [];\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            rankdir: \"TB\",\n            align: undefined,\n            nodeSize: undefined,\n            nodesepFunc: undefined,\n            ranksepFunc: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: false, // 是否保留布局连线的控制点\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const { nodes, nodeSize, rankdir, combos } = self;\n        if (!nodes)\n            return;\n        const edges = self.edges || [];\n        const g = new dagre.graphlib.Graph({\n            multigraph: true,\n            compound: true,\n        });\n        let nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        return d.size;\n                    }\n                    if (isObject(d.size)) {\n                        return [d.size.width || 40, d.size.height || 40];\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if (isArray(nodeSize)) {\n            nodeSizeFunc = () => nodeSize;\n        }\n        else {\n            nodeSizeFunc = () => [nodeSize, nodeSize];\n        }\n        let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        if (rankdir === \"LR\" || rankdir === \"RL\") {\n            horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n            vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        }\n        g.setDefaultEdgeLabel(() => ({}));\n        g.setGraph(self);\n        const comboMap = {};\n        nodes.filter((node) => node.layout !== false).forEach((node) => {\n            const size = nodeSizeFunc(node);\n            const verti = vertisep(node);\n            const hori = horisep(node);\n            const width = size[0] + 2 * hori;\n            const height = size[1] + 2 * verti;\n            g.setNode(node.id, { width, height });\n            if (this.sortByCombo && node.comboId) {\n                if (!comboMap[node.comboId]) {\n                    comboMap[node.comboId] = true;\n                    g.setNode(node.comboId, {});\n                }\n                g.setParent(node.id, node.comboId);\n            }\n        });\n        if (this.sortByCombo && combos) {\n            combos.forEach((combo) => {\n                if (!combo.parentId)\n                    return;\n                if (!comboMap[combo.parentId]) {\n                    comboMap[combo.parentId] = true;\n                    g.setNode(combo.parentId, {});\n                }\n                g.setParent(combo.id, combo.parentId);\n            });\n        }\n        edges.forEach((edge) => {\n            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n            const source = getEdgeTerminal(edge, 'source');\n            const target = getEdgeTerminal(edge, 'target');\n            g.setEdge(source, target, {\n                weight: edge.weight || 1,\n            });\n        });\n        dagre.layout(g);\n        let coord;\n        g.nodes().forEach((node) => {\n            coord = g.node(node);\n            const i = nodes.findIndex((it) => it.id === node);\n            if (!nodes[i])\n                return;\n            nodes[i].x = coord.x;\n            nodes[i].y = coord.y;\n        });\n        g.edges().forEach((edge) => {\n            coord = g.edge(edge);\n            const i = edges.findIndex((it) => {\n                const source = getEdgeTerminal(it, 'source');\n                const target = getEdgeTerminal(it, 'target');\n                return source === edge.v && target === edge.w;\n            });\n            if (self.controlPoints && edges[i].type !== \"loop\") {\n                edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n            }\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes,\n            edges,\n        };\n    }\n    getType() {\n        return \"dagre\";\n    }\n}\nfunction getFunc(func, value, defaultValue) {\n    let resultFunc;\n    if (func) {\n        resultFunc = func;\n    }\n    else if (isNumber(value)) {\n        resultFunc = () => value;\n    }\n    else {\n        resultFunc = () => defaultValue;\n    }\n    return resultFunc;\n}\n//# sourceMappingURL=dagre.js.map"]},"metadata":{},"sourceType":"module"}