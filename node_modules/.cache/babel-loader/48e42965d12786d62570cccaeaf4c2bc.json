{"ast":null,"code":"import { isString, isNumber, isNil, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return type + \"-\" + Math.random() + Date.now();\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  var top = 0;\n  var left = 0;\n  var right = 0;\n  var bottom = 0;\n\n  if (isNumber(padding)) {\n    top = left = right = bottom = padding;\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    top = left = right = bottom = intPadding;\n  } else if (isArray(padding)) {\n    top = padding[0];\n    right = !isNil(padding[1]) ? padding[1] : padding[0];\n    bottom = !isNil(padding[2]) ? padding[2] : padding[0];\n    left = !isNil(padding[3]) ? padding[3] : right;\n  }\n\n  return [top, right, bottom, left];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = source + \"-\" + target;\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-core/es/util/base.js"],"names":["isString","isNumber","isNil","isArray","G6GraphEvent","uniqueId","type","Math","random","Date","now","formatPadding","padding","top","left","right","bottom","intPadding","parseInt","cloneEvent","e","event","clientX","clientY","x","y","target","currentTarget","bubbles","item","isViewportChanged","matrix","MATRIX_LEN","ORIGIN_MATRIX","i","isNaN","input","Number","calculationItemsBBox","items","minx","Infinity","maxx","miny","maxy","length","element","bbox","getBBox","minX","minY","maxX","maxY","floor","width","ceil","height","processParallelEdges","edges","offsetDiff","multiEdgeType","singleEdgeType","loopEdgeType","undefined","len","cod","loopPosition","edgeMap","tags","reverses","edge","source","sourceTarget","push","j","sedge","src","dst","key","arcEdges","length_1","k","current","loopCfg","position","dist","sign","curveOffset"],"mappings":"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","sourcesContent":["import { isString, isNumber, isNil, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return type + \"-\" + Math.random() + Date.now();\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  var top = 0;\n  var left = 0;\n  var right = 0;\n  var bottom = 0;\n\n  if (isNumber(padding)) {\n    top = left = right = bottom = padding;\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    top = left = right = bottom = intPadding;\n  } else if (isArray(padding)) {\n    top = padding[0];\n    right = !isNil(padding[1]) ? padding[1] : padding[0];\n    bottom = !isNil(padding[2]) ? padding[2] : padding[0];\n    left = !isNil(padding[3]) ? padding[3] : right;\n  }\n\n  return [top, right, bottom, left];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = source + \"-\" + target;\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};"]},"metadata":{},"sourceType":"module"}