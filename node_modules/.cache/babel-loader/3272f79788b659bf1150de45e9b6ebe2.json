{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor, _class3, _temp;\n\nimport { Frustum, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\nexport var CAMERA_TYPE;\n\n(function (CAMERA_TYPE) {\n  CAMERA_TYPE[\"ORBITING\"] = \"ORBITING\";\n  CAMERA_TYPE[\"EXPLORING\"] = \"EXPLORING\";\n  CAMERA_TYPE[\"TRACKING\"] = \"TRACKING\";\n})(CAMERA_TYPE || (CAMERA_TYPE = {}));\n\nexport var CAMERA_TRACKING_MODE;\n\n(function (CAMERA_TRACKING_MODE) {\n  CAMERA_TRACKING_MODE[\"DEFAULT\"] = \"DEFAULT\";\n  CAMERA_TRACKING_MODE[\"ROTATIONAL\"] = \"ROTATIONAL\";\n  CAMERA_TRACKING_MODE[\"TRANSLATIONAL\"] = \"TRANSLATIONAL\";\n  CAMERA_TRACKING_MODE[\"CINEMATIC\"] = \"CINEMATIC\";\n})(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));\n\nexport var CAMERA_PROJECTION_MODE;\n\n(function (CAMERA_PROJECTION_MODE) {\n  CAMERA_PROJECTION_MODE[\"ORTHOGRAPHIC\"] = \"ORTHOGRAPHIC\";\n  CAMERA_PROJECTION_MODE[\"PERSPECTIVE\"] = \"PERSPECTIVE\";\n})(CAMERA_PROJECTION_MODE || (CAMERA_PROJECTION_MODE = {}));\n\nvar DEG_2_RAD = Math.PI / 180;\nvar RAD_2_DEG = 180 / Math.PI;\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n\nexport var Camera = (_dec = injectable(), _dec2 = inject(IDENTIFIER.InteractorService), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function () {\n  function Camera() {\n    _classCallCheck(this, Camera);\n\n    this.matrix = mat4.create();\n    this.right = vec3.fromValues(1, 0, 0);\n    this.up = vec3.fromValues(0, 1, 0);\n    this.forward = vec3.fromValues(0, 0, 1);\n    this.position = vec3.fromValues(0, 0, 1);\n    this.focalPoint = vec3.fromValues(0, 0, 0);\n    this.distanceVector = vec3.fromValues(0, 0, 0);\n    this.distance = 1;\n    this.azimuth = 0;\n    this.elevation = 0;\n    this.roll = 0;\n    this.relAzimuth = 0;\n    this.relElevation = 0;\n    this.relRoll = 0;\n    this.dollyingStep = 0;\n    this.maxDistance = Infinity;\n    this.minDistance = -Infinity;\n    this.rotateWorld = false;\n\n    _initializerDefineProperty(this, \"interactor\", _descriptor, this);\n\n    this.fov = 30;\n    this.near = 0.1;\n    this.far = 10000;\n    this.aspect = 1;\n    this.left = void 0;\n    this.rright = void 0;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.zoom = 1;\n    this.perspective = mat4.create();\n    this.view = void 0;\n    this.following = undefined;\n    this.type = CAMERA_TYPE.EXPLORING;\n    this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.frustum = new Frustum();\n    this.landmarks = [];\n    this.landmarkAnimationID = void 0;\n  }\n\n  _createClass(Camera, [{\n    key: \"clone\",\n    value: function clone() {\n      var camera = new Camera();\n      camera.setType(this.type, undefined);\n      camera.interactor = this.interactor;\n      return camera;\n    }\n  }, {\n    key: \"getProjectionMode\",\n    value: function getProjectionMode() {\n      return this.projectionMode;\n    }\n  }, {\n    key: \"getPerspective\",\n    value: function getPerspective() {\n      return this.perspective;\n    }\n  }, {\n    key: \"getFrustum\",\n    value: function getFrustum() {\n      return this.frustum;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return this.position;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(type, trackingMode) {\n      this.type = type;\n\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        this.setWorldRotation(true);\n      } else {\n        this.setWorldRotation(false);\n      }\n\n      this._getAngles();\n\n      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n        this.setTrackingMode(trackingMode);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setProjectionMode\",\n    value: function setProjectionMode(projectionMode) {\n      this.projectionMode = projectionMode;\n      return this;\n    }\n  }, {\n    key: \"setTrackingMode\",\n    value: function setTrackingMode(trackingMode) {\n      if (this.type !== CAMERA_TYPE.TRACKING) {\n        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');\n      }\n\n      this.trackingMode = trackingMode;\n      return this;\n    }\n    /**\n     * If flag is true, it reverses the azimuth and elevation angles.\n     * Subsequent calls to rotate, setAzimuth, setElevation,\n     * changeAzimuth or changeElevation will cause the inverted effect.\n     * setRoll or changeRoll is not affected by this method.\n     *\n     * This inversion is useful when one wants to simulate that the world\n     * is moving, instead of the camera.\n     *\n     * By default the camera angles are not reversed.\n     * @param {Boolean} flag the boolean flag to reverse the angles.\n     */\n\n  }, {\n    key: \"setWorldRotation\",\n    value: function setWorldRotation(flag) {\n      this.rotateWorld = flag;\n\n      this._getAngles();\n    }\n    /**\n     * 计算 MV 矩阵，为相机矩阵的逆矩阵\n     */\n\n  }, {\n    key: \"getViewTransform\",\n    value: function getViewTransform() {\n      return mat4.invert(mat4.create(), this.matrix);\n    }\n  }, {\n    key: \"getWorldTransform\",\n    value: function getWorldTransform() {\n      return this.matrix;\n    }\n    /**\n     * 设置相机矩阵\n     */\n\n  }, {\n    key: \"setMatrix\",\n    value: function setMatrix(matrix) {\n      this.matrix = matrix;\n\n      this._update();\n\n      return this;\n    }\n  }, {\n    key: \"setAspect\",\n    value: function setAspect(aspect) {\n      this.setPerspective(this.near, this.far, this.fov, aspect);\n      return this;\n    }\n    /**\n     * Sets an offset in a larger frustum, used in PixelPicking\n     */\n\n  }, {\n    key: \"setViewOffset\",\n    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n      this.aspect = fullWidth / fullHeight;\n\n      if (this.view === undefined) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clearViewOffset\",\n    value: function clearViewOffset() {\n      if (this.view !== undefined) {\n        this.view.enabled = false;\n      }\n\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setPerspective\",\n    value: function setPerspective(near, far, fov, aspect) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n      this.fov = fov;\n      this.near = near;\n      this.far = far;\n      this.aspect = aspect;\n      mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);\n      return this;\n    }\n  }, {\n    key: \"setOrthographic\",\n    value: function setOrthographic(l, r, t, b, near, far) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n      this.rright = r;\n      this.left = l;\n      this.top = t;\n      this.bottom = b;\n      this.near = near;\n      this.far = far;\n      var dx = (this.rright - this.left) / (2 * this.zoom);\n      var dy = (this.top - this.bottom) / (2 * this.zoom);\n      var cx = (this.rright + this.left) / 2;\n      var cy = (this.top + this.bottom) / 2;\n      var left = cx - dx;\n      var right = cx + dx;\n      var top = cy + dy;\n      var bottom = cy - dy;\n\n      if (this.view !== undefined && this.view.enabled) {\n        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;\n        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n        left += scaleW * this.view.offsetX;\n        right = left + scaleW * this.view.width;\n        top -= scaleH * this.view.offsetY;\n        bottom = top - scaleH * this.view.height;\n      }\n\n      mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n      return this;\n    }\n    /**\n     * 设置相机位置\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(x, y, z) {\n      this._setPosition(x, y, z);\n\n      this.setFocalPoint(this.focalPoint);\n      return this;\n    }\n    /**\n     * 设置视点位置\n     */\n\n  }, {\n    key: \"setFocalPoint\",\n    value: function setFocalPoint(x, y, z) {\n      var up = vec3.fromValues(0, 1, 0);\n      this.focalPoint = createVec3(x, y, z);\n\n      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n        var d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n        x = d[0];\n        y = d[1];\n        z = d[2];\n        var r = vec3.length(d);\n        var el = Math.asin(y / r) * RAD_2_DEG;\n        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n        var m = mat4.create();\n        mat4.rotateY(m, m, az * DEG_2_RAD);\n        mat4.rotateX(m, m, el * DEG_2_RAD);\n        up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n      }\n\n      mat4.invert(this.matrix, mat4.lookAt(mat4.create(), this.position, this.focalPoint, up));\n\n      this._getAxes();\n\n      this._getDistance();\n\n      this._getAngles();\n\n      return this;\n    }\n    /**\n     * 固定当前视点，按指定距离放置相机\n     */\n\n  }, {\n    key: \"setDistance\",\n    value: function setDistance(d) {\n      if (this.distance === d || d < 0) {\n        return;\n      }\n\n      this.distance = d;\n\n      if (this.distance < 0.0002) {\n        this.distance = 0.0002;\n      }\n\n      this.dollyingStep = this.distance / 100;\n      var pos = vec3.create();\n      d = this.distance;\n      var n = this.forward;\n      var f = this.focalPoint;\n      pos[0] = d * n[0] + f[0];\n      pos[1] = d * n[1] + f[1];\n      pos[2] = d * n[2] + f[2];\n\n      this._setPosition(pos);\n\n      return this;\n    }\n  }, {\n    key: \"setMaxDistance\",\n    value: function setMaxDistance(d) {\n      this.maxDistance = d;\n      return this;\n    }\n  }, {\n    key: \"setMinDistance\",\n    value: function setMinDistance(d) {\n      this.minDistance = d;\n      return this;\n    }\n    /**\n     * Changes the initial azimuth of the camera\n     */\n\n  }, {\n    key: \"changeAzimuth\",\n    value: function changeAzimuth(az) {\n      this.setAzimuth(this.azimuth + az);\n      return this;\n    }\n    /**\n     * Changes the initial elevation of the camera\n     */\n\n  }, {\n    key: \"changeElevation\",\n    value: function changeElevation(el) {\n      this.setElevation(this.elevation + el);\n      return this;\n    }\n    /**\n     * Changes the initial roll of the camera\n     */\n\n  }, {\n    key: \"changeRoll\",\n    value: function changeRoll(rl) {\n      this.setRoll(this.roll + rl);\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the azimuth in degrees\n     */\n\n  }, {\n    key: \"setAzimuth\",\n    value: function setAzimuth(az) {\n      this.azimuth = getAngle(az);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getAzimuth\",\n    value: function getAzimuth() {\n      return this.azimuth;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the elevation in degrees\n     */\n\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(el) {\n      this.elevation = getAngle(el);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} angle the roll angle\n     */\n\n  }, {\n    key: \"setRoll\",\n    value: function setRoll(angle) {\n      this.roll = getAngle(angle);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n    /**\n     * Changes the azimuth and elevation with respect to the current camera axes\n     * @param {Number} azimuth the relative azimuth\n     * @param {Number} elevation the relative elevation\n     * @param {Number} roll the relative roll\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(azimuth, elevation, roll) {\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        azimuth = getAngle(azimuth);\n        elevation = getAngle(elevation);\n        roll = getAngle(roll);\n        var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);\n        var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);\n        var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], roll * DEG_2_RAD);\n        var rotQ = quat.multiply(quat.create(), rotY, rotX);\n        rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n        var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n        mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else {\n        if (Math.abs(this.elevation + elevation) > 90) {\n          return;\n        }\n\n        this.relElevation = getAngle(elevation);\n        this.relAzimuth = getAngle(azimuth);\n        this.relRoll = getAngle(roll);\n        this.elevation += this.relElevation;\n        this.azimuth += this.relAzimuth;\n        this.roll += this.relRoll;\n        this.computeMatrix();\n      }\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      this._update();\n\n      return this;\n    }\n    /**\n     * 沿水平(right) & 垂直(up)平移相机\n     */\n\n  }, {\n    key: \"pan\",\n    value: function pan(tx, ty) {\n      var coords = createVec3(tx, ty, 0);\n      var pos = vec3.clone(this.position);\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n\n      this._setPosition(pos);\n\n      return this;\n    }\n    /**\n     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n     */\n\n  }, {\n    key: \"dolly\",\n    value: function dolly(value) {\n      var n = this.forward;\n      var pos = vec3.clone(this.position);\n      var step = value * this.dollyingStep;\n      var updatedDistance = this.distance + value * this.dollyingStep; // 限制视点距离范围\n\n      step = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;\n      pos[0] += step * n[0];\n      pos[1] += step * n[1];\n      pos[2] += step * n[2];\n\n      this._setPosition(pos);\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        // 重新计算视点距离\n        this._getDistance();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        // 保持视距，移动视点位置\n        vec3.add(this.focalPoint, pos, this.distanceVector);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"createLandmark\",\n    value: function createLandmark(name, params) {\n      var camera = this.clone();\n      camera.setPosition(params.position);\n      camera.setFocalPoint(params.focalPoint);\n\n      if (params.roll !== undefined) {\n        camera.setRoll(params.roll);\n      }\n\n      var landmark = new Landmark(name, camera);\n      this.landmarks.push(landmark);\n      return landmark;\n    }\n  }, {\n    key: \"setLandmark\",\n    value: function setLandmark(name) {\n      var landmark = new Landmark(name, this);\n      this.landmarks.push(landmark);\n      return this;\n    }\n  }, {\n    key: \"gotoLandmark\",\n    value: function gotoLandmark(name) {\n      var _this = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var landmark = this.landmarks.find(function (l) {\n        return l.name === name;\n      });\n\n      if (landmark) {\n        if (duration === 0) {\n          landmark.retrieve(this);\n          return;\n        }\n\n        if (this.landmarkAnimationID !== undefined) {\n          window.cancelAnimationFrame(this.landmarkAnimationID);\n        } // TODO: do not process events during animation\n\n\n        this.interactor.disconnect();\n        var destPosition = landmark.getPosition();\n        var destFocalPoint = landmark.getFocalPoint();\n        var destRoll = landmark.getRoll();\n        var timeStart;\n\n        var animate = function animate(timestamp) {\n          if (timeStart === undefined) {\n            timeStart = timestamp;\n          }\n\n          var elapsed = timestamp - timeStart; // TODO: use better ease function\n\n          var t = (1 - Math.cos(elapsed / duration * Math.PI)) / 2;\n          var interFocalPoint = vec3.create();\n          var interPosition = vec3.create();\n          var interRoll = 0;\n          vec3.lerp(interFocalPoint, _this.focalPoint, destFocalPoint, t);\n          vec3.lerp(interPosition, _this.position, destPosition, t);\n          interRoll = _this.roll * (1 - t) + destRoll * t;\n\n          _this.setFocalPoint(interFocalPoint);\n\n          _this.setPosition(interPosition);\n\n          _this.setRoll(interRoll);\n\n          _this.computeMatrix();\n\n          var dist = vec3.dist(interFocalPoint, destFocalPoint) + vec3.dist(interPosition, destPosition);\n\n          if (dist > 0.01) {//\n          } else {\n            _this.setFocalPoint(interFocalPoint);\n\n            _this.setPosition(interPosition);\n\n            _this.setRoll(interRoll);\n\n            _this.computeMatrix();\n\n            _this.interactor.connect();\n\n            return;\n          }\n\n          if (elapsed < duration) {\n            _this.landmarkAnimationID = window.requestAnimationFrame(animate);\n          }\n        };\n\n        window.requestAnimationFrame(animate);\n      }\n    }\n    /**\n     * 根据相机矩阵重新计算各种相机参数\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._getAxes();\n\n      this._getPosition();\n\n      this._getDistance();\n\n      this._getAngles();\n    }\n    /**\n     * 计算相机矩阵\n     */\n\n  }, {\n    key: \"computeMatrix\",\n    value: function computeMatrix() {\n      var rotX;\n      var rotY; // 使用四元数描述 3D 旋转\n      // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n\n      var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);\n      mat4.identity(this.matrix); // only consider HCS for EXPLORING and ORBITING cameras\n\n      rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);\n      rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.azimuth * DEG_2_RAD);\n      var rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        mat4.translate(this.matrix, this.matrix, this.focalPoint);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        mat4.translate(this.matrix, this.matrix, this.position);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      }\n    }\n    /**\n     * Sets the camera position in the camera matrix\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(x, y, z) {\n      this.position = createVec3(x, y, z);\n      var m = this.matrix;\n      m[12] = this.position[0];\n      m[13] = this.position[1];\n      m[14] = this.position[2];\n      m[15] = 1;\n    }\n    /**\n     * Recalculates axes based on the current matrix\n     */\n\n  }, {\n    key: \"_getAxes\",\n    value: function _getAxes() {\n      vec3.copy(this.right, createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)));\n      vec3.copy(this.up, createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)));\n      vec3.copy(this.forward, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)));\n      vec3.normalize(this.right, this.right);\n      vec3.normalize(this.up, this.up);\n      vec3.normalize(this.forward, this.forward);\n    }\n    /**\n     * Recalculates euler angles based on the current state\n     */\n\n  }, {\n    key: \"_getAngles\",\n    value: function _getAngles() {\n      // Recalculates angles\n      var x = this.distanceVector[0];\n      var y = this.distanceVector[1];\n      var z = this.distanceVector[2];\n      var r = vec3.length(this.distanceVector); // FAST FAIL: If there is no distance we cannot compute angles\n\n      if (r === 0) {\n        this.elevation = 0;\n        this.azimuth = 0;\n        return;\n      }\n\n      if (this.type === CAMERA_TYPE.TRACKING) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        if (this.rotateWorld) {\n          this.elevation = Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n        } else {\n          this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n        }\n      }\n    }\n    /**\n     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n     */\n\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition() {\n      vec3.copy(this.position, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix))); // 相机位置变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n     */\n\n  }, {\n    key: \"_getFocalPoint\",\n    value: function _getFocalPoint() {\n      vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3.fromMat4(mat3.create(), this.matrix));\n      vec3.add(this.focalPoint, this.position, this.distanceVector); // 视点变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视距\n     */\n\n  }, {\n    key: \"_getDistance\",\n    value: function _getDistance() {\n      this.distanceVector = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      this.distance = vec3.length(this.distanceVector);\n      this.dollyingStep = this.distance / 100;\n    }\n  }]);\n\n  return Camera;\n}(), _class3.ProjectionMode = {\n  ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n  PERSPECTIVE: 'PERSPECTIVE'\n}, _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"interactor\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);","map":{"version":3,"sources":["../../src/camera/Camera.ts"],"names":["CAMERA_TYPE","CAMERA_TRACKING_MODE","CAMERA_PROJECTION_MODE","DEG_2_RAD","Math","RAD_2_DEG","injectable","Camera","ORTHOGRAPHIC","PERSPECTIVE","mat4","vec3","inject","IDENTIFIER","camera","trackingMode","fullWidth","enabled","fullHeight","offsetX","offsetY","width","height","dx","dy","cx","cy","left","right","top","bottom","scaleW","scaleH","up","createVec3","d","x","y","z","r","el","az","m","pos","n","f","getAngle","azimuth","elevation","roll","rotX","quat","rotY","rotZ","rotQ","rotMatrix","coords","step","value","updatedDistance","params","landmark","duration","l","window","destPosition","destFocalPoint","destRoll","animate","timeStart","elapsed","timestamp","t","interFocalPoint","interPosition","interRoll","dist","vec4","mat3"],"mappings":"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","sourcesContent":["import {\n  Frustum,\n  ICamera,\n  IDENTIFIER,\n  IInteractorService,\n} from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\n\nexport enum CAMERA_TYPE {\n  ORBITING = 'ORBITING',\n  EXPLORING = 'EXPLORING',\n  TRACKING = 'TRACKING',\n}\n\nexport enum CAMERA_TRACKING_MODE {\n  DEFAULT = 'DEFAULT',\n  ROTATIONAL = 'ROTATIONAL',\n  TRANSLATIONAL = 'TRANSLATIONAL',\n  CINEMATIC = 'CINEMATIC',\n}\n\nexport enum CAMERA_PROJECTION_MODE {\n  ORTHOGRAPHIC = 'ORTHOGRAPHIC',\n  PERSPECTIVE = 'PERSPECTIVE',\n}\n\nconst DEG_2_RAD = Math.PI / 180;\nconst RAD_2_DEG = 180 / Math.PI;\n\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n@injectable()\nexport class Camera implements ICamera {\n  public static ProjectionMode = {\n    ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n    PERSPECTIVE: 'PERSPECTIVE',\n  };\n  /**\n   * 相机矩阵\n   */\n  public matrix = mat4.create();\n\n  /**\n   * u 轴\n   * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition\n   */\n  public right = vec3.fromValues(1, 0, 0);\n\n  /**\n   * v 轴\n   */\n  public up = vec3.fromValues(0, 1, 0);\n\n  /**\n   * n 轴\n   */\n  public forward = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 相机位置\n   */\n  public position = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 视点位置\n   */\n  public focalPoint = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点向量\n   * focalPoint - position\n   */\n  public distanceVector = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点距离\n   * length(focalPoint - position)\n   */\n  public distance = 1;\n\n  /**\n   * @see https://en.wikipedia.org/wiki/Azimuth\n   */\n  public azimuth = 0;\n  public elevation = 0;\n  public roll = 0;\n  public relAzimuth = 0;\n  public relElevation = 0;\n  public relRoll = 0;\n\n  /**\n   * 沿 n 轴移动时，保证移动速度从快到慢\n   */\n  public dollyingStep = 0;\n  public maxDistance = Infinity;\n  public minDistance = -Infinity;\n\n  /**\n   * invert the horizontal coordinate system HCS\n   */\n  public rotateWorld = false;\n\n  @inject(IDENTIFIER.InteractorService)\n  public interactor: IInteractorService;\n\n  /**\n   * 投影矩阵参数\n   */\n\n  /**\n   * field of view [0-360]\n   * @see http://en.wikipedia.org/wiki/Angle_of_view\n   */\n  private fov = 30;\n  private near = 0.1;\n  private far = 10000;\n  private aspect = 1;\n  private left: number;\n  private rright: number;\n  private top: number;\n  private bottom: number;\n  private zoom = 1;\n  private perspective = mat4.create();\n\n  private view:\n    | {\n        enabled: boolean;\n        fullWidth: number;\n        fullHeight: number;\n        offsetX: number;\n        offsetY: number;\n        width: number;\n        height: number;\n      }\n    | undefined;\n\n  private following = undefined;\n\n  private type = CAMERA_TYPE.EXPLORING;\n  private trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n  private projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n\n  /**\n   * for culling use\n   */\n  private frustum: Frustum = new Frustum();\n\n  /**\n   * switch between multiple landmarks\n   */\n  private landmarks: Landmark[] = [];\n  private landmarkAnimationID: number | undefined;\n\n  public clone(): Camera {\n    const camera = new Camera();\n    camera.setType(this.type, undefined);\n    camera.interactor = this.interactor;\n    return camera;\n  }\n\n  public getProjectionMode() {\n    return this.projectionMode;\n  }\n\n  public getPerspective() {\n    return this.perspective;\n  }\n\n  public getFrustum() {\n    return this.frustum;\n  }\n\n  public getPosition() {\n    return this.position;\n  }\n\n  public setType(\n    type: CAMERA_TYPE,\n    trackingMode: CAMERA_TRACKING_MODE | undefined,\n  ) {\n    this.type = type;\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      this.setWorldRotation(true);\n    } else {\n      this.setWorldRotation(false);\n    }\n    this._getAngles();\n\n    if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n      this.setTrackingMode(trackingMode);\n    }\n    return this;\n  }\n\n  public setProjectionMode(projectionMode: CAMERA_PROJECTION_MODE) {\n    this.projectionMode = projectionMode;\n    return this;\n  }\n\n  public setTrackingMode(trackingMode: CAMERA_TRACKING_MODE) {\n    if (this.type !== CAMERA_TYPE.TRACKING) {\n      throw new Error(\n        'Impossible to set a tracking mode if the camera is not of tracking type',\n      );\n    }\n    this.trackingMode = trackingMode;\n    return this;\n  }\n\n  /**\n   * If flag is true, it reverses the azimuth and elevation angles.\n   * Subsequent calls to rotate, setAzimuth, setElevation,\n   * changeAzimuth or changeElevation will cause the inverted effect.\n   * setRoll or changeRoll is not affected by this method.\n   *\n   * This inversion is useful when one wants to simulate that the world\n   * is moving, instead of the camera.\n   *\n   * By default the camera angles are not reversed.\n   * @param {Boolean} flag the boolean flag to reverse the angles.\n   */\n  public setWorldRotation(flag: boolean) {\n    this.rotateWorld = flag;\n    this._getAngles();\n  }\n\n  /**\n   * 计算 MV 矩阵，为相机矩阵的逆矩阵\n   */\n  public getViewTransform(): mat4 {\n    return mat4.invert(mat4.create(), this.matrix)!;\n  }\n\n  public getWorldTransform(): mat4 {\n    return this.matrix;\n  }\n\n  /**\n   * 设置相机矩阵\n   */\n  public setMatrix(matrix: mat4) {\n    this.matrix = matrix;\n    this._update();\n    return this;\n  }\n\n  public setAspect(aspect: number) {\n    this.setPerspective(this.near, this.far, this.fov, aspect);\n    return this;\n  }\n\n  /**\n   * Sets an offset in a larger frustum, used in PixelPicking\n   */\n  public setViewOffset(\n    fullWidth: number,\n    fullHeight: number,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n  ) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === undefined) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1,\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public clearViewOffset() {\n    if (this.view !== undefined) {\n      this.view.enabled = false;\n    }\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public setPerspective(\n    near: number,\n    far: number,\n    fov: number,\n    aspect: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.fov = fov;\n    this.near = near;\n    this.far = far;\n    this.aspect = aspect;\n    mat4.perspective(\n      this.perspective,\n      this.fov * DEG_2_RAD,\n      this.aspect,\n      this.near,\n      this.far,\n    );\n    return this;\n  }\n\n  public setOrthographic(\n    l: number,\n    r: number,\n    t: number,\n    b: number,\n    near: number,\n    far: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n    this.rright = r;\n    this.left = l;\n    this.top = t;\n    this.bottom = b;\n    this.near = near;\n    this.far = far;\n\n    const dx = (this.rright - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.rright + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== undefined && this.view.enabled) {\n      const scaleW =\n        (this.rright - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH =\n        (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n\n    mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n    return this;\n  }\n\n  /**\n   * 设置相机位置\n   */\n  public setPosition(x: number | vec3, y?: number, z?: number) {\n    this._setPosition(x, y, z);\n    this.setFocalPoint(this.focalPoint);\n    return this;\n  }\n\n  /**\n   * 设置视点位置\n   */\n  public setFocalPoint(x: number | vec3, y?: number, z?: number) {\n    let up = vec3.fromValues(0, 1, 0);\n    this.focalPoint = createVec3(x, y, z);\n\n    if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n      const d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      x = d[0];\n      y = d[1] as number;\n      z = d[2] as number;\n      const r = vec3.length(d);\n      const el = Math.asin(y / r) * RAD_2_DEG;\n      const az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n      const m = mat4.create();\n      mat4.rotateY(m, m, az * DEG_2_RAD);\n      mat4.rotateX(m, m, el * DEG_2_RAD);\n      up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n    }\n\n    mat4.invert(\n      this.matrix,\n      mat4.lookAt(mat4.create(), this.position, this.focalPoint, up),\n    );\n\n    this._getAxes();\n    this._getDistance();\n    this._getAngles();\n    return this;\n  }\n\n  /**\n   * 固定当前视点，按指定距离放置相机\n   */\n  public setDistance(d: number) {\n    if (this.distance === d || d < 0) {\n      return;\n    }\n\n    this.distance = d;\n\n    if (this.distance < 0.0002) {\n      this.distance = 0.0002;\n    }\n    this.dollyingStep = this.distance / 100;\n\n    const pos = vec3.create();\n    d = this.distance;\n    const n = this.forward;\n    const f = this.focalPoint;\n\n    pos[0] = d * n[0] + f[0];\n    pos[1] = d * n[1] + f[1];\n    pos[2] = d * n[2] + f[2];\n\n    this._setPosition(pos);\n    return this;\n  }\n\n  public setMaxDistance(d: number) {\n    this.maxDistance = d;\n    return this;\n  }\n\n  public setMinDistance(d: number) {\n    this.minDistance = d;\n    return this;\n  }\n\n  /**\n   * Changes the initial azimuth of the camera\n   */\n  public changeAzimuth(az: number) {\n    this.setAzimuth(this.azimuth + az);\n    return this;\n  }\n\n  /**\n   * Changes the initial elevation of the camera\n   */\n  public changeElevation(el: number) {\n    this.setElevation(this.elevation + el);\n    return this;\n  }\n\n  /**\n   * Changes the initial roll of the camera\n   */\n  public changeRoll(rl: number) {\n    this.setRoll(this.roll + rl);\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the azimuth in degrees\n   */\n  public setAzimuth(az: number) {\n    this.azimuth = getAngle(az);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  public getAzimuth() {\n    return this.azimuth;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the elevation in degrees\n   */\n  public setElevation(el: number) {\n    this.elevation = getAngle(el);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} angle the roll angle\n   */\n  public setRoll(angle: number) {\n    this.roll = getAngle(angle);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * Changes the azimuth and elevation with respect to the current camera axes\n   * @param {Number} azimuth the relative azimuth\n   * @param {Number} elevation the relative elevation\n   * @param {Number} roll the relative roll\n   */\n  public rotate(azimuth: number, elevation: number, roll: number) {\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      azimuth = getAngle(azimuth);\n      elevation = getAngle(elevation);\n      roll = getAngle(roll);\n\n      const rotX = quat.setAxisAngle(\n        quat.create(),\n        [1, 0, 0],\n        (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD,\n      );\n      const rotY = quat.setAxisAngle(\n        quat.create(),\n        [0, 1, 0],\n        (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD,\n      );\n\n      const rotZ = quat.setAxisAngle(\n        quat.create(),\n        [0, 0, 1],\n        roll * DEG_2_RAD,\n      );\n      let rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n      mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else {\n      if (Math.abs(this.elevation + elevation) > 90) {\n        return;\n      }\n      this.relElevation = getAngle(elevation);\n      this.relAzimuth = getAngle(azimuth);\n      this.relRoll = getAngle(roll);\n      this.elevation += this.relElevation;\n      this.azimuth += this.relAzimuth;\n      this.roll += this.relRoll;\n\n      this.computeMatrix();\n    }\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n\n    this._update();\n    return this;\n  }\n\n  /**\n   * 沿水平(right) & 垂直(up)平移相机\n   */\n  public pan(tx: number, ty: number) {\n    const coords = createVec3(tx, ty, 0);\n    const pos = vec3.clone(this.position);\n\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n\n    this._setPosition(pos);\n\n    return this;\n  }\n\n  /**\n   * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n   */\n  public dolly(value: number) {\n    const n = this.forward;\n    const pos = vec3.clone(this.position);\n    let step = value * this.dollyingStep;\n    const updatedDistance = this.distance + value * this.dollyingStep;\n\n    // 限制视点距离范围\n    step =\n      Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) -\n      this.distance;\n    pos[0] += step * n[0];\n    pos[1] += step * n[1];\n    pos[2] += step * n[2];\n\n    this._setPosition(pos);\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      // 重新计算视点距离\n      this._getDistance();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      // 保持视距，移动视点位置\n      vec3.add(this.focalPoint, pos, this.distanceVector);\n    }\n    return this;\n  }\n\n  public createLandmark(\n    name: string,\n    params: {\n      position: vec3;\n      focalPoint: vec3;\n      roll?: number;\n    },\n  ): Landmark {\n    const camera = this.clone();\n    camera.setPosition(params.position);\n    camera.setFocalPoint(params.focalPoint);\n    if (params.roll !== undefined) {\n      camera.setRoll(params.roll);\n    }\n    const landmark = new Landmark(name, camera);\n    this.landmarks.push(landmark);\n    return landmark;\n  }\n\n  public setLandmark(name: string) {\n    const landmark = new Landmark(name, this);\n    this.landmarks.push(landmark);\n    return this;\n  }\n\n  public gotoLandmark(name: string, duration: number = 1000) {\n    const landmark = this.landmarks.find((l) => l.name === name);\n    if (landmark) {\n      if (duration === 0) {\n        landmark.retrieve(this);\n        return;\n      }\n\n      if (this.landmarkAnimationID !== undefined) {\n        window.cancelAnimationFrame(this.landmarkAnimationID);\n      }\n\n      // TODO: do not process events during animation\n      this.interactor.disconnect();\n\n      const destPosition = landmark.getPosition();\n      const destFocalPoint = landmark.getFocalPoint();\n      const destRoll = landmark.getRoll();\n\n      let timeStart: number | undefined;\n      const animate = (timestamp: number) => {\n        if (timeStart === undefined) {\n          timeStart = timestamp;\n        }\n        const elapsed = timestamp - timeStart;\n        // TODO: use better ease function\n        const t = (1 - Math.cos((elapsed / duration) * Math.PI)) / 2;\n\n        const interFocalPoint = vec3.create();\n        const interPosition = vec3.create();\n        let interRoll = 0;\n\n        vec3.lerp(interFocalPoint, this.focalPoint, destFocalPoint, t);\n        vec3.lerp(interPosition, this.position, destPosition, t);\n        interRoll = this.roll * (1 - t) + destRoll * t;\n\n        this.setFocalPoint(interFocalPoint);\n        this.setPosition(interPosition);\n        this.setRoll(interRoll);\n        this.computeMatrix();\n\n        const dist =\n          vec3.dist(interFocalPoint, destFocalPoint) +\n          vec3.dist(interPosition, destPosition);\n        if (dist > 0.01) {\n          //\n        } else {\n          this.setFocalPoint(interFocalPoint);\n          this.setPosition(interPosition);\n          this.setRoll(interRoll);\n          this.computeMatrix();\n          this.interactor.connect();\n          return;\n        }\n\n        if (elapsed < duration) {\n          this.landmarkAnimationID = window.requestAnimationFrame(animate);\n        }\n      };\n\n      window.requestAnimationFrame(animate);\n    }\n  }\n\n  /**\n   * 根据相机矩阵重新计算各种相机参数\n   */\n  private _update() {\n    this._getAxes();\n    this._getPosition();\n    this._getDistance();\n    this._getAngles();\n  }\n\n  /**\n   * 计算相机矩阵\n   */\n  private computeMatrix() {\n    let rotX;\n    let rotY;\n    // 使用四元数描述 3D 旋转\n    // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n    const rotZ = quat.setAxisAngle(\n      quat.create(),\n      [0, 0, 1],\n      this.roll * DEG_2_RAD,\n    );\n\n    mat4.identity(this.matrix);\n\n    // only consider HCS for EXPLORING and ORBITING cameras\n    rotX = quat.setAxisAngle(\n      quat.create(),\n      [1, 0, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.elevation *\n        DEG_2_RAD,\n    );\n    rotY = quat.setAxisAngle(\n      quat.create(),\n      [0, 1, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.azimuth *\n        DEG_2_RAD,\n    );\n\n    let rotQ = quat.multiply(quat.create(), rotY, rotX);\n    rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n    const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      mat4.translate(this.matrix, this.matrix, this.focalPoint);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      mat4.translate(this.matrix, this.matrix, this.position);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n    }\n  }\n\n  /**\n   * Sets the camera position in the camera matrix\n   */\n  private _setPosition(x: number | vec3, y?: number, z?: number) {\n    this.position = createVec3(x, y, z);\n    const m = this.matrix;\n    m[12] = this.position[0];\n    m[13] = this.position[1];\n    m[14] = this.position[2];\n    m[15] = 1;\n  }\n\n  /**\n   * Recalculates axes based on the current matrix\n   */\n  private _getAxes() {\n    vec3.copy(\n      this.right,\n      createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.up,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.forward,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)),\n    );\n    vec3.normalize(this.right, this.right);\n    vec3.normalize(this.up, this.up);\n    vec3.normalize(this.forward, this.forward);\n  }\n\n  /**\n   * Recalculates euler angles based on the current state\n   */\n  private _getAngles() {\n    // Recalculates angles\n    const x = this.distanceVector[0];\n    const y = this.distanceVector[1];\n    const z = this.distanceVector[2];\n    const r = vec3.length(this.distanceVector);\n\n    // FAST FAIL: If there is no distance we cannot compute angles\n    if (r === 0) {\n      this.elevation = 0;\n      this.azimuth = 0;\n      return;\n    }\n\n    if (this.type === CAMERA_TYPE.TRACKING) {\n      this.elevation = Math.asin(y / r) * RAD_2_DEG;\n      this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n    } else {\n      if (this.rotateWorld) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n      }\n    }\n  }\n\n  /**\n   * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n   */\n  private _getPosition() {\n    vec3.copy(\n      this.position,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix)),\n    );\n\n    // 相机位置变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n   */\n  private _getFocalPoint() {\n    vec3.transformMat3(\n      this.distanceVector,\n      [0, 0, -this.distance],\n      mat3.fromMat4(mat3.create(), this.matrix),\n    );\n    vec3.add(this.focalPoint, this.position, this.distanceVector);\n\n    // 视点变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视距\n   */\n  private _getDistance() {\n    this.distanceVector = vec3.subtract(\n      vec3.create(),\n      this.focalPoint,\n      this.position,\n    );\n    this.distance = vec3.length(this.distanceVector);\n    this.dollyingStep = this.distance / 100;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}