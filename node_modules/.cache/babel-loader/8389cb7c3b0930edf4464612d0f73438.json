{"ast":null,"code":"import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nexport default minimumSpanningTree;","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/algorithm/es/mts.js"],"names":["UnionFind","MinBinaryHeap","getEdgesByNodeId","primMST","graphData","weight","selectedEdges","_a","nodes","_b","edges","length","currNode","visited","Set","add","compareWeight","a","b","edgeQueue","id","forEach","edge","insert","isEmpty","currEdge","delMin","source","target","has","push","kruskalMST","weightEdges","map","sort","disjointSet","n","curEdge","shift","connected","union","minimumSpanningTree","algo","algos","prim","kruskal"],"mappings":"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","sourcesContent":["import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nexport default minimumSpanningTree;"]},"metadata":{},"sourceType":"module"}