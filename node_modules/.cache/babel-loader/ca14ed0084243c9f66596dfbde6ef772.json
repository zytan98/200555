{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { vec3 } from 'gl-matrix';\nimport { isNumber } from './is-number';\nexport function getAngle(angle) {\n  if (angle === undefined) {\n    return 0;\n  } else if (angle > 360 || angle < -360) {\n    return angle % 360;\n  }\n\n  return angle;\n}\nexport function createVec3(x, y, z) {\n  if (isNumber(x)) {\n    return vec3.fromValues(x, y, z);\n  }\n\n  if (x.length === 3) {\n    return vec3.clone(x);\n  } // @ts-ignore\n\n\n  return vec3.fromValues(x[0], x[1], x[2]);\n}\nexport function getRotationScale(matrix, result) {\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[4];\n  result[4] = matrix[5];\n  result[5] = matrix[6];\n  result[6] = matrix[8];\n  result[7] = matrix[9];\n  result[8] = matrix[10];\n  return result;\n}\nexport function decodePickingColor(color) {\n  var _color = _slicedToArray(color, 3),\n      i1 = _color[0],\n      i2 = _color[1],\n      i3 = _color[2]; // 1 was added to seperate from no selection\n\n\n  var index = i1 + i2 * 256 + i3 * 65536 - 1;\n  return index;\n}\nexport function encodePickingColor(featureIdx) {\n  return [featureIdx + 1 & 255, featureIdx + 1 >> 8 & 255, featureIdx + 1 >> 8 >> 8 & 255];\n}","map":{"version":3,"sources":["../../src/utils/math.ts"],"names":["angle","isNumber","vec3","x","result","matrix","i1","i2","i3","index","featureIdx"],"mappings":";AAAA,SAAA,IAAA,QAAA,WAAA;AACA,SAAA,QAAA,QAAA,aAAA;AAEA,OAAO,SAAA,QAAA,CAAA,KAAA,EAA6C;AAClD,MAAIA,KAAK,KAAT,SAAA,EAAyB;AACvB,WAAA,CAAA;AADF,GAAA,MAEO,IAAIA,KAAK,GAALA,GAAAA,IAAeA,KAAK,GAAG,CAA3B,GAAA,EAAiC;AACtC,WAAOA,KAAK,GAAZ,GAAA;AACD;;AACD,SAAA,KAAA;AACD;AAED,OAAO,SAAA,UAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAqE;AAC1E,MAAIC,QAAQ,CAAZ,CAAY,CAAZ,EAAiB;AACf,WAAOC,IAAI,CAAJA,UAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAP,CAAOA,CAAP;AACD;;AAED,MAAKC,CAAD,CAAA,MAACA,KAAL,CAAA,EAA8B;AAC5B,WAAOD,IAAI,CAAJA,KAAAA,CAAP,CAAOA,CAAP;AANwE,GAAA,CAS1E;;;AACA,SAAOA,IAAI,CAAJA,UAAAA,CAAgBC,CAAC,CAAjBD,CAAiB,CAAjBA,EAAsBC,CAAC,CAAvBD,CAAuB,CAAvBA,EAA4BC,CAAC,CAApC,CAAoC,CAA7BD,CAAP;AACD;AAED,OAAO,SAAA,gBAAA,CAAA,MAAA,EAAA,MAAA,EAAsD;AAC3DE,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,CAAkB,CAAlBA;AACAA,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYC,MAAM,CAAlBD,EAAkB,CAAlBA;AACA,SAAA,MAAA;AACD;AAED,OAAO,SAAA,kBAAA,CAAA,KAAA,EAAuD;AAAA,MAAA,MAAA,GAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,MACrDE,EADqD,GAAA,MAAA,CAAA,CAAA,CAAA;AAAA,MACjDC,EADiD,GAAA,MAAA,CAAA,CAAA,CAAA;AAAA,MAC7CC,EAD6C,GAAA,MAAA,CAAA,CAAA,CAAA,CAAA,CAE5D;;;AACA,MAAMC,KAAK,GAAGH,EAAE,GAAGC,EAAE,GAAPD,GAAAA,GAAgBE,EAAE,GAAlBF,KAAAA,GAAd,CAAA;AACA,SAAA,KAAA;AACD;AAED,OAAO,SAAA,kBAAA,CAAA,UAAA,EAEqB;AAC1B,SAAO,CACJI,UAAU,GAAX,CAACA,GADI,GAAA,EAEHA,UAAU,GAAX,CAACA,IAAF,CAAEA,GAFG,GAAA,EAGFA,UAAU,GAAX,CAACA,IAAF,CAAEA,IAAH,CAAGA,GAHL,GAAO,CAAP;AAKD","sourcesContent":["import { mat3, mat4, vec3, vec4 } from 'gl-matrix';\nimport { isNumber } from './is-number';\n\nexport function getAngle(angle: number | undefined) {\n  if (angle === undefined) {\n    return 0;\n  } else if (angle > 360 || angle < -360) {\n    return angle % 360;\n  }\n  return angle;\n}\n\nexport function createVec3(x: number | vec3 | vec4, y?: number, z?: number) {\n  if (isNumber(x)) {\n    return vec3.fromValues(x as number, y as number, z as number);\n  }\n\n  if ((x as vec3).length === 3) {\n    return vec3.clone(x as vec3);\n  }\n\n  // @ts-ignore\n  return vec3.fromValues(x[0], x[1], x[2]);\n}\n\nexport function getRotationScale(matrix: mat4, result: mat3) {\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[4];\n  result[4] = matrix[5];\n  result[5] = matrix[6];\n  result[6] = matrix[8];\n  result[7] = matrix[9];\n  result[8] = matrix[10];\n  return result;\n}\n\nexport function decodePickingColor(color: Uint8Array): number {\n  const [i1, i2, i3] = color;\n  // 1 was added to seperate from no selection\n  const index = i1 + i2 * 256 + i3 * 65536 - 1;\n  return index;\n}\n\nexport function encodePickingColor(\n  featureIdx: number,\n): [number, number, number] {\n  return [\n    (featureIdx + 1) & 255,\n    ((featureIdx + 1) >> 8) & 255,\n    (((featureIdx + 1) >> 8) >> 8) & 255,\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}