{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { gl, isSafari } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { extractUniforms } from '../utils/uniform';\nimport { getColorStateDescriptors, getCullMode, getDepthStencilStateDescriptor, primitiveMap } from './constants';\nimport WebGPUBuffer from './WebGPUBuffer'; // @ts-ignore\n\nfunction concatenate(resultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var arr = _arrays[_i];\n    totalLength += arr.length;\n  }\n\n  var result = new resultConstructor(totalLength);\n  var offset = 0;\n\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var _arr = _arrays2[_i2];\n    result.set(_arr, offset);\n    offset += _arr.length;\n  }\n\n  return result;\n}\n\nvar WebGPUModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n\n  /**\n   * vertex\n   */\n\n  /**\n   * indices's buffer\n   */\n  function WebGPUModel(engine, options) {\n    _classCallCheck(this, WebGPUModel);\n\n    this.engine = engine;\n    this.options = options;\n    this.pipelineLayout = void 0;\n    this.renderPipeline = void 0;\n    this.uniformsBindGroupLayout = void 0;\n    this.uniformBindGroup = void 0;\n    this.uniformBuffer = void 0;\n    this.uniforms = {};\n    this.uniformGPUBufferLayout = [];\n    this.attributeCache = {};\n    this.indexBuffer = void 0;\n    this.indexCount = void 0;\n  }\n\n  _createClass(WebGPUModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _this$options, vs, fs, attributes, uniforms, primitive, count, elements, depth, blend, stencil, cull, instances, _yield$this$compilePi, vertexStage, fragmentStage, vertexState, descriptor;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$options = this.options, vs = _this$options.vs, fs = _this$options.fs, attributes = _this$options.attributes, uniforms = _this$options.uniforms, primitive = _this$options.primitive, count = _this$options.count, elements = _this$options.elements, depth = _this$options.depth, blend = _this$options.blend, stencil = _this$options.stencil, cull = _this$options.cull, instances = _this$options.instances; // build shaders first\n\n                _context.next = 3;\n                return this.compilePipelineStageDescriptor(vs, fs, null);\n\n              case 3:\n                _yield$this$compilePi = _context.sent;\n                vertexStage = _yield$this$compilePi.vertexStage;\n                fragmentStage = _yield$this$compilePi.fragmentStage;\n\n                if (uniforms) {\n                  // create uniform bind groups & layout\n                  this.buildUniformBindGroup(uniforms);\n                }\n\n                if (elements) {\n                  this.indexBuffer = elements.get();\n                  this.indexCount = elements.indexCount;\n                } // TODO: instanced array\n\n\n                vertexState = {\n                  vertexBuffers: Object.keys(attributes).map(function (attributeName, i) {\n                    var attribute = attributes[attributeName];\n\n                    var _attribute$get = attribute.get(),\n                        arrayStride = _attribute$get.arrayStride,\n                        stepMode = _attribute$get.stepMode,\n                        ats = _attribute$get.attributes;\n\n                    _this.attributeCache[attributeName] = attribute;\n                    return {\n                      arrayStride: arrayStride,\n                      stepMode: stepMode,\n                      attributes: ats\n                    };\n                  })\n                };\n                descriptor = {\n                  sampleCount: this.engine.mainPassSampleCount,\n                  primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n                  rasterizationState: _objectSpread(_objectSpread({}, this.getDefaultRasterizationStateDescriptor()), {}, {\n                    // TODO: support frontface\n                    cullMode: getCullMode({\n                      cull: cull\n                    })\n                  }),\n                  depthStencilState: getDepthStencilStateDescriptor({\n                    depth: depth,\n                    stencil: stencil\n                  }),\n                  colorStates: getColorStateDescriptors({\n                    blend: blend\n                  }, this.engine.options.swapChainFormat),\n                  layout: this.pipelineLayout,\n                  vertexStage: vertexStage,\n                  fragmentStage: fragmentStage,\n                  vertexState: vertexState\n                }; // create pipeline\n\n                this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var _this2 = this;\n\n      var renderPass = this.engine.getCurrentRenderPass();\n\n      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(options.uniforms || {}));\n\n      var bindGroupBindings = []; // TODO: uniform 发生修改\n\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = _typeof(uniforms[uniformName]);\n\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT) {\n          var _this2$uniformGPUBuff;\n\n          var offset = (_this2$uniformGPUBuff = _this2.uniformGPUBufferLayout.find(function (_ref) {\n            var name = _ref.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff === void 0 ? void 0 : _this2$uniformGPUBuff.offset;\n\n          if (offset !== null) {\n            _this2.uniformBuffer.subData({\n              // @ts-ignore\n              data: uniforms[uniformName],\n              // @ts-ignore\n              offset: offset\n            });\n          }\n        } else {\n          var _this2$uniformGPUBuff2;\n\n          var _offset = (_this2$uniformGPUBuff2 = _this2.uniformGPUBufferLayout.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff2 === void 0 ? void 0 : _this2$uniformGPUBuff2.offset;\n\n          if (_offset !== null) {\n            var textureOrFramebuffer = uniforms[uniformName].get();\n\n            var _ref3 = // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer,\n                texture = _ref3.texture,\n                sampler = _ref3.sampler;\n\n            if (sampler) {\n              bindGroupBindings.push({\n                // @ts-ignore\n                binding: _offset,\n                resource: sampler\n              }); // @ts-ignore\n\n              _offset++;\n            }\n\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: _offset,\n              resource: texture.createView()\n            });\n          }\n        }\n      });\n\n      if (this.uniformBuffer) {\n        bindGroupBindings[0] = {\n          binding: 0,\n          resource: {\n            buffer: this.uniformBuffer.get() // 返回 GPUBuffer 原生对象\n\n          }\n        };\n      }\n\n      this.uniformBindGroup = this.engine.device.createBindGroup({\n        layout: this.uniformsBindGroupLayout,\n        entries: bindGroupBindings\n      });\n\n      if (this.renderPipeline) {\n        renderPass.setPipeline(this.renderPipeline);\n      }\n\n      renderPass.setBindGroup(0, this.uniformBindGroup);\n\n      if (this.indexBuffer) {\n        renderPass.setIndexBuffer(this.indexBuffer.get(), WebGPUConstants.IndexFormat.Uint32, 0);\n      }\n\n      Object.keys(this.attributeCache).forEach(function (attributeName, i) {\n        renderPass.setVertexBuffer(0 + i, _this2.attributeCache[attributeName].get().buffer, 0);\n      }); // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n\n      if (this.indexBuffer) {\n        renderPass.drawIndexed(this.indexCount, this.options.instances || 1, 0, 0, 0);\n      } else {\n        renderPass.draw(this.options.count || 0, this.options.instances || 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"compilePipelineStageDescriptor\",\n    value: function () {\n      var _compilePipelineStageDescriptor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(vertexCode, fragmentCode, defines) {\n        var shaderVersion, vertexShader, fragmentShader;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                shaderVersion = '#version 450\\n';\n                vertexShader = vertexCode;\n                fragmentShader = fragmentCode;\n\n                if (this.engine.options.useWGSL) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 6;\n                return this.compileShaderToSpirV(vertexCode, 'vertex', shaderVersion);\n\n              case 6:\n                vertexShader = _context2.sent;\n                _context2.next = 9;\n                return this.compileShaderToSpirV(fragmentCode, 'fragment', shaderVersion);\n\n              case 9:\n                fragmentShader = _context2.sent;\n\n              case 10:\n                return _context2.abrupt(\"return\", this.createPipelineStageDescriptor(vertexShader, fragmentShader));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function compilePipelineStageDescriptor(_x, _x2, _x3) {\n        return _compilePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compilePipelineStageDescriptor;\n    }()\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"createPipelineStageDescriptor\",\n    value: function createPipelineStageDescriptor(vertexShader, fragmentShader) {\n      return {\n        vertexStage: {\n          module: this.engine.device.createShaderModule({\n            code: vertexShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        },\n        fragmentStage: {\n          module: this.engine.device.createShaderModule({\n            code: fragmentShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        }\n      };\n    }\n    /**\n     * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n     */\n\n  }, {\n    key: \"getDefaultRasterizationStateDescriptor\",\n    value: function getDefaultRasterizationStateDescriptor() {\n      return {\n        frontFace: WebGPUConstants.FrontFace.CCW,\n        cullMode: WebGPUConstants.CullMode.None,\n        depthBias: 0,\n        depthBiasSlopeScale: 0,\n        depthBiasClamp: 0\n      };\n    }\n  }, {\n    key: \"buildUniformBindGroup\",\n    value: function buildUniformBindGroup(uniforms) {\n      var _this3 = this;\n\n      var offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n\n      var mergedUniformData = concatenate.apply(void 0, [Float32Array].concat(_toConsumableArray(Object.keys(uniforms).map(function (uniformName) {\n        if (uniforms[uniformName]) {\n          _this3.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset: offset\n          }); // @ts-ignore\n\n\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }))));\n      var entries = [];\n      var hasUniform = false;\n\n      if (mergedUniformData.length) {\n        hasUniform = true; // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n\n        entries.push({\n          // TODO: 暂时都绑定到 slot 0\n          binding: 0,\n          visibility: WebGPUConstants.ShaderStage.Fragment | WebGPUConstants.ShaderStage.Vertex,\n          // TODO: 暂时 VS 和 FS 都可见\n          type: WebGPUConstants.BindingType.UniformBuffer\n        });\n      } // 声明 texture & sampler\n\n\n      Object.keys(uniforms).filter(function (uniformName) {\n        return uniforms[uniformName] === null;\n      }).forEach(function (uniformName, i) {\n        _this3.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0)\n        });\n\n        entries.push({\n          // Sampler\n          binding: i * 2 + (hasUniform ? 1 : 0),\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.Sampler\n        }, {\n          // Texture view\n          binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.SampledTexture\n        });\n      });\n      this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n        // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n        // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n        // @see https://github.com/antvis/GWebGPUEngine/issues/5\n        entries: entries\n      });\n      this.pipelineLayout = this.engine.device.createPipelineLayout({\n        bindGroupLayouts: [this.uniformsBindGroupLayout]\n      });\n\n      if (hasUniform) {\n        this.uniformBuffer = new WebGPUBuffer(this.engine, {\n          // TODO: 处理 Struct 和 boolean\n          // @ts-ignore\n          data: mergedUniformData instanceof Array ? // @ts-ignore\n          new Float32Array(mergedUniformData) : mergedUniformData,\n          usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n        });\n      }\n    }\n  }]);\n\n  return WebGPUModel;\n}();\n\nexport { WebGPUModel as default };","map":{"version":3,"sources":["../../src/webgpu/WebGPUModel.ts"],"names":["arrays","totalLength","arr","result","offset","WebGPUModel","pipelineLayout","renderPipeline","uniformsBindGroupLayout","uniformBindGroup","uniformBuffer","uniforms","uniformGPUBufferLayout","attributeCache","indexBuffer","indexCount","engine","options","vs","fs","attributes","primitive","count","elements","depth","blend","stencil","cull","instances","vertexStage","fragmentStage","vertexState","vertexBuffers","attribute","arrayStride","stepMode","ats","descriptor","sampleCount","primitiveTopology","primitiveMap","gl","rasterizationState","cullMode","getCullMode","depthStencilState","getDepthStencilStateDescriptor","colorStates","getColorStateDescriptors","layout","extractUniforms","renderPass","bindGroupBindings","Object","type","Array","name","data","textureOrFramebuffer","texture","sampler","binding","resource","buffer","entries","WebGPUConstants","vertexCode","fragmentCode","defines","shaderVersion","vertexShader","fragmentShader","useWGSL","source","module","code","isWHLSL","isSafari","entryPoint","frontFace","depthBias","depthBiasSlopeScale","depthBiasClamp","mergedUniformData","hasUniform","visibility","UniformBuffer","i","Sampler","SampledTexture","bindGroupLayouts","usage","CopyDst"],"mappings":"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","sourcesContent":["import {\n  gl,\n  IModel,\n  IModelDrawOptions,\n  IModelInitializationOptions,\n  isSafari,\n  IUniform,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { extractUniforms } from '../utils/uniform';\nimport {\n  getColorStateDescriptors,\n  getCullMode,\n  getDepthStencilStateDescriptor,\n  primitiveMap,\n} from './constants';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUTexture2D from './WebGPUTexture2D';\n\n// @ts-ignore\nfunction concatenate(resultConstructor, ...arrays) {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.length;\n  }\n  const result = new resultConstructor(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nexport default class WebGPUModel implements IModel {\n  private pipelineLayout: GPUPipelineLayout;\n  private renderPipeline: GPURenderPipeline;\n  private uniformsBindGroupLayout: GPUBindGroupLayout;\n  private uniformBindGroup: GPUBindGroup;\n  private uniformBuffer: WebGPUBuffer;\n\n  private uniforms: {\n    [key: string]: IUniform;\n  } = {};\n\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  /**\n   * vertex\n   */\n  private attributeCache: {\n    [attributeName: string]: WebGPUAttribute;\n  } = {};\n\n  /**\n   * indices's buffer\n   */\n  private indexBuffer: WebGPUBuffer;\n  private indexCount: number;\n\n  constructor(\n    private engine: WebGPUEngine,\n    private options: IModelInitializationOptions,\n  ) {}\n\n  public async init() {\n    const {\n      vs,\n      fs,\n      attributes,\n      uniforms,\n      primitive,\n      count,\n      elements,\n      depth,\n      blend,\n      stencil,\n      cull,\n      instances,\n    } = this.options;\n\n    // build shaders first\n    const {\n      vertexStage,\n      fragmentStage,\n    } = await this.compilePipelineStageDescriptor(vs, fs, null);\n\n    if (uniforms) {\n      // create uniform bind groups & layout\n      this.buildUniformBindGroup(uniforms);\n    }\n\n    if (elements) {\n      this.indexBuffer = (elements as WebGPUElements).get() as WebGPUBuffer;\n      this.indexCount = (elements as WebGPUElements).indexCount;\n    }\n\n    // TODO: instanced array\n\n    const vertexState = {\n      vertexBuffers: Object.keys(attributes).map((attributeName, i) => {\n        const attribute = attributes[attributeName] as WebGPUAttribute;\n        const { arrayStride, stepMode, attributes: ats } = attribute.get();\n        this.attributeCache[attributeName] = attribute;\n        return {\n          arrayStride,\n          stepMode,\n          attributes: ats,\n        };\n      }),\n    };\n\n    const descriptor = {\n      sampleCount: this.engine.mainPassSampleCount,\n      primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n      rasterizationState: {\n        ...this.getDefaultRasterizationStateDescriptor(),\n        // TODO: support frontface\n        cullMode: getCullMode({ cull }),\n      },\n      depthStencilState: getDepthStencilStateDescriptor({\n        depth,\n        stencil,\n      }),\n      colorStates: getColorStateDescriptors(\n        { blend },\n        this.engine.options.swapChainFormat!,\n      ),\n      layout: this.pipelineLayout,\n      vertexStage,\n      fragmentStage,\n      vertexState,\n    };\n\n    // create pipeline\n    this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n  }\n\n  public addUniforms(uniforms: { [key: string]: IUniform }): void {\n    this.uniforms = {\n      ...this.uniforms,\n      ...extractUniforms(uniforms),\n    };\n  }\n\n  public draw(options: IModelDrawOptions): void {\n    const renderPass = this.engine.getCurrentRenderPass();\n\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {\n      ...this.uniforms,\n      ...extractUniforms(options.uniforms || {}),\n    };\n\n    const bindGroupBindings: GPUBindGroupEntry[] = [];\n\n    // TODO: uniform 发生修改\n    Object.keys(uniforms).forEach((uniformName: string) => {\n      const type = typeof uniforms[uniformName];\n      if (\n        type === 'boolean' ||\n        type === 'number' ||\n        Array.isArray(uniforms[uniformName]) ||\n        // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT\n      ) {\n        const offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          this.uniformBuffer.subData({\n            // @ts-ignore\n            data: uniforms[uniformName],\n            // @ts-ignore\n            offset,\n          });\n        }\n      } else {\n        let offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          const textureOrFramebuffer = (uniforms[uniformName] as\n            | WebGPUTexture2D\n            | WebGPUFramebuffer).get();\n          const { texture, sampler } =\n            // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer;\n          if (sampler) {\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: offset,\n              resource: sampler,\n            });\n            // @ts-ignore\n            offset++;\n          }\n          bindGroupBindings.push({\n            // @ts-ignore\n            binding: offset,\n            resource: texture.createView(),\n          });\n        }\n      }\n    });\n\n    if (this.uniformBuffer) {\n      bindGroupBindings[0] = {\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(), // 返回 GPUBuffer 原生对象\n        },\n      };\n    }\n\n    this.uniformBindGroup = this.engine.device.createBindGroup({\n      layout: this.uniformsBindGroupLayout,\n      entries: bindGroupBindings,\n    });\n\n    if (this.renderPipeline) {\n      renderPass.setPipeline(this.renderPipeline);\n    }\n\n    renderPass.setBindGroup(0, this.uniformBindGroup);\n\n    if (this.indexBuffer) {\n      renderPass.setIndexBuffer(\n        this.indexBuffer.get(),\n        WebGPUConstants.IndexFormat.Uint32,\n        0,\n      );\n    }\n\n    Object.keys(this.attributeCache).forEach((attributeName: string, i) => {\n      renderPass.setVertexBuffer(\n        0 + i,\n        this.attributeCache[attributeName].get().buffer,\n        0,\n      );\n    });\n\n    // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n    if (this.indexBuffer) {\n      renderPass.drawIndexed(\n        this.indexCount,\n        this.options.instances || 1,\n        0,\n        0,\n        0,\n      );\n    } else {\n      renderPass.draw(\n        this.options.count || 0,\n        this.options.instances || 0,\n        0,\n        0,\n      );\n    }\n  }\n\n  public destroy(): void {\n    throw new Error('Method not implemented.');\n  }\n\n  private async compilePipelineStageDescriptor(\n    vertexCode: string,\n    fragmentCode: string,\n    defines: string | null,\n  ): Promise<\n    Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'>\n  > {\n    const shaderVersion = '#version 450\\n';\n\n    let vertexShader: Uint32Array | string = vertexCode;\n    let fragmentShader: Uint32Array | string = fragmentCode;\n    if (!this.engine.options.useWGSL) {\n      vertexShader = await this.compileShaderToSpirV(\n        vertexCode,\n        'vertex',\n        shaderVersion,\n      );\n      fragmentShader = await this.compileShaderToSpirV(\n        fragmentCode,\n        'fragment',\n        shaderVersion,\n      );\n    }\n\n    return this.createPipelineStageDescriptor(vertexShader, fragmentShader);\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private createPipelineStageDescriptor(\n    vertexShader: Uint32Array | string,\n    fragmentShader: Uint32Array | string,\n  ): Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'> {\n    return {\n      vertexStage: {\n        module: this.engine.device.createShaderModule({\n          code: vertexShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.engine.device.createShaderModule({\n          code: fragmentShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  /**\n   * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n   */\n  private getDefaultRasterizationStateDescriptor(): GPURasterizationStateDescriptor {\n    return {\n      frontFace: WebGPUConstants.FrontFace.CCW,\n      cullMode: WebGPUConstants.CullMode.None,\n      depthBias: 0,\n      depthBiasSlopeScale: 0,\n      depthBiasClamp: 0,\n    };\n  }\n\n  private buildUniformBindGroup(uniforms: { [key: string]: IUniform }) {\n    let offset = 0;\n    // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n    const mergedUniformData = concatenate(\n      Float32Array,\n      ...Object.keys(uniforms).map((uniformName) => {\n        if (uniforms[uniformName]) {\n          this.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset,\n          });\n          // @ts-ignore\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }),\n    );\n\n    const entries: GPUBindGroupLayoutEntry[] = [];\n    let hasUniform = false;\n    if (mergedUniformData.length) {\n      hasUniform = true;\n      // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n      entries.push({\n        // TODO: 暂时都绑定到 slot 0\n        binding: 0,\n        visibility:\n          WebGPUConstants.ShaderStage.Fragment |\n          WebGPUConstants.ShaderStage.Vertex, // TODO: 暂时 VS 和 FS 都可见\n        type: WebGPUConstants.BindingType.UniformBuffer,\n      });\n    }\n\n    // 声明 texture & sampler\n    Object.keys(uniforms)\n      .filter((uniformName) => uniforms[uniformName] === null)\n      .forEach((uniformName, i) => {\n        this.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0),\n        });\n        entries.push(\n          {\n            // Sampler\n            binding: i * 2 + (hasUniform ? 1 : 0),\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.Sampler,\n          },\n          {\n            // Texture view\n            binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.SampledTexture,\n          },\n        );\n      });\n\n    this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n      // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n      // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n      // @see https://github.com/antvis/GWebGPUEngine/issues/5\n      entries,\n    });\n\n    this.pipelineLayout = this.engine.device.createPipelineLayout({\n      bindGroupLayouts: [this.uniformsBindGroupLayout],\n    });\n\n    if (hasUniform) {\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}