{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AABB } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\nexport var\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nMerged = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Merged, _Geometry);\n\n  var _super = _createSuper(Merged);\n\n  function Merged() {\n    _classCallCheck(this, Merged);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Merged, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config$geometri = this.config.geometries,\n          geometries = _this$config$geometri === void 0 ? [] : _this$config$geometri;\n      var mergedComponent = this.getComponent();\n      mergedComponent.aabb = new AABB();\n      var mergedAttributes = [];\n      var mergedIndices = [];\n      var indexOffset = 0;\n      geometries.forEach(function (geometry) {\n        var aabb = geometry.aabb,\n            indices = geometry.indices,\n            vertexCount = geometry.vertexCount,\n            attributes = geometry.attributes; // merge aabb\n\n        mergedComponent.aabb.add(aabb);\n        mergedComponent.vertexCount += vertexCount; // merge indices\n\n        if (indices) {\n          mergedIndices.push.apply(mergedIndices, _toConsumableArray(indices.map(function (index) {\n            return index + indexOffset;\n          })));\n        }\n\n        indexOffset += vertexCount; // merge attributes\n\n        attributes.forEach(function (attribute, i) {\n          if (!mergedAttributes[i]) {\n            mergedAttributes[i] = attribute;\n            mergedAttributes[i].dirty = true;\n          } else {\n            if (attribute.data) {\n              if (isNumber(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].push(attribute.data);\n              } else if (isTypedArray(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].data = merge( // @ts-ignore\n                mergedAttributes[i].data, attribute.data);\n              } else {\n                // @ts-ignore\n                mergedAttributes[i].data = mergedAttributes[i].data.concat(attribute.data);\n              }\n            }\n          }\n        });\n      });\n      mergedComponent.attributes = mergedAttributes;\n      mergedComponent.indices = Uint32Array.from(mergedIndices);\n      mergedComponent.dirty = true;\n    }\n  }]);\n\n  return Merged;\n}(Geometry)) || _class);","map":{"version":3,"sources":["../../src/geometry/Merged.ts"],"names":["injectable","Merged","geometries","mergedComponent","mergedAttributes","mergedIndices","indexOffset","aabb","indices","vertexCount","attributes","geometry","index","attribute","isNumber","isTypedArray","merge","Uint32Array"],"mappings":"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","sourcesContent":["import { AABB, GeometryComponent } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\n\nexport interface IMergedGeometryParams {\n  geometries: GeometryComponent[];\n}\n\n@injectable()\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nexport class Merged extends Geometry<Partial<IMergedGeometryParams>> {\n  protected onEntityCreated() {\n    const { geometries = [] } = this.config;\n\n    const mergedComponent = this.getComponent();\n    mergedComponent.aabb = new AABB();\n\n    const mergedAttributes: GeometryComponent['attributes'] = [];\n    const mergedIndices: number[] = [];\n    let indexOffset = 0;\n    geometries.forEach((geometry) => {\n      const { aabb, indices, vertexCount, attributes } = geometry;\n\n      // merge aabb\n      mergedComponent.aabb.add(aabb);\n      mergedComponent.vertexCount += vertexCount;\n\n      // merge indices\n      if (indices) {\n        mergedIndices.push(...indices.map((index) => index + indexOffset));\n      }\n      indexOffset += vertexCount;\n\n      // merge attributes\n      attributes.forEach((attribute, i) => {\n        if (!mergedAttributes[i]) {\n          mergedAttributes[i] = attribute;\n          mergedAttributes[i].dirty = true;\n        } else {\n          if (attribute.data) {\n            if (isNumber(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].push(attribute.data);\n            } else if (isTypedArray(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].data = merge(\n                // @ts-ignore\n                mergedAttributes[i].data,\n                attribute.data,\n              );\n            } else {\n              // @ts-ignore\n              mergedAttributes[i].data = mergedAttributes[i].data.concat(\n                attribute.data,\n              );\n            }\n          }\n        }\n      });\n    });\n\n    mergedComponent.attributes = mergedAttributes;\n    mergedComponent.indices = Uint32Array.from(mergedIndices);\n    mergedComponent.dirty = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}