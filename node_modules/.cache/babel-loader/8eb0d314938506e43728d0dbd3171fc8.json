{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, isNil, isFunction, isObject } from '@antv/util';\nimport { vec2 } from '@antv/matrix-util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\n\nvar Circle =\n/** @class */\nfunction (_super) {\n  __extends(Circle, _super);\n\n  function Circle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Circle.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: null,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n\n  Circle.prototype.getLinePath = function () {\n    var center = this.get('center');\n    var x = center.x;\n    var y = center.y;\n    var rx = this.get('radius');\n    var ry = rx;\n    var startAngle = this.get('startAngle');\n    var endAngle = this.get('endAngle');\n    var path = [];\n\n    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n      path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];\n    } else {\n      var startPoint = this.getCirclePoint(startAngle);\n      var endPoint = this.getCirclePoint(endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];\n    }\n\n    return path;\n  };\n\n  Circle.prototype.getTickPoint = function (tickValue) {\n    var startAngle = this.get('startAngle');\n    var endAngle = this.get('endAngle');\n    var angle = startAngle + (endAngle - startAngle) * tickValue;\n    return this.getCirclePoint(angle);\n  }; // 获取垂直于坐标轴的向量\n\n\n  Circle.prototype.getSideVector = function (offset, point) {\n    var center = this.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n    var factor = this.get('verticalFactor');\n    var vecLen = vec2.length(vector);\n    vec2.scale(vector, vector, factor * offset / vecLen);\n    return vector;\n  }; // 获取沿坐标轴方向的向量\n\n\n  Circle.prototype.getAxisVector = function (point) {\n    var center = this.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n    return [vector[1], -1 * vector[0]]; // 获取顺时针方向的向量\n  }; // 根据圆心和半径获取点\n\n\n  Circle.prototype.getCirclePoint = function (angle, radius) {\n    var center = this.get('center');\n    radius = radius || this.get('radius');\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n\n\n  Circle.prototype.canProcessOverlap = function (name) {\n    var labelCfg = this.get('label'); // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    } // 默认所有 overlap 都可执行\n\n\n    return true;\n  };\n\n  Circle.prototype.processOverlap = function (labelGroup) {\n    var _this = this;\n\n    var labelCfg = this.get('label');\n    var titleCfg = this.get('title');\n    var verticalLimitLength = this.get('verticalLimitLength');\n    var labelOffset = labelCfg.offset;\n    var limitLength = verticalLimitLength;\n    var titleHeight = 0;\n    var titleSpacing = 0;\n\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n\n    var overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, function (name) {\n      if (labelCfg[name] && _this.canProcessOverlap(name)) {\n        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        var length_1 = labelGroup.getCanvasBBox().height; // 如果用户没有设置 offset，则自动计算\n\n        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n      }\n    }\n  };\n\n  Circle.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n    var _this = this;\n\n    var hasAdjusted = false;\n    var util = OverlapUtil[name];\n\n    if (limitLength > 0) {\n      if (value === true) {\n        // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n        hasAdjusted = util.getDefault()(false, labelGroup, limitLength);\n      } else if (isFunction(value)) {\n        // 回调函数形式的配置： 用户可以传入回调函数\n        hasAdjusted = value(false, labelGroup, limitLength);\n      } else if (isObject(value)) {\n        // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n        var overlapCfg = value;\n\n        if (util[overlapCfg.type]) {\n          hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);\n        }\n      } else if (util[value]) {\n        // 字符串类型的配置：按照名称执行 overlap 处理方法\n        hasAdjusted = util[value](false, labelGroup, limitLength);\n      }\n    }\n\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        var labels = labelGroup.getChildren();\n        var verticalFactor_1 = this.get('verticalFactor');\n        each(labels, function (label) {\n          var textAlign = label.attr('textAlign');\n\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n\n      each(children, function (label) {\n        if (!label.get('visible')) {\n          if (_this.get('isRegister')) {\n            // 已经注册过了，则删除\n            _this.unregisterElement(label);\n          }\n\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  };\n\n  return Circle;\n}(AxisBase);\n\nexport default Circle;","map":{"version":3,"sources":["../../src/axis/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { each, isNil, isFunction, isObject } from '@antv/util';\nimport { vec2 } from '@antv/matrix-util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: null, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });\n    };\n    Circle.prototype.getLinePath = function () {\n        var center = this.get('center');\n        var x = center.x;\n        var y = center.y;\n        var rx = this.get('radius');\n        var ry = rx;\n        var startAngle = this.get('startAngle');\n        var endAngle = this.get('endAngle');\n        var path = [];\n        if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n            path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];\n        }\n        else {\n            var startPoint = this.getCirclePoint(startAngle);\n            var endPoint = this.getCirclePoint(endAngle);\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n            var sweep = startAngle > endAngle ? 0 : 1;\n            path = [\n                ['M', x, y],\n                ['L', startPoint.x, startPoint.y],\n                ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y],\n                ['L', x, y],\n            ];\n        }\n        return path;\n    };\n    Circle.prototype.getTickPoint = function (tickValue) {\n        var startAngle = this.get('startAngle');\n        var endAngle = this.get('endAngle');\n        var angle = startAngle + (endAngle - startAngle) * tickValue;\n        return this.getCirclePoint(angle);\n    };\n    // 获取垂直于坐标轴的向量\n    Circle.prototype.getSideVector = function (offset, point) {\n        var center = this.get('center');\n        var vector = [point.x - center.x, point.y - center.y];\n        var factor = this.get('verticalFactor');\n        var vecLen = vec2.length(vector);\n        vec2.scale(vector, vector, (factor * offset) / vecLen);\n        return vector;\n    };\n    // 获取沿坐标轴方向的向量\n    Circle.prototype.getAxisVector = function (point) {\n        var center = this.get('center');\n        var vector = [point.x - center.x, point.y - center.y];\n        return [vector[1], -1 * vector[0]]; // 获取顺时针方向的向量\n    };\n    // 根据圆心和半径获取点\n    Circle.prototype.getCirclePoint = function (angle, radius) {\n        var center = this.get('center');\n        radius = radius || this.get('radius');\n        return {\n            x: center.x + Math.cos(angle) * radius,\n            y: center.y + Math.sin(angle) * radius,\n        };\n    };\n    /**\n     * 是否可以执行某一 overlap\n     * @param name\n     */\n    Circle.prototype.canProcessOverlap = function (name) {\n        var labelCfg = this.get('label');\n        // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n        if (name === 'autoRotate') {\n            return isNil(labelCfg.rotate);\n        }\n        // 默认所有 overlap 都可执行\n        return true;\n    };\n    Circle.prototype.processOverlap = function (labelGroup) {\n        var _this = this;\n        var labelCfg = this.get('label');\n        var titleCfg = this.get('title');\n        var verticalLimitLength = this.get('verticalLimitLength');\n        var labelOffset = labelCfg.offset;\n        var limitLength = verticalLimitLength;\n        var titleHeight = 0;\n        var titleSpacing = 0;\n        if (titleCfg) {\n            titleHeight = titleCfg.style.fontSize;\n            titleSpacing = titleCfg.spacing;\n        }\n        if (limitLength) {\n            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n        }\n        var overlapOrder = this.get('overlapOrder');\n        each(overlapOrder, function (name) {\n            if (labelCfg[name] && _this.canProcessOverlap(name)) {\n                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n            }\n        });\n        if (titleCfg) {\n            if (isNil(titleCfg.offset)) {\n                // 调整 title 的 offset\n                var length_1 = labelGroup.getCanvasBBox().height;\n                // 如果用户没有设置 offset，则自动计算\n                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n            }\n        }\n    };\n    Circle.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n        var _this = this;\n        var hasAdjusted = false;\n        var util = OverlapUtil[name];\n        if (limitLength > 0) {\n            if (value === true) {\n                // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n                hasAdjusted = util.getDefault()(false, labelGroup, limitLength);\n            }\n            else if (isFunction(value)) {\n                // 回调函数形式的配置： 用户可以传入回调函数\n                hasAdjusted = value(false, labelGroup, limitLength);\n            }\n            else if (isObject(value)) {\n                // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n                var overlapCfg = value;\n                if (util[overlapCfg.type]) {\n                    hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);\n                }\n            }\n            else if (util[value]) {\n                // 字符串类型的配置：按照名称执行 overlap 处理方法\n                hasAdjusted = util[value](false, labelGroup, limitLength);\n            }\n        }\n        if (name === 'autoRotate') {\n            // 文本旋转后，文本的对齐方式可能就不合适了\n            if (hasAdjusted) {\n                var labels = labelGroup.getChildren();\n                var verticalFactor_1 = this.get('verticalFactor');\n                each(labels, function (label) {\n                    var textAlign = label.attr('textAlign');\n                    if (textAlign === 'center') {\n                        // 居中的文本需要调整旋转度\n                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n                        label.attr('textAlign', newAlign);\n                    }\n                });\n            }\n        }\n        else if (name === 'autoHide') {\n            var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n            each(children, function (label) {\n                if (!label.get('visible')) {\n                    if (_this.get('isRegister')) {\n                        // 已经注册过了，则删除\n                        _this.unregisterElement(label);\n                    }\n                    label.remove(); // 防止 label 数量太多，所以统一删除\n                }\n            });\n        }\n    };\n    return Circle;\n}(AxisBase));\nexport default Circle;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}