{"ast":null,"code":"var SMALL = 1e-10;\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\n\nexport function intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  var intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles\n\n  var innerPoints = intersectionPoints.filter(function (p) {\n    return containedInCircles(p, circles);\n  });\n  var arcArea = 0,\n      polygonArea = 0,\n      i;\n  var arcs = []; // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    var center = getCenter(innerPoints);\n\n    for (i = 0; i < innerPoints.length; ++i) {\n      var p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n\n    innerPoints.sort(function (a, b) {\n      return b.angle - a.angle;\n    }); // iterate over all points, get arc between the points\n    // and update the areas\n\n    var p2 = innerPoints[innerPoints.length - 1];\n\n    for (i = 0; i < innerPoints.length; ++i) {\n      var p1 = innerPoints[i]; // polygon area updates easily ...\n\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved\n\n      var midPoint = {\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2\n      };\n      var arc = null;\n\n      for (var j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          var circle = circles[p1.parentIndex[j]],\n              a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n              a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n          var angleDiff = a2 - a1;\n\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          } // and use that angle to figure out the width of the\n          // arc\n\n\n          var a = a2 - angleDiff / 2;\n          var width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a)\n          }); // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          } // pick the circle whose arc has the smallest width\n\n\n          if (arc === null || arc.width > width) {\n            arc = {\n              circle: circle,\n              width: width,\n              p1: p1,\n              p2: p2\n            };\n          }\n        }\n      }\n\n      if (arc !== null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    var smallest = circles[0];\n\n    for (i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    } // make sure the smallest circle is completely contained in all\n    // the other circles\n\n\n    var disjoint = false;\n\n    for (i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: {\n          x: smallest.x,\n          y: smallest.y + smallest.radius\n        },\n        p2: {\n          x: smallest.x - SMALL,\n          y: smallest.y + smallest.radius\n        },\n        width: smallest.radius * 2\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n/** returns whether a point is contained by all of a list of circles */\n\nexport function containedInCircles(point, circles) {\n  for (var i = 0; i < circles.length; ++i) {\n    if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/** Gets all intersection points between a bunch of circles */\n\nfunction getIntersectionPoints(circles) {\n  var ret = [];\n\n  for (var i = 0; i < circles.length; ++i) {\n    for (var j = i + 1; j < circles.length; ++j) {\n      var intersect = circleCircleIntersection(circles[i], circles[j]);\n\n      for (var k = 0; k < intersect.length; ++k) {\n        var p = intersect[k];\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n\n  return ret;\n}\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\n\n\nexport function circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n/** euclidean distance between two points */\n\nexport function distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\n\nexport function circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  } // completely overlapped\n\n\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n      w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\n\nexport function circleCircleIntersection(p1, p2) {\n  var d = distance(p1, p2),\n      r1 = p1.radius,\n      r2 = p2.radius; // if to far away, or self contained - can't be done\n\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n      h = Math.sqrt(r1 * r1 - a * a),\n      x0 = p1.x + a * (p2.x - p1.x) / d,\n      y0 = p1.y + a * (p2.y - p1.y) / d,\n      rx = -(p2.y - p1.y) * (h / d),\n      ry = -(p2.x - p1.x) * (h / d);\n  return [{\n    x: x0 + rx,\n    y: y0 - ry\n  }, {\n    x: x0 - rx,\n    y: y0 + ry\n  }];\n}\n/** Returns the center of a bunch of points */\n\nexport function getCenter(points) {\n  var center = {\n    x: 0,\n    y: 0\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    center.x += points[i].x;\n    center.y += points[i].y;\n  }\n\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}","map":{"version":3,"sources":["../../../../src/plots/venn/layout/circleintersection.ts"],"names":[],"mappings":"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","sourcesContent":["const SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nexport function intersectionArea(circles, stats?: any) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter(function (p) {\n    return containedInCircles(p, circles);\n  });\n\n  let arcArea = 0,\n    polygonArea = 0,\n    i;\n  const arcs = [];\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort(function (a, b) {\n      return b.angle - a.angle;\n    });\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]],\n            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc === null || arc.width > width) {\n            arc = { circle: circle, width: width, p1: p1, p2: p2 };\n          }\n        }\n      }\n\n      if (arc !== null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nexport function containedInCircles(point, circles) {\n  for (let i = 0; i < circles.length; ++i) {\n    if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (let k = 0; k < intersect.length; ++k) {\n        const p: any = intersect[k];\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nexport function circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nexport function distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nexport function circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nexport function circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2),\n    r1 = p1.radius,\n    r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n    h = Math.sqrt(r1 * r1 - a * a),\n    x0 = p1.x + (a * (p2.x - p1.x)) / d,\n    y0 = p1.y + (a * (p2.y - p1.y)) / d,\n    rx = -(p2.y - p1.y) * (h / d),\n    ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/** Returns the center of a bunch of points */\nexport function getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (let i = 0; i < points.length; ++i) {\n    center.x += points[i].x;\n    center.y += points[i].y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}