{"ast":null,"code":"import { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\n\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length; // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributteStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributteStringMap[item[name]] === undefined) {\n        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;\n      }\n\n      dataArray.push(attributteStringMap[item[name]]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributteStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/@antv/g6-pc/es/util/layout.js"],"names":["Util","isNumber","traverseTree","proccessToFunc","value","defaultV","func","d","buildTextureData","nodes","edges","dataArray","nodeDict","mapIdPos","i","length","n","id","push","x","y","e","source","target","maxEdgePerVetex","offset","dests","len","Math","max","j","dest","array","Float32Array","buildTextureDataWithOneEdgeAttr","attrs","buildTextureDataWithTwoEdgeAttr","attrs1","attrs2","attributesToTextureData","attributeNames","items","attributeNum","attributteStringMap","forEach","item","name","undefined","Object","keys","count","arrayToTextureData","valueArrays","itemNum","_loop_1","valueArray","radialLayout","data","layout","VERTICAL_LAYOUTS","min","Infinity","rScale","radScale","indexOf","node","avgRad","PI","radDiff","radial","r","abs","cos","sin"],"mappings":"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","sourcesContent":["import { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\n\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length; // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributteStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributteStringMap[item[name]] === undefined) {\n        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;\n      }\n\n      dataArray.push(attributteStringMap[item[name]]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributteStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};"]},"metadata":{},"sourceType":"module"}