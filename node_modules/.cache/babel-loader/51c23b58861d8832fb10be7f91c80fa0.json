{"ast":null,"code":"import SVD from './dc/svd';\nimport Matrix from './matrix';\nexport function pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n\n  if (matrix.isEmpty()) {\n    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular\n    // (0xn)*(nx0)*(0xn) = 0xn\n    // (nx0)*(0xn)*(nx0) = nx0\n    return matrix.transpose();\n  }\n\n  let svdSolution = new SVD(matrix, {\n    autoTranspose: true\n  });\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}","map":{"version":3,"sources":["C:/Users/Home/Desktop/cs-2005/node_modules/ml-matrix/src/pseudoInverse.js"],"names":["SVD","Matrix","pseudoInverse","matrix","threshold","Number","EPSILON","checkMatrix","isEmpty","transpose","svdSolution","autoTranspose","U","leftSingularVectors","V","rightSingularVectors","s","diagonal","i","length","Math","abs","mmul","diag"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,UAAhB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,OAAO,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,SAAS,GAAGC,MAAM,CAACC,OAAlD,EAA2D;AAChEH,EAAAA,MAAM,GAAGF,MAAM,CAACM,WAAP,CAAmBJ,MAAnB,CAAT;;AACA,MAAIA,MAAM,CAACK,OAAP,EAAJ,EAAsB;AACpB;AACA;AACA;AACA,WAAOL,MAAM,CAACM,SAAP,EAAP;AACD;;AACD,MAAIC,WAAW,GAAG,IAAIV,GAAJ,CAAQG,MAAR,EAAgB;AAAEQ,IAAAA,aAAa,EAAE;AAAjB,GAAhB,CAAlB;AAEA,MAAIC,CAAC,GAAGF,WAAW,CAACG,mBAApB;AACA,MAAIC,CAAC,GAAGJ,WAAW,CAACK,oBAApB;AACA,MAAIC,CAAC,GAAGN,WAAW,CAACO,QAApB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAAC,CAACG,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AACjC,QAAIE,IAAI,CAACC,GAAL,CAASL,CAAC,CAACE,CAAD,CAAV,IAAiBd,SAArB,EAAgC;AAC9BY,MAAAA,CAAC,CAACE,CAAD,CAAD,GAAO,MAAMF,CAAC,CAACE,CAAD,CAAd;AACD,KAFD,MAEO;AACLF,MAAAA,CAAC,CAACE,CAAD,CAAD,GAAO,GAAP;AACD;AACF;;AAED,SAAOJ,CAAC,CAACQ,IAAF,CAAOrB,MAAM,CAACsB,IAAP,CAAYP,CAAZ,EAAeM,IAAf,CAAoBV,CAAC,CAACH,SAAF,EAApB,CAAP,CAAP;AACD","sourcesContent":["import SVD from './dc/svd';\nimport Matrix from './matrix';\n\nexport function pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n  if (matrix.isEmpty()) {\n    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular\n    // (0xn)*(nx0)*(0xn) = 0xn\n    // (nx0)*(0xn)*(nx0) = nx0\n    return matrix.transpose();\n  }\n  let svdSolution = new SVD(matrix, { autoTranspose: true });\n\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}\n"]},"metadata":{},"sourceType":"module"}