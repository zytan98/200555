{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nvar primitiveUv1Padding = 4.0 / 64;\nvar primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nexport var\n/**\n * borrow from playcanvas:\n * Creates a procedural box-shaped mesh\n */\nBox = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Box, _Geometry);\n\n  var _super = _createSuper(Box);\n\n  function Box() {\n    _classCallCheck(this, Box);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Box, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n          _this$config$widthSeg = _this$config.widthSegments,\n          widthSegments = _this$config$widthSeg === void 0 ? 1 : _this$config$widthSeg,\n          _this$config$heightSe = _this$config.heightSegments,\n          heightSegments = _this$config$heightSe === void 0 ? 1 : _this$config$heightSe,\n          _this$config$depthSeg = _this$config.depthSegments,\n          depthSegments = _this$config$depthSeg === void 0 ? 1 : _this$config$depthSeg,\n          _this$config$halfExte = _this$config.halfExtents,\n          halfExtents = _this$config$halfExte === void 0 ? vec3.fromValues(0.5, 0.5, 0.5) : _this$config$halfExte;\n      var ws = widthSegments;\n      var hs = heightSegments;\n      var ds = depthSegments;\n\n      var _halfExtents = _slicedToArray(halfExtents, 3),\n          hex = _halfExtents[0],\n          hey = _halfExtents[1],\n          hez = _halfExtents[2];\n\n      var corners = [vec3.fromValues(-hex, -hey, hez), vec3.fromValues(hex, -hey, hez), vec3.fromValues(hex, hey, hez), vec3.fromValues(-hex, hey, hez), vec3.fromValues(hex, -hey, -hez), vec3.fromValues(-hex, -hey, -hez), vec3.fromValues(-hex, hey, -hez), vec3.fromValues(hex, hey, -hez)];\n      var faceAxes = [[0, 1, 3], // FRONT\n      [4, 5, 7], // BACK\n      [3, 2, 6], // TOP\n      [1, 0, 4], // BOTTOM\n      [1, 4, 2], // RIGHT\n      [5, 0, 6] // LEFT\n      ];\n      var faceNormals = [[0, 0, 1], // FRONT\n      [0, 0, -1], // BACK\n      [0, 1, 0], // TOP\n      [0, -1, 0], // BOTTOM\n      [1, 0, 0], // RIGHT\n      [-1, 0, 0] // LEFT\n      ];\n      var sides = {\n        FRONT: 0,\n        BACK: 1,\n        TOP: 2,\n        BOTTOM: 3,\n        RIGHT: 4,\n        LEFT: 5\n      };\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var uvs1 = [];\n      var indices = [];\n      var vcounter = 0;\n\n      var generateFace = function generateFace(side, uSegments, vSegments) {\n        var u;\n        var v;\n        var i;\n        var j;\n\n        for (i = 0; i <= uSegments; i++) {\n          for (j = 0; j <= vSegments; j++) {\n            var temp1 = vec3.create();\n            var temp2 = vec3.create();\n            var temp3 = vec3.create();\n            var r = vec3.create();\n            vec3.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n            vec3.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n            vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);\n            vec3.add(r, temp1, temp3);\n            u = i / uSegments;\n            v = j / vSegments;\n            positions.push(r[0], r[1], r[2]);\n            normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n            uvs.push(u, v); // pack as 3x2\n            // 1/3 will be empty, but it's either that or stretched pixels\n            // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n\n            u /= 3;\n            v /= 3;\n            u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n            v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n            u += side % 3 / 3;\n            v += Math.floor(side / 3) / 3;\n            uvs1.push(u, v);\n\n            if (i < uSegments && j < vSegments) {\n              indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n              indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n            }\n\n            vcounter++;\n          }\n        }\n      };\n\n      generateFace(sides.FRONT, ws, hs);\n      generateFace(sides.BACK, ws, hs);\n      generateFace(sides.TOP, ws, ds);\n      generateFace(sides.BOTTOM, ws, ds);\n      generateFace(sides.RIGHT, ds, hs);\n      generateFace(sides.LEFT, ds, hs); // generate AABB\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = vcounter;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n\n  return Box;\n}(Geometry)) || _class);","map":{"version":3,"sources":["../../src/geometry/Box.ts"],"names":["primitiveUv1Padding","primitiveUv1PaddingScale","injectable","Box","widthSegments","heightSegments","depthSegments","halfExtents","vec3","ws","hs","ds","hex","hey","hez","corners","faceAxes","faceNormals","sides","FRONT","BACK","TOP","BOTTOM","RIGHT","LEFT","positions","normals","uvs","uvs1","indices","vcounter","generateFace","i","j","temp1","temp2","temp3","r","u","v","side","Math","aabb","generateAABBFromVertices","component","Uint32Array","dirty","name","data","Float32Array","arrayStride","stepMode","attributes","shaderLocation","offset","format"],"mappings":"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","sourcesContent":["import { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Geometry } from '.';\n\nexport interface IBoxGeometryParams {\n  halfExtents: vec3;\n  widthSegments: number;\n  heightSegments: number;\n  depthSegments: number;\n}\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\n\n@injectable()\n/**\n * borrow from playcanvas:\n * Creates a procedural box-shaped mesh\n */\nexport class Box extends Geometry<Partial<IBoxGeometryParams>> {\n  protected onEntityCreated() {\n    const {\n      widthSegments = 1,\n      heightSegments = 1,\n      depthSegments = 1,\n      halfExtents = vec3.fromValues(0.5, 0.5, 0.5),\n    } = this.config;\n    const ws = widthSegments;\n    const hs = heightSegments;\n    const ds = depthSegments;\n    const [hex, hey, hez] = halfExtents;\n\n    const corners = [\n      vec3.fromValues(-hex, -hey, hez),\n      vec3.fromValues(hex, -hey, hez),\n      vec3.fromValues(hex, hey, hez),\n      vec3.fromValues(-hex, hey, hez),\n      vec3.fromValues(hex, -hey, -hez),\n      vec3.fromValues(-hex, -hey, -hez),\n      vec3.fromValues(-hex, hey, -hez),\n      vec3.fromValues(hex, hey, -hez),\n    ];\n\n    const faceAxes = [\n      [0, 1, 3], // FRONT\n      [4, 5, 7], // BACK\n      [3, 2, 6], // TOP\n      [1, 0, 4], // BOTTOM\n      [1, 4, 2], // RIGHT\n      [5, 0, 6], // LEFT\n    ];\n\n    const faceNormals = [\n      [0, 0, 1], // FRONT\n      [0, 0, -1], // BACK\n      [0, 1, 0], // TOP\n      [0, -1, 0], // BOTTOM\n      [1, 0, 0], // RIGHT\n      [-1, 0, 0], // LEFT\n    ];\n\n    const sides = {\n      FRONT: 0,\n      BACK: 1,\n      TOP: 2,\n      BOTTOM: 3,\n      RIGHT: 4,\n      LEFT: 5,\n    };\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const uvs1: number[] = [];\n    const indices: number[] = [];\n    let vcounter = 0;\n\n    const generateFace = (\n      side: number,\n      uSegments: number,\n      vSegments: number,\n    ) => {\n      let u;\n      let v;\n      let i;\n      let j;\n\n      for (i = 0; i <= uSegments; i++) {\n        for (j = 0; j <= vSegments; j++) {\n          const temp1 = vec3.create();\n          const temp2 = vec3.create();\n          const temp3 = vec3.create();\n          const r = vec3.create();\n          vec3.lerp(\n            temp1,\n            corners[faceAxes[side][0]],\n            corners[faceAxes[side][1]],\n            i / uSegments,\n          );\n          vec3.lerp(\n            temp2,\n            corners[faceAxes[side][0]],\n            corners[faceAxes[side][2]],\n            j / vSegments,\n          );\n          vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);\n          vec3.add(r, temp1, temp3);\n          u = i / uSegments;\n          v = j / vSegments;\n\n          positions.push(r[0], r[1], r[2]);\n          normals.push(\n            faceNormals[side][0],\n            faceNormals[side][1],\n            faceNormals[side][2],\n          );\n          uvs.push(u, v);\n          // pack as 3x2\n          // 1/3 will be empty, but it's either that or stretched pixels\n          // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n          u /= 3;\n          v /= 3;\n          u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n          v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n          u += (side % 3) / 3;\n          v += Math.floor(side / 3) / 3;\n          uvs1.push(u, v);\n\n          if (i < uSegments && j < vSegments) {\n            indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n            indices.push(\n              vcounter + vSegments + 1,\n              vcounter + vSegments + 2,\n              vcounter + 1,\n            );\n          }\n\n          vcounter++;\n        }\n      }\n    };\n\n    generateFace(sides.FRONT, ws, hs);\n    generateFace(sides.BACK, ws, hs);\n    generateFace(sides.TOP, ws, ds);\n    generateFace(sides.BOTTOM, ws, ds);\n    generateFace(sides.RIGHT, ds, hs);\n    generateFace(sides.LEFT, ds, hs);\n\n    // generate AABB\n    const aabb = generateAABBFromVertices(positions);\n\n    const component = this.getComponent();\n    component.indices = Uint32Array.from(indices);\n    component.aabb = aabb;\n    component.vertexCount = vcounter;\n    component.attributes = [\n      {\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    ];\n\n    // TODO: barycentric & tangent\n  }\n}\n"]},"metadata":{},"sourceType":"module"}