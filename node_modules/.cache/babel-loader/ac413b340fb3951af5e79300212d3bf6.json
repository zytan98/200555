{"ast":null,"code":"/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  y: 0,\n  nodeWidthRatio: 0.05,\n  weight: false,\n  nodePaddingRatio: 0.1,\n  id: function (node) {\n    return node.id;\n  },\n  source: function (edge) {\n    return edge.source;\n  },\n  target: function (edge) {\n    return edge.target;\n  },\n  sourceWeight: function (edge) {\n    return edge.value || 1;\n  },\n  targetWeight: function (edge) {\n    return edge.value || 1;\n  },\n  sortBy: null\n};\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\n\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, function (node, id) {\n    // in edges, out edges\n    node.inEdges = edges.filter(function (edge) {\n      return \"\" + options.target(edge) === \"\" + id;\n    });\n    node.outEdges = edges.filter(function (edge) {\n      return \"\" + options.source(edge) === \"\" + id;\n    }); // frequency\n\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length; // weight\n\n    node.value = 0;\n    node.inEdges.forEach(function (edge) {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach(function (edge) {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\n\n\nfunction sortNodes(nodes, options) {\n  var sortMethods = {\n    weight: function (a, b) {\n      return b.value - a.value;\n    },\n    frequency: function (a, b) {\n      return b.frequency - a.frequency;\n    },\n    id: function (a, b) {\n      return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b));\n    }\n  };\n  var method = sortMethods[options.sortBy];\n\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction layoutNodes(nodes, options) {\n  var len = nodes.length;\n\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n\n  if (options.weight) {\n    var nodePaddingRatio_1 = options.nodePaddingRatio;\n\n    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n\n    var margin_1 = nodePaddingRatio_1 / (2 * len);\n    var nodeWidthRatio_1 = options.nodeWidthRatio;\n\n    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n\n    var totalValue_1 = 0;\n    nodes.forEach(function (node) {\n      totalValue_1 += node.value;\n    });\n    nodes.forEach(function (node) {\n      node.weight = node.value / totalValue_1;\n      node.width = node.weight * (1 - nodePaddingRatio_1);\n      node.height = nodeWidthRatio_1;\n    });\n    nodes.forEach(function (node, index) {\n      // x\n      var deltaX = 0;\n\n      for (var i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin_1;\n      }\n\n      var minX = node.minX = margin_1 + deltaX;\n      var maxX = node.maxX = node.minX + node.width;\n      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;\n      var maxY = node.maxY = minY + nodeWidthRatio_1;\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    var deltaX_1 = 1 / len;\n    nodes.forEach(function (node, index) {\n      node.x = (index + 0.5) * deltaX_1;\n      node.y = options.y;\n    });\n  }\n\n  return nodes;\n}\n\nfunction locatingEdges(nodeById, edges, options) {\n  if (options.weight) {\n    var valueById_1 = {};\n    forIn(nodeById, function (node, id) {\n      valueById_1[id] = node.value;\n    });\n    edges.forEach(function (edge) {\n      var sId = options.source(edge);\n      var tId = options.target(edge);\n      var sNode = nodeById[sId];\n      var tNode = nodeById[tId];\n\n      if (sNode && tNode) {\n        var sValue = valueById_1[sId];\n        var currentSValue = options.sourceWeight(edge);\n        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;\n        var sEnd = sStart + currentSValue / sNode.value * sNode.width;\n        valueById_1[sId] -= currentSValue;\n        var tValue = valueById_1[tId];\n        var currentTValue = options.targetWeight(edge);\n        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;\n        var tEnd = tStart + currentTValue / tNode.value * tNode.width;\n        valueById_1[tId] -= currentTValue;\n        var y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y]; // 将edge的source与target的id换为 sourceNode与targetNode\n\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach(function (edge) {\n      var sNode = nodeById[options.source(edge)];\n      var tNode = nodeById[options.target(edge)];\n\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y]; // 将edge的source与target的id换为 sourceNode与targetNode\n\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n\n  return edges;\n}\n\nexport function getDefaultOptions(options) {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\nexport function chordLayout(chordLayoutOptions, chordLayoutInputData) {\n  var options = getDefaultOptions(chordLayoutOptions);\n  var nodeById = {};\n  var nodes = chordLayoutInputData.nodes;\n  var links = chordLayoutInputData.links;\n  nodes.forEach(function (node) {\n    var id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  var outputNodes = layoutNodes(nodes, options);\n  var outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks\n  };\n}","map":{"version":3,"sources":["../../../src/utils/transform/chord.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nimport { NodeLinkData } from '../../types/relation-data';\n\nconst DEFAULT_OPTIONS: ChordLayoutOptions = {\n  y: 0,\n  nodeWidthRatio: 0.05, // width of the node, (0, 1)\n  weight: false,\n  nodePaddingRatio: 0.1, // margin ratio, [0, 1)\n  id: (node) => node.id,\n  source: (edge) => edge.source,\n  target: (edge) => edge.target,\n  sourceWeight: (edge) => edge.value || 1,\n  targetWeight: (edge) => edge.value || 1,\n  sortBy: null, // optional, id | weight | frequency | {function}\n};\n\nexport type ChordLayoutOptions = {\n  weight?: boolean;\n  y?: number;\n  nodeWidthRatio?: number; // 节点的宽度比例，对应于极坐标系的厚度，(0, 1)\n  nodePaddingRatio?: number; // 节点之间的间距的比例，[0, 1)\n  id?(node: any): any;\n  source?(edge: any): any;\n  target?(edge: any): any;\n  sourceWeight?(edge: any): number;\n  targetWeight?(edge: any): number;\n  sortBy?: 'id' | 'weight' | 'frequency' | null | ((a: any, b: any) => number);\n};\n\ntype OutputNode = {\n  readonly id: number;\n  readonly name: string;\n  // readonly depth: number;\n  readonly value: number;\n\n  // 用于绘制 polygon\n  x: number[];\n  y: number[];\n};\n\ntype OutputLink = {\n  readonly source: OutputNode;\n  readonly target: OutputNode;\n  readonly value: number;\n\n  // 用于绘制 edge\n  x?: number[];\n  y?: number[];\n};\n\ntype ChordLayoutOutputData = {\n  readonly nodes: OutputNode[];\n  readonly links: OutputLink[];\n};\n\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, (node, id) => {\n    // in edges, out edges\n    node.inEdges = edges.filter((edge) => `${options.target(edge)}` === `${id}`);\n    node.outEdges = edges.filter((edge) => `${options.source(edge)}` === `${id}`);\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach((edge) => {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach((edge) => {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\nfunction sortNodes(nodes, options) {\n  const sortMethods = {\n    weight: (a, b) => b.value - a.value,\n    frequency: (a, b) => b.frequency - a.frequency,\n    id: (a, b) => `${options.id(a)}`.localeCompare(`${options.id(b)}`),\n  };\n  let method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction layoutNodes(nodes, options): OutputNode[] {\n  const len = nodes.length;\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n  if (options.weight) {\n    const nodePaddingRatio = options.nodePaddingRatio;\n    if (nodePaddingRatio < 0 || nodePaddingRatio >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n    const margin = nodePaddingRatio / (2 * len);\n    const nodeWidthRatio = options.nodeWidthRatio;\n    if (nodeWidthRatio <= 0 || nodeWidthRatio >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n    let totalValue = 0;\n    nodes.forEach((node) => {\n      totalValue += node.value;\n    });\n    nodes.forEach((node) => {\n      node.weight = node.value / totalValue;\n      node.width = node.weight * (1 - nodePaddingRatio);\n      node.height = nodeWidthRatio;\n    });\n    nodes.forEach((node, index) => {\n      // x\n      let deltaX = 0;\n      for (let i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin;\n      }\n      const minX = (node.minX = margin + deltaX);\n      const maxX = (node.maxX = node.minX + node.width);\n      const minY = (node.minY = options.y - nodeWidthRatio / 2);\n      const maxY = (node.maxY = minY + nodeWidthRatio);\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    const deltaX = 1 / len;\n    nodes.forEach((node, index) => {\n      node.x = (index + 0.5) * deltaX;\n      node.y = options.y;\n    });\n  }\n  return nodes;\n}\n\nfunction locatingEdges(nodeById, edges, options): OutputLink[] {\n  if (options.weight) {\n    const valueById = {};\n    forIn(nodeById, (node, id) => {\n      valueById[id] = node.value;\n    });\n    edges.forEach((edge) => {\n      const sId = options.source(edge);\n      const tId = options.target(edge);\n      const sNode = nodeById[sId];\n      const tNode = nodeById[tId];\n      if (sNode && tNode) {\n        const sValue = valueById[sId];\n        const currentSValue = options.sourceWeight(edge);\n        const sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n        const sEnd = sStart + (currentSValue / sNode.value) * sNode.width;\n        valueById[sId] -= currentSValue;\n\n        const tValue = valueById[tId];\n        const currentTValue = options.targetWeight(edge);\n        const tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n        const tEnd = tStart + (currentTValue / tNode.value) * tNode.width;\n        valueById[tId] -= currentTValue;\n\n        const y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach((edge) => {\n      const sNode = nodeById[options.source(edge)];\n      const tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n  return edges;\n}\n\nexport function getDefaultOptions(options: ChordLayoutOptions): ChordLayoutOptions {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\n\nexport function chordLayout(\n  chordLayoutOptions: ChordLayoutOptions,\n  chordLayoutInputData: NodeLinkData\n): ChordLayoutOutputData {\n  const options = getDefaultOptions(chordLayoutOptions);\n  const nodeById = {};\n  const nodes = chordLayoutInputData.nodes;\n  const links = chordLayoutInputData.links;\n  nodes.forEach((node) => {\n    const id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  const outputNodes = layoutNodes(nodes, options);\n  const outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}