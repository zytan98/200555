{"ast":null,"code":"// @ts-ignore\nimport { copy, create, dot } from 'gl-vec2'; // @ts-ignore\n\nimport { computeMiter, direction, normal } from 'polyline-miter-util';\n\nfunction extrusions(positions, out, point, normal, scale) {\n  addNext(out, normal, -scale);\n  addNext(out, normal, scale);\n  positions.push(point);\n  positions.push(point);\n}\n\nfunction addNext(out, normal, length) {\n  out.push([[normal[0], normal[1]], length]);\n}\n\nexport default function (points, closed, indexOffset) {\n  var lineA = [0, 0];\n  var lineB = [0, 0];\n  var tangent = [0, 0];\n  var miter = [0, 0];\n\n  var _lastFlip = -1;\n\n  var _started = false;\n  var _normal = null;\n  var tmp = create();\n  var count = indexOffset || 0;\n  var miterLimit = 3;\n  var out = [];\n  var attrPos = [];\n  var attrIndex = [];\n  var attrCounters = [0, 0];\n\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  var total = points.length;\n\n  for (var i = 1; i < total; i++) {\n    var index = count;\n    var last = points[i - 1];\n    var cur = points[i];\n    var next = i < points.length - 1 ? points[i + 1] : null;\n    attrCounters.push(i / total, i / total);\n    direction(lineA, cur, last);\n\n    if (!_normal) {\n      _normal = [0, 0];\n      normal(_normal, lineA);\n    }\n\n    if (!_started) {\n      _started = true;\n      extrusions(attrPos, out, last, _normal, 1);\n    }\n\n    attrIndex.push([index + 0, index + 1, index + 2]);\n\n    if (!next) {\n      // no miter, simple segment\n      normal(_normal, lineA); // reset normal\n\n      extrusions(attrPos, out, cur, _normal, 1);\n      attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n      count += 2;\n    } else {\n      // miter with last\n      // get unit dir of next line\n      direction(lineB, next, cur); // stores tangent & miter\n\n      var miterLen = computeMiter(tangent, miter, lineA, lineB, 1); // get orientation\n\n      var flip = dot(tangent, _normal) < 0 ? -1 : 1;\n      var bevel = miterLen > miterLimit; // 处理相邻线段重叠的情况\n\n      if (!isFinite(miterLen)) {\n        normal(_normal, lineA); // reset normal\n\n        extrusions(attrPos, out, cur, _normal, 1);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        count += 2;\n        _lastFlip = flip;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        attrCounters.push(i / total); // next two points in our first segment\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n        addNext(out, miter, miterLen * flip);\n        attrPos.push(cur);\n        attrIndex.push(_lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]); // now add the bevel triangle\n\n        attrIndex.push([index + 2, index + 3, index + 4]);\n        normal(tmp, lineB);\n        copy(_normal, tmp); // store normal for next round\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur); // the miter is now the normal for our next join\n\n        count += 3;\n      } else {\n        // miter\n        // next two points for our miter join\n        extrusions(attrPos, out, cur, miter, miterLen);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        flip = -1; // the miter is now the normal for our next join\n\n        copy(_normal, miter);\n        count += 2;\n      }\n\n      _lastFlip = flip;\n    }\n  }\n\n  return {\n    normals: out,\n    attrIndex: attrIndex,\n    attrPos: attrPos,\n    attrCounters: attrCounters\n  };\n}","map":{"version":3,"sources":["../../src/utils/polyline-normals.ts"],"names":["addNext","positions","out","normal","lineA","lineB","tangent","miter","_lastFlip","_started","_normal","tmp","create","count","indexOffset","miterLimit","attrPos","attrIndex","attrCounters","points","total","i","index","last","cur","next","direction","extrusions","miterLen","computeMiter","flip","dot","bevel","isFinite","copy","normals"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport { copy, create, dot } from 'gl-vec2';\n// @ts-ignore\nimport { computeMiter, direction, normal } from 'polyline-miter-util';\n\nfunction extrusions(\n  positions: number[][],\n  out: any,\n  point: number[],\n  normal: number[],\n  scale: number,\n) {\n  addNext(out, normal, -scale);\n  addNext(out, normal, scale);\n  positions.push(point);\n  positions.push(point);\n}\n\nfunction addNext(out: any[][], normal: number[], length: number) {\n  out.push([[normal[0], normal[1]], length]);\n}\n\nexport default function(\n  points: number[][],\n  closed: boolean,\n  indexOffset?: number,\n) {\n  const lineA = [0, 0];\n  const lineB = [0, 0];\n  const tangent = [0, 0];\n  const miter = [0, 0];\n  let _lastFlip = -1;\n  let _started = false;\n  let _normal: any = null;\n  const tmp = create();\n  let count = indexOffset || 0;\n  const miterLimit = 3;\n\n  const out: any = [];\n  const attrPos: number[][] = [];\n  const attrIndex = [];\n  const attrCounters: number[] = [0, 0];\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  const total = points.length;\n  for (let i = 1; i < total; i++) {\n    const index = count;\n    const last = points[i - 1];\n    const cur = points[i];\n    const next = i < points.length - 1 ? points[i + 1] : null;\n\n    attrCounters.push(i / total, i / total);\n\n    direction(lineA, cur, last);\n\n    if (!_normal) {\n      _normal = [0, 0];\n      normal(_normal, lineA);\n    }\n\n    if (!_started) {\n      _started = true;\n      extrusions(attrPos, out, last, _normal, 1);\n    }\n\n    attrIndex.push([index + 0, index + 1, index + 2]);\n\n    if (!next) {\n      // no miter, simple segment\n      normal(_normal, lineA); // reset normal\n      extrusions(attrPos, out, cur, _normal, 1);\n      attrIndex.push(\n        _lastFlip === 1\n          ? [index, index + 2, index + 3]\n          : [index + 2, index + 1, index + 3],\n      );\n\n      count += 2;\n    } else {\n      // miter with last\n      // get unit dir of next line\n      direction(lineB, next, cur);\n\n      // stores tangent & miter\n      let miterLen = computeMiter(tangent, miter, lineA, lineB, 1);\n\n      // get orientation\n      let flip = dot(tangent, _normal) < 0 ? -1 : 1;\n\n      const bevel = miterLen > miterLimit;\n\n      // 处理相邻线段重叠的情况\n      if (!isFinite(miterLen)) {\n        normal(_normal, lineA); // reset normal\n        extrusions(attrPos, out, cur, _normal, 1);\n        attrIndex.push(\n          _lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        count += 2;\n        _lastFlip = flip;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        attrCounters.push(i / total);\n\n        // next two points in our first segment\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n        addNext(out, miter, miterLen * flip);\n        attrPos.push(cur);\n\n        attrIndex.push(\n          _lastFlip !== -flip\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        // now add the bevel triangle\n        attrIndex.push([index + 2, index + 3, index + 4]);\n\n        normal(tmp, lineB);\n        copy(_normal, tmp); // store normal for next round\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n\n        // the miter is now the normal for our next join\n        count += 3;\n      } else {\n        // miter\n        // next two points for our miter join\n        extrusions(attrPos, out, cur, miter, miterLen);\n        attrIndex.push(\n          _lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        copy(_normal, miter);\n        count += 2;\n      }\n      _lastFlip = flip;\n    }\n  }\n\n  return {\n    normals: out,\n    attrIndex,\n    attrPos,\n    attrCounters,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}