{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n/**\n * implements renderService with WebGPU API\n * @see https://webgpu.io/\n * @see https://github.com/BabylonJS/Babylon.js/blob/WebGPU/src/Engines/webgpuEngine.ts\n */\n\n\nimport { isSafari } from '@antv/g-webgpu-core'; // import { Glslang } from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { injectable } from 'inversify';\nimport glslang from './glslang';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUComputeModel from './WebGPUComputeModel';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUModel from './WebGPUModel';\nimport WebGPUTexture2D from './WebGPUTexture2D';\nexport\n/**\n * regl renderer\n */\nvar WebGPUEngine = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGPUEngine() {\n    var _this = this;\n\n    _classCallCheck(this, WebGPUEngine);\n\n    this.supportWebGPU = true;\n    this.useWGSL = false;\n    this.options = void 0;\n    this.canvas = void 0;\n    this.context = void 0;\n    this.glslang = void 0;\n    this.adapter = void 0;\n    this.device = void 0;\n    this.swapChain = void 0;\n    this.mainPassSampleCount = void 0;\n    this.mainTexture = void 0;\n    this.depthTexture = void 0;\n    this.mainColorAttachments = void 0;\n    this.mainTextureExtends = void 0;\n    this.mainDepthAttachment = void 0;\n    this.uploadEncoder = void 0;\n    this.renderEncoder = void 0;\n    this.computeEncoder = void 0;\n    this.renderTargetEncoder = void 0;\n    this.commandBuffers = new Array(4).fill(undefined);\n    this.currentRenderPass = null;\n    this.mainRenderPass = null;\n    this.currentRenderTargetViewDescriptor = void 0;\n    this.currentComputePass = null;\n    this.bundleEncoder = void 0;\n    this.tempBuffers = [];\n    this.currentRenderTarget = null;\n    this.uploadEncoderDescriptor = {\n      label: 'upload'\n    };\n    this.renderEncoderDescriptor = {\n      label: 'render'\n    };\n    this.renderTargetEncoderDescriptor = {\n      label: 'renderTarget'\n    };\n    this.computeEncoderDescriptor = {\n      label: 'compute'\n    };\n    this.pipelines = {};\n    this.computePipelines = {};\n    this.defaultSampleCount = 4;\n    this.clearDepthValue = 1;\n    this.clearStencilValue = 0;\n    this.transientViewport = {\n      x: Infinity,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n\n    this.clear = function (options) {\n      var framebuffer = options.framebuffer,\n          color = options.color,\n          depth = options.depth,\n          stencil = options.stencil;\n\n      if (_this.options.supportCompute) {\n        _this.startComputePass();\n      } // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n\n\n      if (_this.currentRenderTarget) {\n        if (_this.currentRenderPass) {\n          _this.endRenderTargetRenderPass();\n        }\n\n        _this.startRenderTargetRenderPass(_this.currentRenderTarget, color ? color : null, !!depth, !!stencil);\n      } else {\n        // if (this.useReverseDepthBuffer) {\n        //     this._depthCullingState.depthFunc = Constants.GREATER;\n        // }\n        _this.mainColorAttachments[0].loadValue = color ? color : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.depthLoadValue = depth ? depth : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.stencilLoadValue = stencil ? _this.clearStencilValue : WebGPUConstants.LoadOp.Load;\n\n        if (_this.mainRenderPass) {\n          _this.endMainRenderPass();\n        }\n\n        _this.startMainRenderPass();\n      }\n    };\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                model = new WebGPUModel(_this, options);\n                _context.next = 3;\n                return model.init();\n\n              case 3:\n                return _context.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new WebGPUAttribute(_this, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new WebGPUBuffer(_this, options);\n    };\n\n    this.createElements = function (options) {\n      return new WebGPUElements(_this, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new WebGPUTexture2D(_this, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new WebGPUFramebuffer(_this, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      // bind\n      if (_this.currentRenderTarget) {\n        _this.unbindFramebuffer(_this.currentRenderTarget);\n      }\n\n      _this.currentRenderTarget = framebuffer; // TODO: use mipmap options in framebuffer\n\n      _this.currentRenderTargetViewDescriptor = {\n        dimension: WebGPUConstants.TextureViewDimension.E2d,\n        // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n        // baseArrayLayer: faceIndex,\n        // baseMipLevel: lodLevel,\n        arrayLayerCount: 1,\n        aspect: WebGPUConstants.TextureAspect.All\n      };\n      _this.currentRenderPass = null;\n      drawCommands();\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                model = new WebGPUComputeModel(_this, context);\n                _context2.next = 3;\n                return model.init();\n\n              case 3:\n                return _context2.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.getCanvas = function () {\n      return _this.canvas;\n    };\n\n    this.getGLContext = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    this.viewport = function (_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          width = _ref3.width,\n          height = _ref3.height;\n\n      if (!_this.currentRenderPass) {\n        // call viewport() before current render pass created\n        _this.transientViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      } else if (_this.transientViewport.x !== Infinity) {\n        var renderPass = _this.getCurrentRenderPass(); // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n\n\n        renderPass.setViewport(_this.transientViewport.x, _this.transientViewport.y, _this.transientViewport.width, _this.transientViewport.height, 0, 1);\n      } else if (x !== _this.cachedViewport.x || y !== _this.cachedViewport.y || width !== _this.cachedViewport.width || height !== _this.cachedViewport.height) {\n        _this.cachedViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n\n        var _renderPass = _this.getCurrentRenderPass();\n\n        _renderPass.setViewport(x, y, width, height, 0, 1);\n      }\n    };\n\n    this.readPixels = function (options) {\n      throw new Error('Method not implemented.');\n    };\n  }\n\n  _createClass(WebGPUEngine, [{\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      return true;\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(config) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.canvas = config.canvas;\n                this.options = config;\n                this.useWGSL = !!config.useWGSL;\n                this.mainPassSampleCount = config.antialiasing ? this.defaultSampleCount : 1;\n                _context3.next = 6;\n                return this.initGlslang();\n\n              case 6:\n                this.initContextAndSwapChain();\n                this.initMainAttachments();\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function init(_x3) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"setScissor\",\n    value: function setScissor(scissor) {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.tempBuffers.forEach(function (buffer) {\n        return buffer.destroy();\n      });\n      this.tempBuffers = [];\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {\n      this.uploadEncoder = this.device.createCommandEncoder(this.uploadEncoderDescriptor);\n      this.renderEncoder = this.device.createCommandEncoder(this.renderEncoderDescriptor);\n      this.renderTargetEncoder = this.device.createCommandEncoder(this.renderTargetEncoderDescriptor);\n\n      if (this.options.supportCompute) {\n        this.computeEncoder = this.device.createCommandEncoder(this.computeEncoderDescriptor);\n      }\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {\n      if (this.options.supportCompute) {\n        this.endComputePass();\n      }\n\n      this.endMainRenderPass();\n      this.commandBuffers[0] = this.uploadEncoder.finish();\n      this.commandBuffers[1] = this.renderEncoder.finish();\n\n      if (this.options.supportCompute) {\n        this.commandBuffers[2] = this.computeEncoder.finish();\n      }\n\n      this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n      if (isSafari) {\n        this.device // @ts-ignore\n        .getQueue().submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      } else {\n        this.device.defaultQueue.submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      }\n    }\n  }, {\n    key: \"getCurrentRenderPass\",\n    value: function getCurrentRenderPass() {\n      if (this.currentRenderTarget && !this.currentRenderPass) {\n        this.startRenderTargetRenderPass(this.currentRenderTarget, null, false, false);\n      } else if (!this.currentRenderPass) {\n        this.startMainRenderPass();\n      }\n\n      return this.currentRenderPass;\n    }\n  }, {\n    key: \"initGlslang\",\n    value: function () {\n      var _initGlslang = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _navigator, _navigator$gpu;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return glslang();\n\n              case 2:\n                this.glslang = _context4.sent;\n                _context4.next = 5;\n                return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$gpu = _navigator.gpu) === null || _navigator$gpu === void 0 ? void 0 : _navigator$gpu.requestAdapter();\n\n              case 5:\n                this.adapter = _context4.sent;\n                _context4.next = 8;\n                return this.adapter.requestDevice();\n\n              case 8:\n                this.device = _context4.sent;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function initGlslang() {\n        return _initGlslang.apply(this, arguments);\n      }\n\n      return initGlslang;\n    }()\n  }, {\n    key: \"initContextAndSwapChain\",\n    value: function initContextAndSwapChain() {\n      this.context = this.canvas.getContext(isSafari ? 'gpu' : 'gpupresent');\n      this.swapChain = this.context.configureSwapChain({\n        device: this.device,\n        format: this.options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment | WebGPUConstants.TextureUsage.CopySrc\n      });\n    }\n  }, {\n    key: \"initMainAttachments\",\n    value: function initMainAttachments() {\n      this.mainTextureExtends = {\n        width: this.canvas.width,\n        height: this.canvas.height,\n        depth: 1\n      };\n\n      if (this.options.antialiasing) {\n        var mainTextureDescriptor = {\n          size: this.mainTextureExtends,\n          // TODO: arrayLayerCount is deprecated: use size.depth\n          // arrayLayerCount: 1,\n          mipLevelCount: 1,\n          sampleCount: this.mainPassSampleCount,\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n          usage: WebGPUConstants.TextureUsage.OutputAttachment\n        };\n\n        if (this.mainTexture) {\n          this.mainTexture.destroy();\n        }\n\n        this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.mainTexture.createDefaultView() : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      } else {\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      }\n\n      var depthTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: isSafari ? 'depth32float-stencil8' : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment\n      };\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.depthTexture = this.device.createTexture( // @ts-ignore\n      depthTextureDescriptor);\n      this.mainDepthAttachment = {\n        attachment: isSafari ? // @ts-ignore\n        this.depthTexture.createDefaultView() : this.depthTexture.createView(),\n        depthLoadValue: this.clearDepthValue,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilLoadValue: this.clearStencilValue,\n        stencilStoreOp: WebGPUConstants.StoreOp.Store\n      };\n    }\n  }, {\n    key: \"startComputePass\",\n    value: function startComputePass() {\n      if (this.currentComputePass) {\n        this.endComputePass();\n      }\n\n      this.currentComputePass = this.computeEncoder.beginComputePass();\n    }\n  }, {\n    key: \"startMainRenderPass\",\n    value: function startMainRenderPass() {\n      if (this.currentRenderPass && !this.currentRenderTarget) {\n        this.endMainRenderPass();\n      } // Resolve in case of MSAA\n\n\n      if (this.options.antialiasing) {\n        this.mainColorAttachments[0].resolveTarget = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      } else {\n        this.mainColorAttachments[0].attachment = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      }\n\n      this.currentRenderPass = this.renderEncoder.beginRenderPass({\n        colorAttachments: this.mainColorAttachments,\n        depthStencilAttachment: this.mainDepthAttachment // TODO: use framebuffer's depth & stencil\n\n      });\n      this.mainRenderPass = this.currentRenderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      }\n    }\n  }, {\n    key: \"startRenderTargetRenderPass\",\n    value: function startRenderTargetRenderPass(renderTarget, clearColor, clearDepth) {\n      var _renderTarget$get$col, _renderTarget$get$dep;\n\n      var clearStencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var gpuTexture = (_renderTarget$get$col = renderTarget.get().color) === null || _renderTarget$get$col === void 0 ? void 0 : _renderTarget$get$col.texture;\n      var colorTextureView;\n\n      if (gpuTexture) {\n        colorTextureView = gpuTexture.createView(this.currentRenderTargetViewDescriptor);\n      }\n\n      var depthStencilTexture = (_renderTarget$get$dep = renderTarget.get().depth) === null || _renderTarget$get$dep === void 0 ? void 0 : _renderTarget$get$dep.texture;\n      var depthStencilTextureView;\n\n      if (depthStencilTexture) {\n        depthStencilTextureView = depthStencilTexture.createView();\n      }\n\n      var renderPass = this.renderTargetEncoder.beginRenderPass({\n        colorAttachments: [{\n          attachment: colorTextureView,\n          loadValue: clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }],\n        depthStencilAttachment: depthStencilTexture && depthStencilTextureView ? {\n          attachment: depthStencilTextureView,\n          depthLoadValue: clearDepth ? this.clearDepthValue : WebGPUConstants.LoadOp.Load,\n          depthStoreOp: WebGPUConstants.StoreOp.Store,\n          stencilLoadValue: clearStencil ? this.clearStencilValue : WebGPUConstants.LoadOp.Load,\n          stencilStoreOp: WebGPUConstants.StoreOp.Store\n        } : undefined\n      });\n      this.currentRenderPass = renderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      } // TODO WEBGPU set the scissor rect and the stencil reference value\n\n    }\n  }, {\n    key: \"endMainRenderPass\",\n    value: function endMainRenderPass() {\n      if (this.currentRenderPass === this.mainRenderPass && this.currentRenderPass !== null) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n        this.currentRenderPass = null;\n        this.mainRenderPass = null;\n      }\n    }\n  }, {\n    key: \"endComputePass\",\n    value: function endComputePass() {\n      if (this.currentComputePass) {\n        this.currentComputePass.endPass();\n        this.currentComputePass = null;\n      }\n    }\n  }, {\n    key: \"endRenderTargetRenderPass\",\n    value: function endRenderTargetRenderPass() {\n      if (this.currentRenderPass) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n      }\n    }\n  }, {\n    key: \"resetCachedViewport\",\n    value: function resetCachedViewport() {\n      this.cachedViewport = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"unbindFramebuffer\",\n    value: function unbindFramebuffer(framebuffer) {\n      // unbind\n      if (this.currentRenderPass && this.currentRenderPass !== this.mainRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n\n      this.transientViewport.x = Infinity;\n      this.currentRenderTarget = null; // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      //   this._generateMipmaps(texture);\n      // }\n\n      this.currentRenderPass = this.mainRenderPass;\n    }\n  }]);\n\n  return WebGPUEngine;\n}(), _temp)) || _class);","map":{"version":3,"sources":["../../src/webgpu/index.ts"],"names":["injectable","WebGPUEngine","label","x","y","width","height","config","framebuffer","color","depth","stencil","options","WebGPUConstants","model","dimension","arrayLayerCount","aspect","All","drawCommands","renderPass","buffer","glslang","navigator","isSafari","device","format","usage","CopySrc","mainTextureDescriptor","size","mipLevelCount","sampleCount","OutputAttachment","attachment","loadValue","storeOp","Store","depthTextureDescriptor","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","colorAttachments","depthStencilAttachment","clearStencil","gpuTexture","renderTarget","colorTextureView","depthStencilTexture","depthStencilTextureView","clearColor","clearDepth","undefined"],"mappings":"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","sourcesContent":["/**\n * implements renderService with WebGPU API\n * @see https://webgpu.io/\n * @see https://github.com/BabylonJS/Babylon.js/blob/WebGPU/src/Engines/webgpuEngine.ts\n */\nimport {\n  GLSLContext,\n  IAttribute,\n  IAttributeInitializationOptions,\n  IBuffer,\n  IBufferInitializationOptions,\n  IClearOptions,\n  IElements,\n  IElementsInitializationOptions,\n  IFramebuffer,\n  IFramebufferInitializationOptions,\n  IModel,\n  IModelInitializationOptions,\n  IReadPixelsOptions,\n  IRendererConfig,\n  IRendererService,\n  isSafari,\n  ITexture2D,\n  ITexture2DInitializationOptions,\n  IViewport,\n} from '@antv/g-webgpu-core';\n// import { Glslang } from '@webgpu/glslang/dist/web-devel/glslang.onefile';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { vec4 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport glslang from './glslang';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUComputeModel from './WebGPUComputeModel';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUModel from './WebGPUModel';\nimport WebGPUTexture2D from './WebGPUTexture2D';\n\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/**\n * regl renderer\n */\n@injectable()\nexport class WebGPUEngine implements IRendererService {\n  public supportWebGPU = true;\n  public useWGSL = false;\n\n  public options: IRendererConfig;\n  public canvas: HTMLCanvasElement;\n  public context: GPUCanvasContext;\n  public glslang: any;\n  public adapter: GPUAdapter;\n  public device: GPUDevice;\n  public swapChain: GPUSwapChain;\n\n  public mainPassSampleCount: number;\n\n  public mainTexture: GPUTexture;\n  public depthTexture: GPUTexture;\n  public mainColorAttachments: GPURenderPassColorAttachmentDescriptor[];\n  public mainTextureExtends: GPUExtent3D;\n  public mainDepthAttachment: GPURenderPassDepthStencilAttachmentDescriptor;\n\n  // Frame Life Cycle (recreated each frame)\n  public uploadEncoder: GPUCommandEncoder;\n  public renderEncoder: GPUCommandEncoder;\n  public computeEncoder: GPUCommandEncoder;\n  public renderTargetEncoder: GPUCommandEncoder;\n  public commandBuffers: GPUCommandBuffer[] = new Array(4).fill(undefined);\n\n  // Frame Buffer Life Cycle (recreated for each render target pass)\n  public currentRenderPass: GPURenderPassEncoder | null = null;\n  public mainRenderPass: GPURenderPassEncoder | null = null;\n  public currentRenderTargetViewDescriptor: GPUTextureViewDescriptor;\n  public currentComputePass: GPUComputePassEncoder | null = null;\n  public bundleEncoder: GPURenderBundleEncoder | null;\n  public tempBuffers: GPUBuffer[] = [];\n  public currentRenderTarget: WebGPUFramebuffer | null = null;\n\n  public readonly uploadEncoderDescriptor = { label: 'upload' };\n  public readonly renderEncoderDescriptor = { label: 'render' };\n  public readonly renderTargetEncoderDescriptor = { label: 'renderTarget' };\n  public readonly computeEncoderDescriptor = { label: 'compute' };\n\n  /**\n   * 通过名称访问\n   */\n  private pipelines: {\n    [pipelineName: string]: GPURenderPipeline;\n  } = {};\n  private computePipelines: {\n    [pipelineName: string]: GPUComputePipeline;\n  } = {};\n\n  private readonly defaultSampleCount = 4;\n  private readonly clearDepthValue = 1;\n  private readonly clearStencilValue = 0;\n  private transientViewport: IViewport = {\n    x: Infinity,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n  private cachedViewport: IViewport = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  public isFloatSupported() {\n    return true;\n  }\n\n  public async init(config: IRendererConfig): Promise<void> {\n    this.canvas = config.canvas!;\n    this.options = config;\n    this.useWGSL = !!config.useWGSL;\n    this.mainPassSampleCount = config.antialiasing\n      ? this.defaultSampleCount\n      : 1;\n\n    await this.initGlslang();\n    this.initContextAndSwapChain();\n    this.initMainAttachments();\n  }\n\n  public setScissor(\n    scissor: Partial<{\n      enable: boolean;\n      box: { x: number; y: number; width: number; height: number };\n    }>,\n  ): void {\n    throw new Error('Method not implemented.');\n  }\n\n  public clear = (options: IClearOptions): void => {\n    const { framebuffer, color, depth, stencil } = options;\n\n    if (this.options.supportCompute) {\n      this.startComputePass();\n    }\n\n    // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n    if (this.currentRenderTarget) {\n      if (this.currentRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n      this.startRenderTargetRenderPass(\n        this.currentRenderTarget!,\n        color ? color : null,\n        !!depth,\n        !!stencil,\n      );\n    } else {\n      // if (this.useReverseDepthBuffer) {\n      //     this._depthCullingState.depthFunc = Constants.GREATER;\n      // }\n\n      this.mainColorAttachments[0].loadValue = color\n        ? color\n        : WebGPUConstants.LoadOp.Load;\n\n      this.mainDepthAttachment.depthLoadValue = depth\n        ? depth\n        : WebGPUConstants.LoadOp.Load;\n      this.mainDepthAttachment.stencilLoadValue = stencil\n        ? this.clearStencilValue\n        : WebGPUConstants.LoadOp.Load;\n\n      if (this.mainRenderPass) {\n        this.endMainRenderPass();\n      }\n\n      this.startMainRenderPass();\n    }\n  };\n\n  public createModel = async (\n    options: IModelInitializationOptions,\n  ): Promise<IModel> => {\n    const model = new WebGPUModel(this, options);\n    await model.init();\n    return model;\n  };\n\n  public createAttribute = (\n    options: IAttributeInitializationOptions,\n  ): IAttribute => {\n    return new WebGPUAttribute(this, options);\n  };\n\n  public createBuffer = (options: IBufferInitializationOptions): IBuffer => {\n    return new WebGPUBuffer(this, options);\n  };\n\n  public createElements = (\n    options: IElementsInitializationOptions,\n  ): IElements => {\n    return new WebGPUElements(this, options);\n  };\n\n  public createTexture2D = (\n    options: ITexture2DInitializationOptions,\n  ): ITexture2D => {\n    return new WebGPUTexture2D(this, options);\n  };\n\n  public createFramebuffer = (\n    options: IFramebufferInitializationOptions,\n  ): IFramebuffer => {\n    return new WebGPUFramebuffer(this, options);\n  };\n\n  public useFramebuffer = (\n    framebuffer: IFramebuffer | null,\n    drawCommands: () => void,\n  ): void => {\n    // bind\n    if (this.currentRenderTarget) {\n      this.unbindFramebuffer(this.currentRenderTarget);\n    }\n    this.currentRenderTarget = framebuffer as WebGPUFramebuffer;\n\n    // TODO: use mipmap options in framebuffer\n    this.currentRenderTargetViewDescriptor = {\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n      // baseArrayLayer: faceIndex,\n      // baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All,\n    };\n\n    this.currentRenderPass = null;\n\n    drawCommands();\n  };\n\n  public createComputeModel = async (context: GLSLContext) => {\n    const model = new WebGPUComputeModel(this, context);\n    await model.init();\n    return model;\n  };\n\n  public getCanvas = (): HTMLCanvasElement => {\n    return this.canvas;\n  };\n\n  public getGLContext = (): WebGLRenderingContext => {\n    throw new Error('Method not implemented.');\n  };\n\n  public viewport = ({\n    x,\n    y,\n    width,\n    height,\n  }: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  }): void => {\n    if (!this.currentRenderPass) {\n      // call viewport() before current render pass created\n      this.transientViewport = { x, y, width, height };\n    } else if (this.transientViewport.x !== Infinity) {\n      const renderPass = this.getCurrentRenderPass();\n      // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n      renderPass.setViewport(\n        this.transientViewport.x,\n        this.transientViewport.y,\n        this.transientViewport.width,\n        this.transientViewport.height,\n        0,\n        1,\n      );\n    } else if (\n      x !== this.cachedViewport.x ||\n      y !== this.cachedViewport.y ||\n      width !== this.cachedViewport.width ||\n      height !== this.cachedViewport.height\n    ) {\n      this.cachedViewport = { x, y, width, height };\n      const renderPass = this.getCurrentRenderPass();\n      renderPass.setViewport(x, y, width, height, 0, 1);\n    }\n  };\n\n  public readPixels = (options: IReadPixelsOptions): Uint8Array => {\n    throw new Error('Method not implemented.');\n  };\n\n  public destroy(): void {\n    if (this.mainTexture) {\n      this.mainTexture.destroy();\n    }\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n    }\n    this.tempBuffers.forEach((buffer) => buffer.destroy());\n    this.tempBuffers = [];\n  }\n\n  public beginFrame() {\n    this.uploadEncoder = this.device.createCommandEncoder(\n      this.uploadEncoderDescriptor,\n    );\n    this.renderEncoder = this.device.createCommandEncoder(\n      this.renderEncoderDescriptor,\n    );\n    this.renderTargetEncoder = this.device.createCommandEncoder(\n      this.renderTargetEncoderDescriptor,\n    );\n    if (this.options.supportCompute) {\n      this.computeEncoder = this.device.createCommandEncoder(\n        this.computeEncoderDescriptor,\n      );\n    }\n  }\n\n  public endFrame() {\n    if (this.options.supportCompute) {\n      this.endComputePass();\n    }\n\n    this.endMainRenderPass();\n\n    this.commandBuffers[0] = this.uploadEncoder.finish();\n    this.commandBuffers[1] = this.renderEncoder.finish();\n    if (this.options.supportCompute) {\n      this.commandBuffers[2] = this.computeEncoder.finish();\n    }\n    this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n    if (isSafari) {\n      this.device\n        // @ts-ignore\n        .getQueue()\n        .submit(this.commandBuffers.filter((buffer) => buffer));\n    } else {\n      this.device.defaultQueue.submit(\n        this.commandBuffers.filter((buffer) => buffer),\n      );\n    }\n  }\n\n  public getCurrentRenderPass(): GPURenderPassEncoder {\n    if (this.currentRenderTarget && !this.currentRenderPass) {\n      this.startRenderTargetRenderPass(\n        this.currentRenderTarget,\n        null,\n        false,\n        false,\n      );\n    } else if (!this.currentRenderPass) {\n      this.startMainRenderPass();\n    }\n\n    return this.currentRenderPass!;\n  }\n\n  private async initGlslang() {\n    this.glslang = await glslang();\n    this.adapter = (await navigator?.gpu?.requestAdapter()) as GPUAdapter;\n    this.device = (await this.adapter.requestDevice()) as GPUDevice;\n  }\n\n  private initContextAndSwapChain() {\n    this.context = (this.canvas.getContext(\n      isSafari ? 'gpu' : 'gpupresent',\n    ) as unknown) as GPUCanvasContext;\n    this.swapChain = this.context.configureSwapChain({\n      device: this.device,\n      format: this.options.swapChainFormat!,\n      usage:\n        WebGPUConstants.TextureUsage.OutputAttachment |\n        WebGPUConstants.TextureUsage.CopySrc,\n    });\n  }\n\n  private initMainAttachments() {\n    this.mainTextureExtends = {\n      width: this.canvas.width,\n      height: this.canvas.height,\n      depth: 1,\n    };\n\n    if (this.options.antialiasing) {\n      const mainTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // TODO: arrayLayerCount is deprecated: use size.depth\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment,\n      };\n\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n      this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n      this.mainColorAttachments = [\n        {\n          attachment: isSafari\n            ? // @ts-ignore\n              this.mainTexture.createDefaultView()\n            : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ];\n    } else {\n      this.mainColorAttachments = [\n        {\n          attachment: isSafari\n            ? // @ts-ignore\n              this.swapChain.getCurrentTexture().createDefaultView()\n            : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ];\n    }\n\n    const depthTextureDescriptor = {\n      size: this.mainTextureExtends,\n      // arrayLayerCount: 1,\n      mipLevelCount: 1,\n      sampleCount: this.mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: isSafari\n        ? 'depth32float-stencil8'\n        : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n      usage: WebGPUConstants.TextureUsage.OutputAttachment,\n    };\n\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n    }\n\n    this.depthTexture = this.device.createTexture(\n      // @ts-ignore\n      depthTextureDescriptor,\n    );\n    this.mainDepthAttachment = {\n      attachment: isSafari\n        ? // @ts-ignore\n          this.depthTexture.createDefaultView()\n        : this.depthTexture.createView(),\n      depthLoadValue: this.clearDepthValue,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilLoadValue: this.clearStencilValue,\n      stencilStoreOp: WebGPUConstants.StoreOp.Store,\n    };\n  }\n\n  private startComputePass() {\n    if (this.currentComputePass) {\n      this.endComputePass();\n    }\n\n    this.currentComputePass = this.computeEncoder.beginComputePass();\n  }\n\n  private startMainRenderPass() {\n    if (this.currentRenderPass && !this.currentRenderTarget) {\n      this.endMainRenderPass();\n    }\n\n    // Resolve in case of MSAA\n    if (this.options.antialiasing) {\n      this.mainColorAttachments[0].resolveTarget = isSafari\n        ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView()\n        : this.swapChain.getCurrentTexture().createView();\n    } else {\n      this.mainColorAttachments[0].attachment = isSafari\n        ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView()\n        : this.swapChain.getCurrentTexture().createView();\n    }\n\n    this.currentRenderPass = this.renderEncoder.beginRenderPass({\n      colorAttachments: this.mainColorAttachments,\n      depthStencilAttachment: this.mainDepthAttachment, // TODO: use framebuffer's depth & stencil\n    });\n\n    this.mainRenderPass = this.currentRenderPass;\n\n    if (this.cachedViewport) {\n      this.viewport(this.cachedViewport);\n    }\n  }\n\n  private startRenderTargetRenderPass(\n    renderTarget: WebGPUFramebuffer,\n    clearColor: [number, number, number, number] | null,\n    clearDepth: boolean,\n    clearStencil: boolean = false,\n  ) {\n    const gpuTexture = renderTarget.get().color?.texture;\n    let colorTextureView: GPUTextureView;\n    if (gpuTexture) {\n      colorTextureView = gpuTexture.createView(\n        this.currentRenderTargetViewDescriptor,\n      );\n    }\n\n    const depthStencilTexture = renderTarget.get().depth?.texture;\n    let depthStencilTextureView;\n    if (depthStencilTexture) {\n      depthStencilTextureView = depthStencilTexture.createView();\n    }\n\n    const renderPass = this.renderTargetEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: colorTextureView!,\n          loadValue:\n            clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ],\n      depthStencilAttachment:\n        depthStencilTexture && depthStencilTextureView\n          ? {\n              attachment: depthStencilTextureView,\n              depthLoadValue: clearDepth\n                ? this.clearDepthValue\n                : WebGPUConstants.LoadOp.Load,\n              depthStoreOp: WebGPUConstants.StoreOp.Store,\n              stencilLoadValue: clearStencil\n                ? this.clearStencilValue\n                : WebGPUConstants.LoadOp.Load,\n              stencilStoreOp: WebGPUConstants.StoreOp.Store,\n            }\n          : undefined,\n    });\n\n    this.currentRenderPass = renderPass;\n\n    if (this.cachedViewport) {\n      this.viewport(this.cachedViewport);\n    }\n\n    // TODO WEBGPU set the scissor rect and the stencil reference value\n  }\n\n  private endMainRenderPass() {\n    if (\n      this.currentRenderPass === this.mainRenderPass &&\n      this.currentRenderPass !== null\n    ) {\n      this.currentRenderPass.endPass();\n      this.resetCachedViewport();\n      this.currentRenderPass = null;\n      this.mainRenderPass = null;\n    }\n  }\n\n  private endComputePass() {\n    if (this.currentComputePass) {\n      this.currentComputePass.endPass();\n      this.currentComputePass = null;\n    }\n  }\n\n  private endRenderTargetRenderPass() {\n    if (this.currentRenderPass) {\n      this.currentRenderPass.endPass();\n      this.resetCachedViewport();\n    }\n  }\n\n  private resetCachedViewport() {\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    };\n  }\n\n  private unbindFramebuffer(framebuffer: WebGPUFramebuffer) {\n    // unbind\n    if (\n      this.currentRenderPass &&\n      this.currentRenderPass !== this.mainRenderPass\n    ) {\n      this.endRenderTargetRenderPass();\n    }\n\n    this.transientViewport.x = Infinity;\n    this.currentRenderTarget = null;\n\n    // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n    //   this._generateMipmaps(texture);\n    // }\n\n    this.currentRenderPass = this.mainRenderPass;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}