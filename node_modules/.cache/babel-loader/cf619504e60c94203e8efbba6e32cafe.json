{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nimport { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../identifier';\nexport var SceneGraphSystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.HierarchyComponentManager), _dec3 = inject(IDENTIFIER.TransformComponentManager), _dec4 = inject(IDENTIFIER.MeshComponentManager), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function SceneGraphSystem() {\n    _classCallCheck(this, SceneGraphSystem);\n\n    _initializerDefineProperty(this, \"hierarchy\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"transform\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"mesh\", _descriptor3, this);\n  }\n\n  _createClass(SceneGraphSystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.runTransformUpdateSystem();\n                this.runHierarchyUpdateSystem();\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.hierarchy.clear();\n      this.transform.clear();\n    }\n  }, {\n    key: \"getHierarchyComponentManager\",\n    value: function getHierarchyComponentManager() {\n      return this.hierarchy;\n    }\n  }, {\n    key: \"getTransformComponentManager\",\n    value: function getTransformComponentManager() {\n      return this.transform;\n    }\n  }, {\n    key: \"runTransformUpdateSystem\",\n    value: function runTransformUpdateSystem() {\n      var _this = this; // 原版基于 JobSystem 实现\n\n\n      this.transform.forEach(function (entity, transform) {\n        if (transform.isDirty() || transform.isLocalDirty()) {\n          _this.setMeshAABBDirty(_this.mesh.getComponentByEntity(entity));\n\n          transform.updateTransform();\n        }\n      });\n    }\n  }, {\n    key: \"runHierarchyUpdateSystem\",\n    value: function runHierarchyUpdateSystem() {\n      var _this2 = this;\n\n      this.hierarchy.forEach(function (entity, parentComponent) {\n        var transformChild = _this2.transform.getComponentByEntity(entity);\n\n        var transformParent = _this2.transform.getComponentByEntity(parentComponent.parentID);\n\n        if (transformChild !== null && transformParent !== null) {\n          transformChild.updateTransformWithParent(transformParent);\n        }\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(entity, parent, isChildAlreadyInLocalSpace) {\n      if (this.hierarchy.contains(entity)) {\n        this.detach(entity);\n      }\n\n      this.hierarchy.create(entity, {\n        parentID: parent\n      });\n      var mesh = this.mesh.getComponentByEntity(parent); // inform parent mesh to update its aabb\n\n      this.setMeshAABBDirty(mesh);\n\n      if (mesh && mesh.children.indexOf(entity) === -1) {\n        mesh.children.push(entity);\n      }\n\n      if (this.hierarchy.getCount() > 1) {\n        for (var i = this.hierarchy.getCount() - 1; i > 0; --i) {\n          var parentCandidateEntity = this.hierarchy.getEntity(i); // const parentCandidateComponent = this.hierarchy.getComponent(i);\n\n          for (var j = 0; j < i; ++j) {\n            var childCandidateEntity = this.hierarchy.getComponent(j);\n\n            if (childCandidateEntity.parentID === parentCandidateEntity) {\n              this.hierarchy.moveItem(i, j);\n              ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n\n              break;\n            }\n          }\n        }\n      } // Re-query parent after potential MoveItem(), because it invalidates references:\n\n\n      var parentcomponent = this.hierarchy.getComponentByEntity(entity);\n      var transformParent = this.transform.getComponentByEntity(parent);\n\n      if (transformParent === null) {\n        transformParent = this.transform.create(parent);\n      }\n\n      var transformChild = this.transform.getComponentByEntity(entity);\n\n      if (transformChild === null) {\n        transformChild = this.transform.create(entity); // after transforms.Create(), transform_parent pointer could have become invalidated!\n\n        transformParent = this.transform.getComponentByEntity(parent);\n      }\n\n      transformChild.parent = transformParent;\n\n      if (!isChildAlreadyInLocalSpace && transformParent) {\n        transformChild.matrixTransform(mat4.invert(mat4.create(), transformParent.worldTransform));\n        transformChild.updateTransform();\n      }\n\n      if (transformParent) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(entity) {\n      var self = this.hierarchy.getComponentByEntity(entity);\n\n      if (self !== null) {\n        var transform = this.transform.getComponentByEntity(entity);\n\n        if (transform !== null) {\n          transform.parent = null;\n          transform.applyTransform();\n        }\n\n        this.hierarchy.removeKeepSorted(entity); // inform parent mesh to update its aabb\n\n        var mesh = this.mesh.getComponentByEntity(self.parentID);\n\n        if (mesh) {\n          var index = mesh.children.indexOf(entity);\n          mesh.children.splice(index, 1);\n        }\n\n        this.setMeshAABBDirty(mesh);\n      }\n    }\n  }, {\n    key: \"detachChildren\",\n    value: function detachChildren(parent) {\n      var mesh = this.mesh.getComponentByEntity(parent);\n\n      if (mesh) {\n        mesh.children = [];\n      }\n\n      for (var i = 0; i < this.hierarchy.getCount();) {\n        var _this$hierarchy$getCo;\n\n        if (((_this$hierarchy$getCo = this.hierarchy.getComponent(i)) === null || _this$hierarchy$getCo === void 0 ? void 0 : _this$hierarchy$getCo.parentID) === parent) {\n          var entity = this.hierarchy.getEntity(i);\n          this.detach(entity);\n        } else {\n          ++i;\n        }\n      }\n    }\n  }, {\n    key: \"setMeshAABBDirty\",\n    value: function setMeshAABBDirty(mesh) {\n      if (mesh) {\n        mesh.aabbDirty = true;\n      }\n    }\n  }]);\n\n  return SceneGraphSystem;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"hierarchy\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"transform\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"mesh\", [_dec4], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"sources":["../../../src/components/scenegraph/System.ts"],"names":["injectable","SceneGraphSystem","inject","IDENTIFIER","transform","transformChild","transformParent","parentComponent","parentID","parent","mesh","i","parentCandidateEntity","j","childCandidateEntity","parentcomponent","mat4","self","index","entity"],"mappings":"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","sourcesContent":["import { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Entity, ISystem } from '../..';\nimport { Component } from '../../ComponentManager';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { MeshComponent } from '../mesh/MeshComponent';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { TransformComponent } from './TransformComponent';\n\n@injectable()\nexport class SceneGraphSystem implements ISystem {\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  public async execute() {\n    this.runTransformUpdateSystem();\n    this.runHierarchyUpdateSystem();\n  }\n\n  public tearDown() {\n    this.hierarchy.clear();\n    this.transform.clear();\n  }\n\n  public getHierarchyComponentManager() {\n    return this.hierarchy;\n  }\n\n  public getTransformComponentManager() {\n    return this.transform;\n  }\n\n  public runTransformUpdateSystem() {\n    // 原版基于 JobSystem 实现\n    this.transform.forEach((entity, transform) => {\n      if (transform.isDirty() || transform.isLocalDirty()) {\n        this.setMeshAABBDirty(this.mesh.getComponentByEntity(entity));\n        transform.updateTransform();\n      }\n    });\n  }\n\n  public runHierarchyUpdateSystem() {\n    this.hierarchy.forEach((entity, parentComponent) => {\n      const transformChild = this.transform.getComponentByEntity(entity);\n      const transformParent = this.transform.getComponentByEntity(\n        parentComponent.parentID,\n      );\n      if (transformChild !== null && transformParent !== null) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    });\n  }\n\n  public attach(\n    entity: Entity,\n    parent: Entity,\n    isChildAlreadyInLocalSpace?: boolean,\n  ) {\n    if (this.hierarchy.contains(entity)) {\n      this.detach(entity);\n    }\n\n    this.hierarchy.create(entity, {\n      parentID: parent,\n    });\n    const mesh = this.mesh.getComponentByEntity(parent);\n    // inform parent mesh to update its aabb\n    this.setMeshAABBDirty(mesh);\n    if (mesh && mesh.children.indexOf(entity) === -1) {\n      mesh.children.push(entity);\n    }\n\n    if (this.hierarchy.getCount() > 1) {\n      for (let i = this.hierarchy.getCount() - 1; i > 0; --i) {\n        const parentCandidateEntity = this.hierarchy.getEntity(i);\n        // const parentCandidateComponent = this.hierarchy.getComponent(i);\n        for (let j = 0; j < i; ++j) {\n          const childCandidateEntity = this.hierarchy.getComponent(j);\n\n          if (childCandidateEntity.parentID === parentCandidateEntity) {\n            this.hierarchy.moveItem(i, j);\n            ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n            break;\n          }\n        }\n      }\n    }\n\n    // Re-query parent after potential MoveItem(), because it invalidates references:\n    const parentcomponent = this.hierarchy.getComponentByEntity(entity);\n\n    let transformParent = this.transform.getComponentByEntity(parent);\n    if (transformParent === null) {\n      transformParent = this.transform.create(parent);\n    }\n\n    let transformChild = this.transform.getComponentByEntity(entity);\n    if (transformChild === null) {\n      transformChild = this.transform.create(entity);\n      // after transforms.Create(), transform_parent pointer could have become invalidated!\n      transformParent = this.transform.getComponentByEntity(parent);\n    }\n\n    transformChild.parent = transformParent;\n\n    if (!isChildAlreadyInLocalSpace && transformParent) {\n      transformChild.matrixTransform(\n        mat4.invert(mat4.create(), transformParent.worldTransform),\n      );\n      transformChild.updateTransform();\n    }\n    if (transformParent) {\n      transformChild.updateTransformWithParent(transformParent);\n    }\n  }\n\n  public detach(entity: Entity) {\n    const self = this.hierarchy.getComponentByEntity(entity);\n    if (self !== null) {\n      const transform = this.transform.getComponentByEntity(entity);\n      if (transform !== null) {\n        transform.parent = null;\n        transform.applyTransform();\n      }\n\n      this.hierarchy.removeKeepSorted(entity);\n\n      // inform parent mesh to update its aabb\n      const mesh = this.mesh.getComponentByEntity(self.parentID);\n      if (mesh) {\n        const index = mesh.children.indexOf(entity);\n        mesh.children.splice(index, 1);\n      }\n      this.setMeshAABBDirty(mesh);\n    }\n  }\n\n  public detachChildren(parent: Entity) {\n    const mesh = this.mesh.getComponentByEntity(parent);\n    if (mesh) {\n      mesh.children = [];\n    }\n    for (let i = 0; i < this.hierarchy.getCount(); ) {\n      if (this.hierarchy.getComponent(i)?.parentID === parent) {\n        const entity = this.hierarchy.getEntity(i);\n        this.detach(entity);\n      } else {\n        ++i;\n      }\n    }\n  }\n\n  private setMeshAABBDirty(\n    mesh: (Component<MeshComponent> & MeshComponent) | null,\n  ) {\n    if (mesh) {\n      mesh.aabbDirty = true;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}