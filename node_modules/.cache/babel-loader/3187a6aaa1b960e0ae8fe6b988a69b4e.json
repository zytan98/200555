{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { assign, memoize } from '@antv/util';\nimport { blend } from '../../utils/color/blend';\nimport { log, LEVEL } from '../../utils';\nimport { venn, scaleSolution } from './layout/layout';\nimport { intersectionAreaPath, computeTextCentres } from './layout/diagram';\nimport { ID_FIELD, PATH_FIELD } from './constant';\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\n\nexport var getColorMap = memoize(function (colorPalette, data, blendMode, setsField) {\n  var colorMap = new Map();\n  var colorPaletteLen = colorPalette.length;\n  data.forEach(function (d, idx) {\n    if (d[setsField].length === 1) {\n      colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n    } else {\n      /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n      var colorArr = d[setsField].map(function (id) {\n        return colorMap.get(id);\n      });\n      colorMap.set(d[ID_FIELD], colorArr.slice(1).reduce(function (a, b) {\n        return blend(a, b, blendMode);\n      }, colorArr[0]));\n    }\n  });\n  return colorMap;\n}, function () {\n  var params = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    params[_i] = arguments[_i];\n  }\n\n  return JSON.stringify(params);\n});\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\n\nexport function layoutVennData(options, width, height, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var data = options.data,\n      setsField = options.setsField,\n      sizeField = options.sizeField; // 处理空数据的情况\n\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n\n  var vennData = data.map(function (d) {\n    var _a;\n\n    return __assign(__assign({}, d), (_a = {\n      sets: d[setsField] || [],\n      size: d[sizeField]\n    }, _a[PATH_FIELD] = '', _a[ID_FIELD] = '', _a));\n  }); // 1. 进行排序，避免图形元素遮挡\n\n  vennData.sort(function (a, b) {\n    return a.sets.length - b.sets.length;\n  }); // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n\n  var solution = venn(vennData);\n  var circles = scaleSolution(solution, width, height, padding);\n  var textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach(function (row) {\n    var sets = row.sets;\n    var id = sets.join(',');\n    row[ID_FIELD] = id; // 保留 vennText 布局方法\n\n    var setCircles = sets.map(function (set) {\n      return circles[set];\n    });\n    var path = intersectionAreaPath(setCircles);\n\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n\n    row[PATH_FIELD] = path;\n    var center = textCenters[id] || {\n      x: 0,\n      y: 0\n    };\n    assign(row, center);\n  });\n  return vennData;\n}\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\n\nexport function islegalSets(legalArr, testArr) {\n  for (var i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["../../../src/plots/venn/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { assign, memoize } from '@antv/util';\nimport { blend } from '../../utils/color/blend';\nimport { log, LEVEL } from '../../utils';\nimport { venn, scaleSolution } from './layout/layout';\nimport { intersectionAreaPath, computeTextCentres } from './layout/diagram';\nimport { ID_FIELD, PATH_FIELD } from './constant';\nimport { VennData, VennOptions } from './types';\n\ntype ColorMapFunction = (\n  colorPalette: string[],\n  data: VennData,\n  blendMode: VennOptions['blendMode'],\n  setsField: VennOptions['setsField']\n) => Map<string, string>;\n\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\nexport const getColorMap = memoize(\n  ((colorPalette, data, blendMode, setsField) => {\n    const colorMap = new Map<string /** id */, string /** color */>();\n    const colorPaletteLen = colorPalette.length;\n    data.forEach((d, idx) => {\n      if (d[setsField].length === 1) {\n        colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n      } else {\n        /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n        const colorArr = d[setsField].map((id) => colorMap.get(id));\n        colorMap.set(\n          d[ID_FIELD],\n          colorArr.slice(1).reduce((a, b) => blend(a, b, blendMode), colorArr[0])\n        );\n      }\n    });\n\n    return colorMap;\n  }) as ColorMapFunction,\n  (...params) => JSON.stringify(params)\n) as ColorMapFunction;\n\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\nexport function layoutVennData(options: VennOptions, width: number, height: number, padding: number = 0): VennData {\n  const { data, setsField, sizeField } = options;\n\n  // 处理空数据的情况\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n\n  const vennData: VennData = data.map((d) => ({\n    ...d,\n    sets: d[setsField] || [],\n    size: d[sizeField],\n    [PATH_FIELD]: '',\n    [ID_FIELD]: '',\n  }));\n  // 1. 进行排序，避免图形元素遮挡\n  vennData.sort((a, b) => a.sets.length - b.sets.length);\n  // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n\n  const solution = venn(vennData);\n  const circles = scaleSolution(solution, width, height, padding);\n  const textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach((row) => {\n    const sets = row.sets;\n    const id = sets.join(',');\n    row[ID_FIELD] = id;\n    // 保留 vennText 布局方法\n    const setCircles = sets.map((set) => circles[set]);\n    let path = intersectionAreaPath(setCircles);\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n    row[PATH_FIELD] = path;\n    const center = textCenters[id] || { x: 0, y: 0 };\n    assign(row, center);\n  });\n  return vennData;\n}\n\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\nexport function islegalSets(legalArr: any[], testArr: any[]): boolean {\n  for (let i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}